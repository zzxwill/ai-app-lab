/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*
 * Modifications:
 *
 * The following changes have been made to the original code:
 * 1. Support login for Volcengine ECS
 * 2. Suport keyboard event in iframe
 */

var Guacamole = Guacamole || {};

/**
 * A reader which automatically handles the given input stream, returning
 * strictly received packets as array buffers. Note that this object will
 * overwrite any installed event handlers on the given Guacamole.InputStream.
 *
 * @constructor
 * @param {Guacamole.InputStream} stream The stream that data will be read
 *                                       from.
 */
Guacamole.ArrayBufferReader = function (stream) {
  /**
   * Reference to this Guacamole.InputStream.
   * @private
   */
  var guac_reader = this;

  // Receive blobs as array buffers
  stream.onblob = function (data) {
    // Convert to ArrayBuffer
    var binary = window.atob(data);
    var arrayBuffer = new ArrayBuffer(binary.length);
    var bufferView = new Uint8Array(arrayBuffer);

    for (var i = 0; i < binary.length; i++)
      bufferView[i] = binary.charCodeAt(i);

    // Call handler, if present
    if (guac_reader.ondata) guac_reader.ondata(arrayBuffer);
  };

  // Simply call onend when end received
  stream.onend = function () {
    if (guac_reader.onend) guac_reader.onend();
  };

  /**
   * Fired once for every blob of data received.
   *
   * @event
   * @param {ArrayBuffer} buffer The data packet received.
   */
  this.ondata = null;

  /**
   * Fired once this stream is finished and no further data will be written.
   * @event
   */
  this.onend = null;
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A writer which automatically writes to the given output stream with arbitrary
 * binary data, supplied as ArrayBuffers.
 *
 * @constructor
 * @param {Guacamole.OutputStream} stream The stream that data will be written
 *                                        to.
 */
Guacamole.ArrayBufferWriter = function (stream) {
  /**
   * Reference to this Guacamole.StringWriter.
   * @private
   */
  var guac_writer = this;

  // Simply call onack for acknowledgements
  stream.onack = function (status) {
    if (guac_writer.onack) guac_writer.onack(status);
  };

  /**
   * Encodes the given data as base64, sending it as a blob. The data must
   * be small enough to fit into a single blob instruction.
   *
   * @private
   * @param {Uint8Array} bytes The data to send.
   */
  function __send_blob(bytes) {
    var binary = "";

    // Produce binary string from bytes in buffer
    for (var i = 0; i < bytes.byteLength; i++)
      binary += String.fromCharCode(bytes[i]);

    // Send as base64
    stream.sendBlob(window.btoa(binary));
  }

  /**
   * The maximum length of any blob sent by this Guacamole.ArrayBufferWriter,
   * in bytes. Data sent via
   * [sendData()]{@link Guacamole.ArrayBufferWriter#sendData} which exceeds
   * this length will be split into multiple blobs. As the Guacamole protocol
   * limits the maximum size of any instruction or instruction element to
   * 8192 bytes, and the contents of blobs will be base64-encoded, this value
   * should only be increased with extreme caution.
   *
   * @type {Number}
   * @default {@link Guacamole.ArrayBufferWriter.DEFAULT_BLOB_LENGTH}
   */
  this.blobLength = Guacamole.ArrayBufferWriter.DEFAULT_BLOB_LENGTH;

  /**
   * Sends the given data.
   *
   * @param {ArrayBuffer|TypedArray} data The data to send.
   */
  this.sendData = function (data) {
    var bytes = new Uint8Array(data);

    // If small enough to fit into single instruction, send as-is
    if (bytes.length <= guac_writer.blobLength) __send_blob(bytes);
    // Otherwise, send as multiple instructions
    else {
      for (
        var offset = 0;
        offset < bytes.length;
        offset += guac_writer.blobLength
      )
        __send_blob(bytes.subarray(offset, offset + guac_writer.blobLength));
    }
  };

  /**
   * Signals that no further text will be sent, effectively closing the
   * stream.
   */
  this.sendEnd = function () {
    stream.sendEnd();
  };

  /**
   * Fired for received data, if acknowledged by the server.
   * @event
   * @param {Guacamole.Status} status The status of the operation.
   */
  this.onack = null;
};

/**
 * The default maximum blob length for new Guacamole.ArrayBufferWriter
 * instances.
 *
 * @constant
 * @type {Number}
 */
Guacamole.ArrayBufferWriter.DEFAULT_BLOB_LENGTH = 6048;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Maintains a singleton instance of the Web Audio API AudioContext class,
 * instantiating the AudioContext only in response to the first call to
 * getAudioContext(), and only if no existing AudioContext instance has been
 * provided via the singleton property. Subsequent calls to getAudioContext()
 * will return the same instance.
 *
 * @namespace
 */
Guacamole.AudioContextFactory = {
  /**
   * A singleton instance of a Web Audio API AudioContext object, or null if
   * no instance has yes been created. This property may be manually set if
   * you wish to supply your own AudioContext instance, but care must be
   * taken to do so as early as possible. Assignments to this property will
   * not retroactively affect the value returned by previous calls to
   * getAudioContext().
   *
   * @type {AudioContext}
   */
  singleton: null,

  /**
   * Returns a singleton instance of a Web Audio API AudioContext object.
   *
   * @return {AudioContext}
   *     A singleton instance of a Web Audio API AudioContext object, or null
   *     if the Web Audio API is not supported.
   */
  getAudioContext: function getAudioContext() {
    // Fallback to Webkit-specific AudioContext implementation
    var AudioContext = window.AudioContext || window.webkitAudioContext;

    // Get new AudioContext instance if Web Audio API is supported
    if (AudioContext) {
      try {
        // Create new instance if none yet exists
        if (!Guacamole.AudioContextFactory.singleton)
          Guacamole.AudioContextFactory.singleton = new AudioContext();

        // Return singleton instance
        return Guacamole.AudioContextFactory.singleton;
      } catch (e) {
        // Do not use Web Audio API if not allowed by browser
      }
    }

    // Web Audio API not supported
    return null;
  },
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Abstract audio player which accepts, queues and plays back arbitrary audio
 * data. It is up to implementations of this class to provide some means of
 * handling a provided Guacamole.InputStream. Data received along the provided
 * stream is to be played back immediately.
 *
 * @constructor
 */
Guacamole.AudioPlayer = function AudioPlayer() {
  /**
   * Notifies this Guacamole.AudioPlayer that all audio up to the current
   * point in time has been given via the underlying stream, and that any
   * difference in time between queued audio data and the current time can be
   * considered latency.
   */
  this.sync = function sync() {
    // Default implementation - do nothing
  };
};

/**
 * Determines whether the given mimetype is supported by any built-in
 * implementation of Guacamole.AudioPlayer, and thus will be properly handled
 * by Guacamole.AudioPlayer.getInstance().
 *
 * @param {String} mimetype
 *     The mimetype to check.
 *
 * @returns {Boolean}
 *     true if the given mimetype is supported by any built-in
 *     Guacamole.AudioPlayer, false otherwise.
 */
Guacamole.AudioPlayer.isSupportedType = function isSupportedType(mimetype) {
  return Guacamole.RawAudioPlayer.isSupportedType(mimetype);
};

/**
 * Returns a list of all mimetypes supported by any built-in
 * Guacamole.AudioPlayer, in rough order of priority. Beware that only the core
 * mimetypes themselves will be listed. Any mimetype parameters, even required
 * ones, will not be included in the list. For example, "audio/L8" is a
 * supported raw audio mimetype that is supported, but it is invalid without
 * additional parameters. Something like "audio/L8;rate=44100" would be valid,
 * however (see https://tools.ietf.org/html/rfc4856).
 *
 * @returns {String[]}
 *     A list of all mimetypes supported by any built-in Guacamole.AudioPlayer,
 *     excluding any parameters.
 */
Guacamole.AudioPlayer.getSupportedTypes = function getSupportedTypes() {
  return Guacamole.RawAudioPlayer.getSupportedTypes();
};

/**
 * Returns an instance of Guacamole.AudioPlayer providing support for the given
 * audio format. If support for the given audio format is not available, null
 * is returned.
 *
 * @param {Guacamole.InputStream} stream
 *     The Guacamole.InputStream to read audio data from.
 *
 * @param {String} mimetype
 *     The mimetype of the audio data in the provided stream.
 *
 * @return {Guacamole.AudioPlayer}
 *     A Guacamole.AudioPlayer instance supporting the given mimetype and
 *     reading from the given stream, or null if support for the given mimetype
 *     is absent.
 */
Guacamole.AudioPlayer.getInstance = function getInstance(stream, mimetype) {
  // Use raw audio player if possible
  if (Guacamole.RawAudioPlayer.isSupportedType(mimetype))
    return new Guacamole.RawAudioPlayer(stream, mimetype);

  // No support for given mimetype
  return null;
};

/**
 * Implementation of Guacamole.AudioPlayer providing support for raw PCM format
 * audio. This player relies only on the Web Audio API and does not require any
 * browser-level support for its audio formats.
 *
 * @constructor
 * @augments Guacamole.AudioPlayer
 * @param {Guacamole.InputStream} stream
 *     The Guacamole.InputStream to read audio data from.
 *
 * @param {String} mimetype
 *     The mimetype of the audio data in the provided stream, which must be a
 *     "audio/L8" or "audio/L16" mimetype with necessary parameters, such as:
 *     "audio/L16;rate=44100,channels=2".
 */
Guacamole.RawAudioPlayer = function RawAudioPlayer(stream, mimetype) {
  /**
   * The format of audio this player will decode.
   *
   * @private
   * @type {Guacamole.RawAudioFormat}
   */
  var format = Guacamole.RawAudioFormat.parse(mimetype);

  /**
   * An instance of a Web Audio API AudioContext object, or null if the
   * Web Audio API is not supported.
   *
   * @private
   * @type {AudioContext}
   */
  var context = Guacamole.AudioContextFactory.getAudioContext();

  /**
   * The earliest possible time that the next packet could play without
   * overlapping an already-playing packet, in seconds. Note that while this
   * value is in seconds, it is not an integer value and has microsecond
   * resolution.
   *
   * @private
   * @type {Number}
   */
  var nextPacketTime = context.currentTime;

  /**
   * Guacamole.ArrayBufferReader wrapped around the audio input stream
   * provided with this Guacamole.RawAudioPlayer was created.
   *
   * @private
   * @type {Guacamole.ArrayBufferReader}
   */
  var reader = new Guacamole.ArrayBufferReader(stream);

  /**
   * The minimum size of an audio packet split by splitAudioPacket(), in
   * seconds. Audio packets smaller than this will not be split, nor will the
   * split result of a larger packet ever be smaller in size than this
   * minimum.
   *
   * @private
   * @constant
   * @type {Number}
   */
  var MIN_SPLIT_SIZE = 0.02;

  /**
   * The maximum amount of latency to allow between the buffered data stream
   * and the playback position, in seconds. Initially, this is set to
   * roughly one third of a second.
   *
   * @private
   * @type {Number}
   */
  var maxLatency = 0.3;

  /**
   * The type of typed array that will be used to represent each audio packet
   * internally. This will be either Int8Array or Int16Array, depending on
   * whether the raw audio format is 8-bit or 16-bit.
   *
   * @private
   * @constructor
   */
  var SampleArray =
    format.bytesPerSample === 1 ? window.Int8Array : window.Int16Array;

  /**
   * The maximum absolute value of any sample within a raw audio packet
   * received by this audio player. This depends only on the size of each
   * sample, and will be 128 for 8-bit audio and 32768 for 16-bit audio.
   *
   * @private
   * @type {Number}
   */
  var maxSampleValue = format.bytesPerSample === 1 ? 128 : 32768;

  /**
   * The queue of all pending audio packets, as an array of sample arrays.
   * Audio packets which are pending playback will be added to this queue for
   * further manipulation prior to scheduling via the Web Audio API. Once an
   * audio packet leaves this queue and is scheduled via the Web Audio API,
   * no further modifications can be made to that packet.
   *
   * @private
   * @type {SampleArray[]}
   */
  var packetQueue = [];

  /**
   * Given an array of audio packets, returns a single audio packet
   * containing the concatenation of those packets.
   *
   * @private
   * @param {SampleArray[]} packets
   *     The array of audio packets to concatenate.
   *
   * @returns {SampleArray}
   *     A single audio packet containing the concatenation of all given
   *     audio packets. If no packets are provided, this will be undefined.
   */
  var joinAudioPackets = function joinAudioPackets(packets) {
    // Do not bother joining if one or fewer packets are in the queue
    if (packets.length <= 1) return packets[0];

    // Determine total sample length of the entire queue
    var totalLength = 0;
    packets.forEach(function addPacketLengths(packet) {
      totalLength += packet.length;
    });

    // Append each packet within queue
    var offset = 0;
    var joined = new SampleArray(totalLength);
    packets.forEach(function appendPacket(packet) {
      joined.set(packet, offset);
      offset += packet.length;
    });

    return joined;
  };

  /**
   * Given a single packet of audio data, splits off an arbitrary length of
   * audio data from the beginning of that packet, returning the split result
   * as an array of two packets. The split location is determined through an
   * algorithm intended to minimize the liklihood of audible clicking between
   * packets. If no such split location is possible, an array containing only
   * the originally-provided audio packet is returned.
   *
   * @private
   * @param {SampleArray} data
   *     The audio packet to split.
   *
   * @returns {SampleArray[]}
   *     An array of audio packets containing the result of splitting the
   *     provided audio packet. If splitting is possible, this array will
   *     contain two packets. If splitting is not possible, this array will
   *     contain only the originally-provided packet.
   */
  var splitAudioPacket = function splitAudioPacket(data) {
    var minValue = Number.MAX_VALUE;
    var optimalSplitLength = data.length;

    // Calculate number of whole samples in the provided audio packet AND
    // in the minimum possible split packet
    var samples = Math.floor(data.length / format.channels);
    var minSplitSamples = Math.floor(format.rate * MIN_SPLIT_SIZE);

    // Calculate the beginning of the "end" of the audio packet
    var start = Math.max(
      format.channels * minSplitSamples,
      format.channels * (samples - minSplitSamples)
    );

    // For all samples at the end of the given packet, find a point where
    // the perceptible volume across all channels is lowest (and thus is
    // the optimal point to split)
    for (var offset = start; offset < data.length; offset += format.channels) {
      // Calculate the sum of all values across all channels (the result
      // will be proportional to the average volume of a sample)
      var totalValue = 0;
      for (var channel = 0; channel < format.channels; channel++) {
        totalValue += Math.abs(data[offset + channel]);
      }

      // If this is the smallest average value thus far, set the split
      // length such that the first packet ends with the current sample
      if (totalValue <= minValue) {
        optimalSplitLength = offset + format.channels;
        minValue = totalValue;
      }
    }

    // If packet is not split, return the supplied packet untouched
    if (optimalSplitLength === data.length) return [data];

    // Otherwise, split the packet into two new packets according to the
    // calculated optimal split length
    return [
      new SampleArray(
        data.buffer.slice(0, optimalSplitLength * format.bytesPerSample)
      ),
      new SampleArray(
        data.buffer.slice(optimalSplitLength * format.bytesPerSample)
      ),
    ];
  };

  /**
   * Pushes the given packet of audio data onto the playback queue. Unlike
   * other private functions within Guacamole.RawAudioPlayer, the type of the
   * ArrayBuffer packet of audio data here need not be specific to the type
   * of audio (as with SampleArray). The ArrayBuffer type provided by a
   * Guacamole.ArrayBufferReader, for example, is sufficient. Any necessary
   * conversions will be performed automatically internally.
   *
   * @private
   * @param {ArrayBuffer} data
   *     A raw packet of audio data that should be pushed onto the audio
   *     playback queue.
   */
  var pushAudioPacket = function pushAudioPacket(data) {
    packetQueue.push(new SampleArray(data));
  };

  /**
   * Shifts off and returns a packet of audio data from the beginning of the
   * playback queue. The length of this audio packet is determined
   * dynamically according to the click-reduction algorithm implemented by
   * splitAudioPacket().
   *
   * @private
   * @returns {SampleArray}
   *     A packet of audio data pulled from the beginning of the playback
   *     queue.
   */
  var shiftAudioPacket = function shiftAudioPacket() {
    // Flatten data in packet queue
    var data = joinAudioPackets(packetQueue);
    if (!data) return null;

    // Pull an appropriate amount of data from the front of the queue
    packetQueue = splitAudioPacket(data);
    data = packetQueue.shift();

    return data;
  };

  /**
   * Converts the given audio packet into an AudioBuffer, ready for playback
   * by the Web Audio API. Unlike the raw audio packets received by this
   * audio player, AudioBuffers require floating point samples and are split
   * into isolated planes of channel-specific data.
   *
   * @private
   * @param {SampleArray} data
   *     The raw audio packet that should be converted into a Web Audio API
   *     AudioBuffer.
   *
   * @returns {AudioBuffer}
   *     A new Web Audio API AudioBuffer containing the provided audio data,
   *     converted to the format used by the Web Audio API.
   */
  var toAudioBuffer = function toAudioBuffer(data) {
    // Calculate total number of samples
    var samples = data.length / format.channels;

    // Determine exactly when packet CAN play
    var packetTime = context.currentTime;
    if (nextPacketTime < packetTime) nextPacketTime = packetTime;

    // Get audio buffer for specified format
    var audioBuffer = context.createBuffer(
      format.channels,
      samples,
      format.rate
    );

    // Convert each channel
    for (var channel = 0; channel < format.channels; channel++) {
      var audioData = audioBuffer.getChannelData(channel);

      // Fill audio buffer with data for channel
      var offset = channel;
      for (var i = 0; i < samples; i++) {
        audioData[i] = data[offset] / maxSampleValue;
        offset += format.channels;
      }
    }

    return audioBuffer;
  };

  // Defer playback of received audio packets slightly
  reader.ondata = function playReceivedAudio(data) {
    // Push received samples onto queue
    pushAudioPacket(new SampleArray(data));

    // Shift off an arbitrary packet of audio data from the queue (this may
    // be different in size from the packet just pushed)
    var packet = shiftAudioPacket();
    if (!packet) return;

    // Determine exactly when packet CAN play
    var packetTime = context.currentTime;
    if (nextPacketTime < packetTime) nextPacketTime = packetTime;

    // Set up buffer source
    var source = context.createBufferSource();
    source.connect(context.destination);

    // Use noteOn() instead of start() if necessary
    if (!source.start) source.start = source.noteOn;

    // Schedule packet
    source.buffer = toAudioBuffer(packet);
    source.start(nextPacketTime);

    // Update timeline by duration of scheduled packet
    nextPacketTime += packet.length / format.channels / format.rate;
  };

  /** @override */
  this.sync = function sync() {
    // Calculate elapsed time since last sync
    var now = context.currentTime;

    // Reschedule future playback time such that playback latency is
    // bounded within a reasonable latency threshold
    nextPacketTime = Math.min(nextPacketTime, now + maxLatency);
  };
};

Guacamole.RawAudioPlayer.prototype = new Guacamole.AudioPlayer();

/**
 * Determines whether the given mimetype is supported by
 * Guacamole.RawAudioPlayer.
 *
 * @param {String} mimetype
 *     The mimetype to check.
 *
 * @returns {Boolean}
 *     true if the given mimetype is supported by Guacamole.RawAudioPlayer,
 *     false otherwise.
 */
Guacamole.RawAudioPlayer.isSupportedType = function isSupportedType(mimetype) {
  // No supported types if no Web Audio API
  if (!Guacamole.AudioContextFactory.getAudioContext()) return false;

  return Guacamole.RawAudioFormat.parse(mimetype) !== null;
};

/**
 * Returns a list of all mimetypes supported by Guacamole.RawAudioPlayer. Only
 * the core mimetypes themselves will be listed. Any mimetype parameters, even
 * required ones, will not be included in the list. For example, "audio/L8" is
 * a raw audio mimetype that may be supported, but it is invalid without
 * additional parameters. Something like "audio/L8;rate=44100" would be valid,
 * however (see https://tools.ietf.org/html/rfc4856).
 *
 * @returns {String[]}
 *     A list of all mimetypes supported by Guacamole.RawAudioPlayer, excluding
 *     any parameters. If the necessary JavaScript APIs for playing raw audio
 *     are absent, this list will be empty.
 */
Guacamole.RawAudioPlayer.getSupportedTypes = function getSupportedTypes() {
  // No supported types if no Web Audio API
  if (!Guacamole.AudioContextFactory.getAudioContext()) return [];

  // We support 8-bit and 16-bit raw PCM
  return ["audio/L8", "audio/L16"];
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Abstract audio recorder which streams arbitrary audio data to an underlying
 * Guacamole.OutputStream. It is up to implementations of this class to provide
 * some means of handling this Guacamole.OutputStream. Data produced by the
 * recorder is to be sent along the provided stream immediately.
 *
 * @constructor
 */
Guacamole.AudioRecorder = function AudioRecorder() {
  /**
   * Callback which is invoked when the audio recording process has stopped
   * and the underlying Guacamole stream has been closed normally. Audio will
   * only resume recording if a new Guacamole.AudioRecorder is started. This
   * Guacamole.AudioRecorder instance MAY NOT be reused.
   *
   * @event
   */
  this.onclose = null;

  /**
   * Callback which is invoked when the audio recording process cannot
   * continue due to an error, if it has started at all. The underlying
   * Guacamole stream is automatically closed. Future attempts to record
   * audio should not be made, and this Guacamole.AudioRecorder instance
   * MAY NOT be reused.
   *
   * @event
   */
  this.onerror = null;
};

/**
 * Determines whether the given mimetype is supported by any built-in
 * implementation of Guacamole.AudioRecorder, and thus will be properly handled
 * by Guacamole.AudioRecorder.getInstance().
 *
 * @param {String} mimetype
 *     The mimetype to check.
 *
 * @returns {Boolean}
 *     true if the given mimetype is supported by any built-in
 *     Guacamole.AudioRecorder, false otherwise.
 */
Guacamole.AudioRecorder.isSupportedType = function isSupportedType(mimetype) {
  return Guacamole.RawAudioRecorder.isSupportedType(mimetype);
};

/**
 * Returns a list of all mimetypes supported by any built-in
 * Guacamole.AudioRecorder, in rough order of priority. Beware that only the
 * core mimetypes themselves will be listed. Any mimetype parameters, even
 * required ones, will not be included in the list. For example, "audio/L8" is
 * a supported raw audio mimetype that is supported, but it is invalid without
 * additional parameters. Something like "audio/L8;rate=44100" would be valid,
 * however (see https://tools.ietf.org/html/rfc4856).
 *
 * @returns {String[]}
 *     A list of all mimetypes supported by any built-in
 *     Guacamole.AudioRecorder, excluding any parameters.
 */
Guacamole.AudioRecorder.getSupportedTypes = function getSupportedTypes() {
  return Guacamole.RawAudioRecorder.getSupportedTypes();
};

/**
 * Returns an instance of Guacamole.AudioRecorder providing support for the
 * given audio format. If support for the given audio format is not available,
 * null is returned.
 *
 * @param {Guacamole.OutputStream} stream
 *     The Guacamole.OutputStream to send audio data through.
 *
 * @param {String} mimetype
 *     The mimetype of the audio data to be sent along the provided stream.
 *
 * @return {Guacamole.AudioRecorder}
 *     A Guacamole.AudioRecorder instance supporting the given mimetype and
 *     writing to the given stream, or null if support for the given mimetype
 *     is absent.
 */
Guacamole.AudioRecorder.getInstance = function getInstance(stream, mimetype) {
  // Use raw audio recorder if possible
  if (Guacamole.RawAudioRecorder.isSupportedType(mimetype))
    return new Guacamole.RawAudioRecorder(stream, mimetype);

  // No support for given mimetype
  return null;
};

/**
 * Implementation of Guacamole.AudioRecorder providing support for raw PCM
 * format audio. This recorder relies only on the Web Audio API and does not
 * require any browser-level support for its audio formats.
 *
 * @constructor
 * @augments Guacamole.AudioRecorder
 * @param {Guacamole.OutputStream} stream
 *     The Guacamole.OutputStream to write audio data to.
 *
 * @param {String} mimetype
 *     The mimetype of the audio data to send along the provided stream, which
 *     must be a "audio/L8" or "audio/L16" mimetype with necessary parameters,
 *     such as: "audio/L16;rate=44100,channels=2".
 */
Guacamole.RawAudioRecorder = function RawAudioRecorder(stream, mimetype) {
  /**
   * Reference to this RawAudioRecorder.
   *
   * @private
   * @type {Guacamole.RawAudioRecorder}
   */
  var recorder = this;

  /**
   * The size of audio buffer to request from the Web Audio API when
   * recording or processing audio, in sample-frames. This must be a power of
   * two between 256 and 16384 inclusive, as required by
   * AudioContext.createScriptProcessor().
   *
   * @private
   * @constant
   * @type {Number}
   */
  var BUFFER_SIZE = 2048;

  /**
   * The window size to use when applying Lanczos interpolation, commonly
   * denoted by the variable "a".
   * See: https://en.wikipedia.org/wiki/Lanczos_resampling
   *
   * @private
   * @contant
   * @type Number
   */
  var LANCZOS_WINDOW_SIZE = 3;

  /**
   * The format of audio this recorder will encode.
   *
   * @private
   * @type {Guacamole.RawAudioFormat}
   */
  var format = Guacamole.RawAudioFormat.parse(mimetype);

  /**
   * An instance of a Web Audio API AudioContext object, or null if the
   * Web Audio API is not supported.
   *
   * @private
   * @type {AudioContext}
   */
  var context = Guacamole.AudioContextFactory.getAudioContext();

  // Some browsers do not implement navigator.mediaDevices - this
  // shims in this functionality to ensure code compatibility.
  if (!navigator.mediaDevices) navigator.mediaDevices = {};

  // Browsers that either do not implement navigator.mediaDevices
  // at all or do not implement it completely need the getUserMedia
  // method defined.  This shims in this function by detecting
  // one of the supported legacy methods.
  if (!navigator.mediaDevices.getUserMedia)
    navigator.mediaDevices.getUserMedia = (
      navigator.getUserMedia ||
      navigator.webkitGetUserMedia ||
      navigator.mozGetUserMedia ||
      navigator.msGetUserMedia
    ).bind(navigator);

  /**
   * Guacamole.ArrayBufferWriter wrapped around the audio output stream
   * provided when this Guacamole.RawAudioRecorder was created.
   *
   * @private
   * @type {Guacamole.ArrayBufferWriter}
   */
  var writer = new Guacamole.ArrayBufferWriter(stream);

  /**
   * The type of typed array that will be used to represent each audio packet
   * internally. This will be either Int8Array or Int16Array, depending on
   * whether the raw audio format is 8-bit or 16-bit.
   *
   * @private
   * @constructor
   */
  var SampleArray =
    format.bytesPerSample === 1 ? window.Int8Array : window.Int16Array;

  /**
   * The maximum absolute value of any sample within a raw audio packet sent
   * by this audio recorder. This depends only on the size of each sample,
   * and will be 128 for 8-bit audio and 32768 for 16-bit audio.
   *
   * @private
   * @type {Number}
   */
  var maxSampleValue = format.bytesPerSample === 1 ? 128 : 32768;

  /**
   * The total number of audio samples read from the local audio input device
   * over the life of this audio recorder.
   *
   * @private
   * @type {Number}
   */
  var readSamples = 0;

  /**
   * The total number of audio samples written to the underlying Guacamole
   * connection over the life of this audio recorder.
   *
   * @private
   * @type {Number}
   */
  var writtenSamples = 0;

  /**
   * The audio stream provided by the browser, if allowed. If no stream has
   * yet been received, this will be null.
   *
   * @type MediaStream
   */
  var mediaStream = null;

  /**
   * The source node providing access to the local audio input device.
   *
   * @private
   * @type {MediaStreamAudioSourceNode}
   */
  var source = null;

  /**
   * The script processing node which receives audio input from the media
   * stream source node as individual audio buffers.
   *
   * @private
   * @type {ScriptProcessorNode}
   */
  var processor = null;

  /**
   * The normalized sinc function. The normalized sinc function is defined as
   * 1 for x=0 and sin(PI * x) / (PI * x) for all other values of x.
   *
   * See: https://en.wikipedia.org/wiki/Sinc_function
   *
   * @private
   * @param {Number} x
   *     The point at which the normalized sinc function should be computed.
   *
   * @returns {Number}
   *     The value of the normalized sinc function at x.
   */
  var sinc = function sinc(x) {
    // The value of sinc(0) is defined as 1
    if (x === 0) return 1;

    // Otherwise, normlized sinc(x) is sin(PI * x) / (PI * x)
    var piX = Math.PI * x;
    return Math.sin(piX) / piX;
  };

  /**
   * Calculates the value of the Lanczos kernal at point x for a given window
   * size. See: https://en.wikipedia.org/wiki/Lanczos_resampling
   *
   * @private
   * @param {Number} x
   *     The point at which the value of the Lanczos kernel should be
   *     computed.
   *
   * @param {Number} a
   *     The window size to use for the Lanczos kernel.
   *
   * @returns {Number}
   *     The value of the Lanczos kernel at the given point for the given
   *     window size.
   */
  var lanczos = function lanczos(x, a) {
    // Lanczos is sinc(x) * sinc(x / a) for -a < x < a ...
    if (-a < x && x < a) return sinc(x) * sinc(x / a);

    // ... and 0 otherwise
    return 0;
  };

  /**
   * Determines the value of the waveform represented by the audio data at
   * the given location. If the value cannot be determined exactly as it does
   * not correspond to an exact sample within the audio data, the value will
   * be derived through interpolating nearby samples.
   *
   * @private
   * @param {Float32Array} audioData
   *     An array of audio data, as returned by AudioBuffer.getChannelData().
   *
   * @param {Number} t
   *     The relative location within the waveform from which the value
   *     should be retrieved, represented as a floating point number between
   *     0 and 1 inclusive, where 0 represents the earliest point in time and
   *     1 represents the latest.
   *
   * @returns {Number}
   *     The value of the waveform at the given location.
   */
  var interpolateSample = function getValueAt(audioData, t) {
    // Convert [0, 1] range to [0, audioData.length - 1]
    var index = (audioData.length - 1) * t;

    // Determine the start and end points for the summation used by the
    // Lanczos interpolation algorithm (see: https://en.wikipedia.org/wiki/Lanczos_resampling)
    var start = Math.floor(index) - LANCZOS_WINDOW_SIZE + 1;
    var end = Math.floor(index) + LANCZOS_WINDOW_SIZE;

    // Calculate the value of the Lanczos interpolation function for the
    // required range
    var sum = 0;
    for (var i = start; i <= end; i++) {
      sum += (audioData[i] || 0) * lanczos(index - i, LANCZOS_WINDOW_SIZE);
    }

    return sum;
  };

  /**
   * Converts the given AudioBuffer into an audio packet, ready for streaming
   * along the underlying output stream. Unlike the raw audio packets used by
   * this audio recorder, AudioBuffers require floating point samples and are
   * split into isolated planes of channel-specific data.
   *
   * @private
   * @param {AudioBuffer} audioBuffer
   *     The Web Audio API AudioBuffer that should be converted to a raw
   *     audio packet.
   *
   * @returns {SampleArray}
   *     A new raw audio packet containing the audio data from the provided
   *     AudioBuffer.
   */
  var toSampleArray = function toSampleArray(audioBuffer) {
    // Track overall amount of data read
    var inSamples = audioBuffer.length;
    readSamples += inSamples;

    // Calculate the total number of samples that should be written as of
    // the audio data just received and adjust the size of the output
    // packet accordingly
    var expectedWrittenSamples = Math.round(
      (readSamples * format.rate) / audioBuffer.sampleRate
    );
    var outSamples = expectedWrittenSamples - writtenSamples;

    // Update number of samples written
    writtenSamples += outSamples;

    // Get array for raw PCM storage
    var data = new SampleArray(outSamples * format.channels);

    // Convert each channel
    for (var channel = 0; channel < format.channels; channel++) {
      var audioData = audioBuffer.getChannelData(channel);

      // Fill array with data from audio buffer channel
      var offset = channel;
      for (var i = 0; i < outSamples; i++) {
        data[offset] =
          interpolateSample(audioData, i / (outSamples - 1)) * maxSampleValue;
        offset += format.channels;
      }
    }

    return data;
  };

  /**
   * getUserMedia() callback which handles successful retrieval of an
   * audio stream (successful start of recording).
   *
   * @private
   * @param {MediaStream} stream
   *     A MediaStream which provides access to audio data read from the
   *     user's local audio input device.
   */
  var streamReceived = function streamReceived(stream) {
    // Create processing node which receives appropriately-sized audio buffers
    processor = context.createScriptProcessor(
      BUFFER_SIZE,
      format.channels,
      format.channels
    );
    processor.connect(context.destination);

    // Send blobs when audio buffers are received
    processor.onaudioprocess = function processAudio(e) {
      writer.sendData(toSampleArray(e.inputBuffer).buffer);
    };

    // Connect processing node to user's audio input source
    source = context.createMediaStreamSource(stream);
    source.connect(processor);

    // Attempt to explicitly resume AudioContext, as it may be paused
    // by default
    if (context.state === "suspended") context.resume();

    // Save stream for later cleanup
    mediaStream = stream;
  };

  /**
   * getUserMedia() callback which handles audio recording denial. The
   * underlying Guacamole output stream is closed, and the failure to
   * record is noted using onerror.
   *
   * @private
   */
  var streamDenied = function streamDenied() {
    // Simply end stream if audio access is not allowed
    writer.sendEnd();

    // Notify of closure
    if (recorder.onerror) recorder.onerror();
  };

  /**
   * Requests access to the user's microphone and begins capturing audio. All
   * received audio data is resampled as necessary and forwarded to the
   * Guacamole stream underlying this Guacamole.RawAudioRecorder. This
   * function must be invoked ONLY ONCE per instance of
   * Guacamole.RawAudioRecorder.
   *
   * @private
   */
  var beginAudioCapture = function beginAudioCapture() {
    // Attempt to retrieve an audio input stream from the browser
    var promise = navigator.mediaDevices.getUserMedia(
      {
        audio: true,
      },
      streamReceived,
      streamDenied
    );

    // Handle stream creation/rejection via Promise for newer versions of
    // getUserMedia()
    if (promise && promise.then) promise.then(streamReceived, streamDenied);
  };

  /**
   * Stops capturing audio, if the capture has started, freeing all associated
   * resources. If the capture has not started, this function simply ends the
   * underlying Guacamole stream.
   *
   * @private
   */
  var stopAudioCapture = function stopAudioCapture() {
    // Disconnect media source node from script processor
    if (source) source.disconnect();

    // Disconnect associated script processor node
    if (processor) processor.disconnect();

    // Stop capture
    if (mediaStream) {
      var tracks = mediaStream.getTracks();
      for (var i = 0; i < tracks.length; i++) tracks[i].stop();
    }

    // Remove references to now-unneeded components
    processor = null;
    source = null;
    mediaStream = null;

    // End stream
    writer.sendEnd();
  };

  // Once audio stream is successfully open, request and begin reading audio
  writer.onack = function audioStreamAcknowledged(status) {
    // Begin capture if successful response and not yet started
    if (status.code === Guacamole.Status.Code.SUCCESS && !mediaStream)
      beginAudioCapture();
    // Otherwise stop capture and cease handling any further acks
    else {
      // Stop capturing audio
      stopAudioCapture();
      writer.onack = null;

      // Notify if stream has closed normally
      if (status.code === Guacamole.Status.Code.RESOURCE_CLOSED) {
        if (recorder.onclose) recorder.onclose();
      }

      // Otherwise notify of closure due to error
      else {
        if (recorder.onerror) recorder.onerror();
      }
    }
  };
};

Guacamole.RawAudioRecorder.prototype = new Guacamole.AudioRecorder();

/**
 * Determines whether the given mimetype is supported by
 * Guacamole.RawAudioRecorder.
 *
 * @param {String} mimetype
 *     The mimetype to check.
 *
 * @returns {Boolean}
 *     true if the given mimetype is supported by Guacamole.RawAudioRecorder,
 *     false otherwise.
 */
Guacamole.RawAudioRecorder.isSupportedType = function isSupportedType(
  mimetype
) {
  // No supported types if no Web Audio API
  if (!Guacamole.AudioContextFactory.getAudioContext()) return false;

  return Guacamole.RawAudioFormat.parse(mimetype) !== null;
};

/**
 * Returns a list of all mimetypes supported by Guacamole.RawAudioRecorder. Only
 * the core mimetypes themselves will be listed. Any mimetype parameters, even
 * required ones, will not be included in the list. For example, "audio/L8" is
 * a raw audio mimetype that may be supported, but it is invalid without
 * additional parameters. Something like "audio/L8;rate=44100" would be valid,
 * however (see https://tools.ietf.org/html/rfc4856).
 *
 * @returns {String[]}
 *     A list of all mimetypes supported by Guacamole.RawAudioRecorder,
 *     excluding any parameters. If the necessary JavaScript APIs for recording
 *     raw audio are absent, this list will be empty.
 */
Guacamole.RawAudioRecorder.getSupportedTypes = function getSupportedTypes() {
  // No supported types if no Web Audio API
  if (!Guacamole.AudioContextFactory.getAudioContext()) return [];

  // We support 8-bit and 16-bit raw PCM
  return ["audio/L8", "audio/L16"];
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A reader which automatically handles the given input stream, assembling all
 * received blobs into a single blob by appending them to each other in order.
 * Note that this object will overwrite any installed event handlers on the
 * given Guacamole.InputStream.
 *
 * @constructor
 * @param {Guacamole.InputStream} stream The stream that data will be read
 *                                       from.
 * @param {String} mimetype The mimetype of the blob being built.
 */
Guacamole.BlobReader = function (stream, mimetype) {
  /**
   * Reference to this Guacamole.InputStream.
   * @private
   */
  var guac_reader = this;

  /**
   * The length of this Guacamole.InputStream in bytes.
   * @private
   */
  var length = 0;

  // Get blob builder
  var blob_builder;
  if (window.BlobBuilder) blob_builder = new BlobBuilder();
  else if (window.WebKitBlobBuilder) blob_builder = new WebKitBlobBuilder();
  else if (window.MozBlobBuilder) blob_builder = new MozBlobBuilder();
  else
    blob_builder = new (function () {
      var blobs = [];

      /** @ignore */
      this.append = function (data) {
        blobs.push(new Blob([data], { type: mimetype }));
      };

      /** @ignore */
      this.getBlob = function () {
        return new Blob(blobs, { type: mimetype });
      };
    })();

  // Append received blobs
  stream.onblob = function (data) {
    // Convert to ArrayBuffer
    var binary = window.atob(data);
    var arrayBuffer = new ArrayBuffer(binary.length);
    var bufferView = new Uint8Array(arrayBuffer);

    for (var i = 0; i < binary.length; i++)
      bufferView[i] = binary.charCodeAt(i);

    blob_builder.append(arrayBuffer);
    length += arrayBuffer.byteLength;

    // Call handler, if present
    if (guac_reader.onprogress) guac_reader.onprogress(arrayBuffer.byteLength);

    // Send success response
    stream.sendAck("OK", 0x0000);
  };

  // Simply call onend when end received
  stream.onend = function () {
    if (guac_reader.onend) guac_reader.onend();
  };

  /**
   * Returns the current length of this Guacamole.InputStream, in bytes.
   * @return {Number} The current length of this Guacamole.InputStream.
   */
  this.getLength = function () {
    return length;
  };

  /**
   * Returns the contents of this Guacamole.BlobReader as a Blob.
   * @return {Blob} The contents of this Guacamole.BlobReader.
   */
  this.getBlob = function () {
    return blob_builder.getBlob();
  };

  /**
   * Fired once for every blob of data received.
   *
   * @event
   * @param {Number} length The number of bytes received.
   */
  this.onprogress = null;

  /**
   * Fired once this stream is finished and no further data will be written.
   * @event
   */
  this.onend = null;
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A writer which automatically writes to the given output stream with the
 * contents of provided Blob objects.
 *
 * @constructor
 * @param {Guacamole.OutputStream} stream
 *     The stream that data will be written to.
 */
Guacamole.BlobWriter = function BlobWriter(stream) {
  /**
   * Reference to this Guacamole.BlobWriter.
   *
   * @private
   * @type {Guacamole.BlobWriter}
   */
  var guacWriter = this;

  /**
   * Wrapped Guacamole.ArrayBufferWriter which will be used to send any
   * provided file data.
   *
   * @private
   * @type {Guacamole.ArrayBufferWriter}
   */
  var arrayBufferWriter = new Guacamole.ArrayBufferWriter(stream);

  // Initially, simply call onack for acknowledgements
  arrayBufferWriter.onack = function (status) {
    if (guacWriter.onack) guacWriter.onack(status);
  };

  /**
   * Browser-independent implementation of Blob.slice() which uses an end
   * offset to determine the span of the resulting slice, rather than a
   * length.
   *
   * @private
   * @param {Blob} blob
   *     The Blob to slice.
   *
   * @param {Number} start
   *     The starting offset of the slice, in bytes, inclusive.
   *
   * @param {Number} end
   *     The ending offset of the slice, in bytes, exclusive.
   *
   * @returns {Blob}
   *     A Blob containing the data within the given Blob starting at
   *     <code>start</code> and ending at <code>end - 1</code>.
   */
  var slice = function slice(blob, start, end) {
    // Use prefixed implementations if necessary
    var sliceImplementation = (
      blob.slice ||
      blob.webkitSlice ||
      blob.mozSlice
    ).bind(blob);

    var length = end - start;

    // The old Blob.slice() was length-based (not end-based). Try the
    // length version first, if the two calls are not equivalent.
    if (length !== end) {
      // If the result of the slice() call matches the expected length,
      // trust that result. It must be correct.
      var sliceResult = sliceImplementation(start, length);
      if (sliceResult.size === length) return sliceResult;
    }

    // Otherwise, use the most-recent standard: end-based slice()
    return sliceImplementation(start, end);
  };

  /**
   * Sends the contents of the given blob over the underlying stream.
   *
   * @param {Blob} blob
   *     The blob to send.
   */
  this.sendBlob = function sendBlob(blob) {
    var offset = 0;
    var reader = new FileReader();

    /**
     * Reads the next chunk of the blob provided to
     * [sendBlob()]{@link Guacamole.BlobWriter#sendBlob}. The chunk itself
     * is read asynchronously, and will not be available until
     * reader.onload fires.
     *
     * @private
     */
    var readNextChunk = function readNextChunk() {
      // If no further chunks remain, inform of completion and stop
      if (offset >= blob.size) {
        // Fire completion event for completed blob
        if (guacWriter.oncomplete) guacWriter.oncomplete(blob);

        // No further chunks to read
        return;
      }

      // Obtain reference to next chunk as a new blob
      var chunk = slice(blob, offset, offset + arrayBufferWriter.blobLength);
      offset += arrayBufferWriter.blobLength;

      // Attempt to read the blob contents represented by the blob into
      // a new array buffer
      reader.readAsArrayBuffer(chunk);
    };

    // Send each chunk over the stream, continue reading the next chunk
    reader.onload = function chunkLoadComplete() {
      // Send the successfully-read chunk
      arrayBufferWriter.sendData(reader.result);

      // Continue sending more chunks after the latest chunk is
      // acknowledged
      arrayBufferWriter.onack = function sendMoreChunks(status) {
        if (guacWriter.onack) guacWriter.onack(status);

        // Abort transfer if an error occurs
        if (status.isError()) return;

        // Inform of blob upload progress via progress events
        if (guacWriter.onprogress)
          guacWriter.onprogress(blob, offset - arrayBufferWriter.blobLength);

        // Queue the next chunk for reading
        readNextChunk();
      };
    };

    // If an error prevents further reading, inform of error and stop
    reader.onerror = function chunkLoadFailed() {
      // Fire error event, including the context of the error
      if (guacWriter.onerror) guacWriter.onerror(blob, offset, reader.error);
    };

    // Begin reading the first chunk
    readNextChunk();
  };

  /**
   * Signals that no further text will be sent, effectively closing the
   * stream.
   */
  this.sendEnd = function sendEnd() {
    arrayBufferWriter.sendEnd();
  };

  /**
   * Fired for received data, if acknowledged by the server.
   *
   * @event
   * @param {Guacamole.Status} status
   *     The status of the operation.
   */
  this.onack = null;

  /**
   * Fired when an error occurs reading a blob passed to
   * [sendBlob()]{@link Guacamole.BlobWriter#sendBlob}. The transfer for the
   * the given blob will cease, but the stream will remain open.
   *
   * @event
   * @param {Blob} blob
   *     The blob that was being read when the error occurred.
   *
   * @param {Number} offset
   *     The offset of the failed read attempt within the blob, in bytes.
   *
   * @param {DOMError} error
   *     The error that occurred.
   */
  this.onerror = null;

  /**
   * Fired for each successfully-read chunk of data as a blob is being sent
   * via [sendBlob()]{@link Guacamole.BlobWriter#sendBlob}.
   *
   * @event
   * @param {Blob} blob
   *     The blob that is being read.
   *
   * @param {Number} offset
   *     The offset of the read that just succeeded.
   */
  this.onprogress = null;

  /**
   * Fired when a blob passed to
   * [sendBlob()]{@link Guacamole.BlobWriter#sendBlob} has finished being
   * sent.
   *
   * @event
   * @param {Blob} blob
   *     The blob that was sent.
   */
  this.oncomplete = null;
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Guacamole protocol client. Given a {@link Guacamole.Tunnel},
 * automatically handles incoming and outgoing Guacamole instructions via the
 * provided tunnel, updating its display using one or more canvas elements.
 *
 * @constructor
 * @param {Guacamole.Tunnel} tunnel The tunnel to use to send and receive
 *                                  Guacamole instructions.
 */
Guacamole.Client = function (tunnel) {
  var guac_client = this;

  var STATE_IDLE = 0;
  var STATE_CONNECTING = 1;
  var STATE_WAITING = 2;
  var STATE_CONNECTED = 3;
  var STATE_DISCONNECTING = 4;
  var STATE_DISCONNECTED = 5;

  var currentState = STATE_IDLE;

  var currentTimestamp = 0;
  var pingInterval = null;

  /**
   * Translation from Guacamole protocol line caps to Layer line caps.
   * @private
   */
  var lineCap = {
    0: "butt",
    1: "round",
    2: "square",
  };

  /**
   * Translation from Guacamole protocol line caps to Layer line caps.
   * @private
   */
  var lineJoin = {
    0: "bevel",
    1: "miter",
    2: "round",
  };

  /**
   * The underlying Guacamole display.
   *
   * @private
   * @type {Guacamole.Display}
   */
  var display = new Guacamole.Display();

  /**
   * All available layers and buffers
   *
   * @private
   * @type {Object.<Number, (Guacamole.Display.VisibleLayer|Guacamole.Layer)>}
   */
  var layers = {};

  /**
   * All audio players currently in use by the client. Initially, this will
   * be empty, but audio players may be allocated by the server upon request.
   *
   * @private
   * @type {Object.<Number, Guacamole.AudioPlayer>}
   */
  var audioPlayers = {};

  /**
   * All video players currently in use by the client. Initially, this will
   * be empty, but video players may be allocated by the server upon request.
   *
   * @private
   * @type {Object.<Number, Guacamole.VideoPlayer>}
   */
  var videoPlayers = {};

  // No initial parsers
  var parsers = [];

  // No initial streams
  var streams = [];

  /**
   * All current objects. The index of each object is dictated by the
   * Guacamole server.
   *
   * @private
   * @type {Guacamole.Object[]}
   */
  var objects = [];

  // Pool of available stream indices
  var stream_indices = new Guacamole.IntegerPool();

  // Array of allocated output streams by index
  var output_streams = [];

  function setState(state) {
    if (state != currentState) {
      currentState = state;
      if (guac_client.onstatechange) guac_client.onstatechange(currentState);
    }
  }

  function isConnected() {
    return currentState == STATE_CONNECTED || currentState == STATE_WAITING;
  }

  /**
   * Produces an opaque representation of Guacamole.Client state which can be
   * later imported through a call to importState(). This object is
   * effectively an independent, compressed snapshot of protocol and display
   * state. Invoking this function implicitly flushes the display.
   *
   * @param {function} callback
   *     Callback which should be invoked once the state object is ready. The
   *     state object will be passed to the callback as the sole parameter.
   *     This callback may be invoked immediately, or later as the display
   *     finishes rendering and becomes ready.
   */
  this.exportState = function exportState(callback) {
    // Start with empty state
    var state = {
      currentState: currentState,
      currentTimestamp: currentTimestamp,
      layers: {},
    };

    var layersSnapshot = {};

    // Make a copy of all current layers (protocol state)
    for (var key in layers) {
      layersSnapshot[key] = layers[key];
    }

    // Populate layers once data is available (display state, requires flush)
    display.flush(function populateLayers() {
      // Export each defined layer/buffer
      for (var key in layersSnapshot) {
        var index = parseInt(key);
        var layer = layersSnapshot[key];
        var canvas = layer.toCanvas();

        // Store layer/buffer dimensions
        var exportLayer = {
          width: layer.width,
          height: layer.height,
        };

        // Store layer/buffer image data, if it can be generated
        if (layer.width && layer.height)
          exportLayer.url = canvas.toDataURL("image/png");

        // Add layer properties if not a buffer nor the default layer
        if (index > 0) {
          exportLayer.x = layer.x;
          exportLayer.y = layer.y;
          exportLayer.z = layer.z;
          exportLayer.alpha = layer.alpha;
          exportLayer.matrix = layer.matrix;
          exportLayer.parent = getLayerIndex(layer.parent);
        }

        // Store exported layer
        state.layers[key] = exportLayer;
      }

      // Invoke callback now that the state is ready
      callback(state);
    });
  };

  /**
   * Restores Guacamole.Client protocol and display state based on an opaque
   * object from a prior call to exportState(). The Guacamole.Client instance
   * used to export that state need not be the same as this instance.
   *
   * @param {Object} state
   *     An opaque representation of Guacamole.Client state from a prior call
   *     to exportState().
   *
   * @param {function} [callback]
   *     The function to invoke when state has finished being imported. This
   *     may happen immediately, or later as images within the provided state
   *     object are loaded.
   */
  this.importState = function importState(state, callback) {
    var key;
    var index;

    currentState = state.currentState;
    currentTimestamp = state.currentTimestamp;

    // Dispose of all layers
    for (key in layers) {
      index = parseInt(key);
      if (index > 0) display.dispose(layers[key]);
    }

    layers = {};

    // Import state of each layer/buffer
    for (key in state.layers) {
      index = parseInt(key);

      var importLayer = state.layers[key];
      var layer = getLayer(index);

      // Reset layer size
      display.resize(layer, importLayer.width, importLayer.height);

      // Initialize new layer if it has associated data
      if (importLayer.url) {
        display.setChannelMask(layer, Guacamole.Layer.SRC);
        display.draw(layer, 0, 0, importLayer.url);
      }

      // Set layer-specific properties if not a buffer nor the default layer
      if (index > 0 && importLayer.parent >= 0) {
        // Apply layer position and set parent
        var parent = getLayer(importLayer.parent);
        display.move(
          layer,
          parent,
          importLayer.x,
          importLayer.y,
          importLayer.z
        );

        // Set layer transparency
        display.shade(layer, importLayer.alpha);

        // Apply matrix transform
        var matrix = importLayer.matrix;
        display.distort(
          layer,
          matrix[0],
          matrix[1],
          matrix[2],
          matrix[3],
          matrix[4],
          matrix[5]
        );
      }
    }

    // Flush changes to display
    display.flush(callback);
  };

  /**
   * Returns the underlying display of this Guacamole.Client. The display
   * contains an Element which can be added to the DOM, causing the
   * display to become visible.
   *
   * @return {Guacamole.Display} The underlying display of this
   *                             Guacamole.Client.
   */
  this.getDisplay = function () {
    return display;
  };

  /**
   * Sends the current size of the screen.
   *
   * @param {Number} width The width of the screen.
   * @param {Number} height The height of the screen.
   */
  this.sendSize = function (width, height) {
    // Do not send requests if not connected
    if (!isConnected()) return;

    tunnel.sendMessage("size", width, height);
  };

  /**
   * Sends a key event having the given properties as if the user
   * pressed or released a key.
   *
   * @param {Boolean} pressed Whether the key is pressed (true) or released
   *                          (false).
   * @param {Number} keysym The keysym of the key being pressed or released.
   */
  this.sendKeyEvent = function (pressed, keysym) {
    // Do not send requests if not connected
    if (!isConnected()) return;

    tunnel.sendMessage("key", keysym, pressed);
  };

  /**
   * Sends a mouse event having the properties provided by the given mouse
   * state.
   *
   * @param {Guacamole.Mouse.State} mouseState The state of the mouse to send
   *                                           in the mouse event.
   */
  this.sendMouseState = function (mouseState) {
    // Do not send requests if not connected
    if (!isConnected()) return;

    // Update client-side cursor
    display.moveCursor(Math.floor(mouseState.x), Math.floor(mouseState.y));

    // Build mask
    var buttonMask = 0;
    if (mouseState.left) buttonMask |= 1;
    if (mouseState.middle) buttonMask |= 2;
    if (mouseState.right) buttonMask |= 4;
    if (mouseState.up) buttonMask |= 8;
    if (mouseState.down) buttonMask |= 16;

    // Send message
    tunnel.sendMessage(
      "mouse",
      Math.floor(mouseState.x),
      Math.floor(mouseState.y),
      buttonMask
    );
  };

  /**
   * Allocates an available stream index and creates a new
   * Guacamole.OutputStream using that index, associating the resulting
   * stream with this Guacamole.Client. Note that this stream will not yet
   * exist as far as the other end of the Guacamole connection is concerned.
   * Streams exist within the Guacamole protocol only when referenced by an
   * instruction which creates the stream, such as a "clipboard", "file", or
   * "pipe" instruction.
   *
   * @returns {Guacamole.OutputStream}
   *     A new Guacamole.OutputStream with a newly-allocated index and
   *     associated with this Guacamole.Client.
   */
  this.createOutputStream = function createOutputStream() {
    // Allocate index
    var index = stream_indices.next();

    // Return new stream
    var stream = (output_streams[index] = new Guacamole.OutputStream(
      guac_client,
      index
    ));
    return stream;
  };

  /**
   * Opens a new audio stream for writing, where audio data having the give
   * mimetype will be sent along the returned stream. The instruction
   * necessary to create this stream will automatically be sent.
   *
   * @param {String} mimetype
   *     The mimetype of the audio data that will be sent along the returned
   *     stream.
   *
   * @return {Guacamole.OutputStream}
   *     The created audio stream.
   */
  this.createAudioStream = function (mimetype) {
    // Allocate and associate stream with audio metadata
    var stream = guac_client.createOutputStream();
    tunnel.sendMessage("audio", stream.index, mimetype);
    return stream;
  };

  /**
   * Opens a new file for writing, having the given index, mimetype and
   * filename. The instruction necessary to create this stream will
   * automatically be sent.
   *
   * @param {String} mimetype The mimetype of the file being sent.
   * @param {String} filename The filename of the file being sent.
   * @return {Guacamole.OutputStream} The created file stream.
   */
  this.createFileStream = function (mimetype, filename) {
    // Allocate and associate stream with file metadata
    var stream = guac_client.createOutputStream();
    tunnel.sendMessage("file", stream.index, mimetype, filename);
    return stream;
  };

  /**
   * Opens a new pipe for writing, having the given name and mimetype. The
   * instruction necessary to create this stream will automatically be sent.
   *
   * @param {String} mimetype The mimetype of the data being sent.
   * @param {String} name The name of the pipe.
   * @return {Guacamole.OutputStream} The created file stream.
   */
  this.createPipeStream = function (mimetype, name) {
    // Allocate and associate stream with pipe metadata
    var stream = guac_client.createOutputStream();
    tunnel.sendMessage("pipe", stream.index, mimetype, name);
    return stream;
  };

  /**
   * Opens a new clipboard object for writing, having the given mimetype. The
   * instruction necessary to create this stream will automatically be sent.
   *
   * @param {String} mimetype The mimetype of the data being sent.
   * @param {String} name The name of the pipe.
   * @return {Guacamole.OutputStream} The created file stream.
   */
  this.createClipboardStream = function (mimetype) {
    // Allocate and associate stream with clipboard metadata
    var stream = guac_client.createOutputStream();
    tunnel.sendMessage("clipboard", stream.index, mimetype);
    return stream;
  };

  /**
   * Opens a new argument value stream for writing, having the given
   * parameter name and mimetype, requesting that the connection parameter
   * with the given name be updated to the value described by the contents
   * of the following stream. The instruction necessary to create this stream
   * will automatically be sent.
   *
   * @param {String} mimetype
   *     The mimetype of the data being sent.
   *
   * @param {String} name
   *     The name of the connection parameter to attempt to update.
   *
   * @return {Guacamole.OutputStream}
   *     The created argument value stream.
   */
  this.createArgumentValueStream = function createArgumentValueStream(
    mimetype,
    name
  ) {
    // Allocate and associate stream with argument value metadata
    var stream = guac_client.createOutputStream();
    tunnel.sendMessage("argv", stream.index, mimetype, name);
    return stream;
  };

  /**
   * Creates a new output stream associated with the given object and having
   * the given mimetype and name. The legality of a mimetype and name is
   * dictated by the object itself. The instruction necessary to create this
   * stream will automatically be sent.
   *
   * @param {Number} index
   *     The index of the object for which the output stream is being
   *     created.
   *
   * @param {String} mimetype
   *     The mimetype of the data which will be sent to the output stream.
   *
   * @param {String} name
   *     The defined name of an output stream within the given object.
   *
   * @returns {Guacamole.OutputStream}
   *     An output stream which will write blobs to the named output stream
   *     of the given object.
   */
  this.createObjectOutputStream = function createObjectOutputStream(
    index,
    mimetype,
    name
  ) {
    // Allocate and ssociate stream with object metadata
    var stream = guac_client.createOutputStream();
    tunnel.sendMessage("put", index, stream.index, mimetype, name);
    return stream;
  };

  /**
   * Requests read access to the input stream having the given name. If
   * successful, a new input stream will be created.
   *
   * @param {Number} index
   *     The index of the object from which the input stream is being
   *     requested.
   *
   * @param {String} name
   *     The name of the input stream to request.
   */
  this.requestObjectInputStream = function requestObjectInputStream(
    index,
    name
  ) {
    // Do not send requests if not connected
    if (!isConnected()) return;

    tunnel.sendMessage("get", index, name);
  };

  /**
   * Acknowledge receipt of a blob on the stream with the given index.
   *
   * @param {Number} index The index of the stream associated with the
   *                       received blob.
   * @param {String} message A human-readable message describing the error
   *                         or status.
   * @param {Number} code The error code, if any, or 0 for success.
   */
  this.sendAck = function (index, message, code) {
    // Do not send requests if not connected
    if (!isConnected()) return;

    tunnel.sendMessage("ack", index, message, code);
  };

  /**
   * Given the index of a file, writes a blob of data to that file.
   *
   * @param {Number} index The index of the file to write to.
   * @param {String} data Base64-encoded data to write to the file.
   */
  this.sendBlob = function (index, data) {
    // Do not send requests if not connected
    if (!isConnected()) return;

    tunnel.sendMessage("blob", index, data);
  };

  /**
   * Marks a currently-open stream as complete. The other end of the
   * Guacamole connection will be notified via an "end" instruction that the
   * stream is closed, and the index will be made available for reuse in
   * future streams.
   *
   * @param {Number} index
   *     The index of the stream to end.
   */
  this.endStream = function (index) {
    // Do not send requests if not connected
    if (!isConnected()) return;

    // Explicitly close stream by sending "end" instruction
    tunnel.sendMessage("end", index);

    // Free associated index and stream if they exist
    if (output_streams[index]) {
      stream_indices.free(index);
      delete output_streams[index];
    }
  };

  /**
   * Fired whenever the state of this Guacamole.Client changes.
   *
   * @event
   * @param {Number} state The new state of the client.
   */
  this.onstatechange = null;

  /**
   * Fired when the remote client sends a name update.
   *
   * @event
   * @param {String} name The new name of this client.
   */
  this.onname = null;

  /**
   * Fired when an error is reported by the remote client, and the connection
   * is being closed.
   *
   * @event
   * @param {Guacamole.Status} status A status object which describes the
   *                                  error.
   */
  this.onerror = null;

  /**
   * Fired when a audio stream is created. The stream provided to this event
   * handler will contain its own event handlers for received data.
   *
   * @event
   * @param {Guacamole.InputStream} stream
   *     The stream that will receive audio data from the server.
   *
   * @param {String} mimetype
   *     The mimetype of the audio data which will be received.
   *
   * @return {Guacamole.AudioPlayer}
   *     An object which implements the Guacamole.AudioPlayer interface and
   *     has been initialied to play the data in the provided stream, or null
   *     if the built-in audio players of the Guacamole client should be
   *     used.
   */
  this.onaudio = null;

  /**
   * Fired when a video stream is created. The stream provided to this event
   * handler will contain its own event handlers for received data.
   *
   * @event
   * @param {Guacamole.InputStream} stream
   *     The stream that will receive video data from the server.
   *
   * @param {Guacamole.Display.VisibleLayer} layer
   *     The destination layer on which the received video data should be
   *     played. It is the responsibility of the Guacamole.VideoPlayer
   *     implementation to play the received data within this layer.
   *
   * @param {String} mimetype
   *     The mimetype of the video data which will be received.
   *
   * @return {Guacamole.VideoPlayer}
   *     An object which implements the Guacamole.VideoPlayer interface and
   *     has been initialied to play the data in the provided stream, or null
   *     if the built-in video players of the Guacamole client should be
   *     used.
   */
  this.onvideo = null;

  /**
   * Fired when the current value of a connection parameter is being exposed
   * by the server.
   *
   * @event
   * @param {Guacamole.InputStream} stream
   *     The stream that will receive connection parameter data from the
   *     server.
   *
   * @param {String} mimetype
   *     The mimetype of the data which will be received.
   *
   * @param {String} name
   *     The name of the connection parameter whose value is being exposed.
   */
  this.onargv = null;

  /**
   * Fired when the clipboard of the remote client is changing.
   *
   * @event
   * @param {Guacamole.InputStream} stream The stream that will receive
   *                                       clipboard data from the server.
   * @param {String} mimetype The mimetype of the data which will be received.
   */
  this.onclipboard = null;

  /**
   * Fired when a file stream is created. The stream provided to this event
   * handler will contain its own event handlers for received data.
   *
   * @event
   * @param {Guacamole.InputStream} stream The stream that will receive data
   *                                       from the server.
   * @param {String} mimetype The mimetype of the file received.
   * @param {String} filename The name of the file received.
   */
  this.onfile = null;

  /**
   * Fired when a filesystem object is created. The object provided to this
   * event handler will contain its own event handlers and functions for
   * requesting and handling data.
   *
   * @event
   * @param {Guacamole.Object} object
   *     The created filesystem object.
   *
   * @param {String} name
   *     The name of the filesystem.
   */
  this.onfilesystem = null;

  /**
   * Fired when a pipe stream is created. The stream provided to this event
   * handler will contain its own event handlers for received data;
   *
   * @event
   * @param {Guacamole.InputStream} stream The stream that will receive data
   *                                       from the server.
   * @param {String} mimetype The mimetype of the data which will be received.
   * @param {String} name The name of the pipe.
   */
  this.onpipe = null;

  /**
   * Fired when a "required" instruction is received. A required instruction
   * indicates that additional parameters are required for the connection to
   * continue, such as user credentials.
   *
   * @event
   * @param {String[]} parameters
   *      The names of the connection parameters that are required to be
   *      provided for the connection to continue.
   */
  this.onrequired = null;

  /**
   * Fired whenever a sync instruction is received from the server, indicating
   * that the server is finished processing any input from the client and
   * has sent any results.
   *
   * @event
   * @param {Number} timestamp The timestamp associated with the sync
   *                           instruction.
   */
  this.onsync = null;

  /**
   * Returns the layer with the given index, creating it if necessary.
   * Positive indices refer to visible layers, an index of zero refers to
   * the default layer, and negative indices refer to buffers.
   *
   * @private
   * @param {Number} index
   *     The index of the layer to retrieve.
   *
   * @return {Guacamole.Display.VisibleLayer|Guacamole.Layer}
   *     The layer having the given index.
   */
  var getLayer = function getLayer(index) {
    // Get layer, create if necessary
    var layer = layers[index];
    if (!layer) {
      // Create layer based on index
      if (index === 0) layer = display.getDefaultLayer();
      else if (index > 0) layer = display.createLayer();
      else layer = display.createBuffer();

      // Add new layer
      layers[index] = layer;
    }

    return layer;
  };

  /**
   * Returns the index passed to getLayer() when the given layer was created.
   * Positive indices refer to visible layers, an index of zero refers to the
   * default layer, and negative indices refer to buffers.
   *
   * @param {Guacamole.Display.VisibleLayer|Guacamole.Layer} layer
   *     The layer whose index should be determined.
   *
   * @returns {Number}
   *     The index of the given layer, or null if no such layer is associated
   *     with this client.
   */
  var getLayerIndex = function getLayerIndex(layer) {
    // Avoid searching if there clearly is no such layer
    if (!layer) return null;

    // Search through each layer, returning the index of the given layer
    // once found
    for (var key in layers) {
      if (layer === layers[key]) return parseInt(key);
    }

    // Otherwise, no such index
    return null;
  };

  function getParser(index) {
    var parser = parsers[index];

    // If parser not yet created, create it, and tie to the
    // oninstruction handler of the tunnel.
    if (parser == null) {
      parser = parsers[index] = new Guacamole.Parser();
      parser.oninstruction = tunnel.oninstruction;
    }

    return parser;
  }

  /**
   * Handlers for all defined layer properties.
   * @private
   */
  var layerPropertyHandlers = {
    "miter-limit": function (layer, value) {
      display.setMiterLimit(layer, parseFloat(value));
    },
  };

  /**
   * Handlers for all instruction opcodes receivable by a Guacamole protocol
   * client.
   * @private
   */
  var instructionHandlers = {
    ack: function (parameters) {
      var stream_index = parseInt(parameters[0]);
      var reason = parameters[1];
      var code = parseInt(parameters[2]);

      // Get stream
      var stream = output_streams[stream_index];
      if (stream) {
        // Signal ack if handler defined
        if (stream.onack) stream.onack(new Guacamole.Status(code, reason));

        // If code is an error, invalidate stream if not already
        // invalidated by onack handler
        if (code >= 0x0100 && output_streams[stream_index] === stream) {
          stream_indices.free(stream_index);
          delete output_streams[stream_index];
        }
      }
    },

    arc: function (parameters) {
      var layer = getLayer(parseInt(parameters[0]));
      var x = parseInt(parameters[1]);
      var y = parseInt(parameters[2]);
      var radius = parseInt(parameters[3]);
      var startAngle = parseFloat(parameters[4]);
      var endAngle = parseFloat(parameters[5]);
      var negative = parseInt(parameters[6]);

      display.arc(layer, x, y, radius, startAngle, endAngle, negative != 0);
    },

    argv: function (parameters) {
      var stream_index = parseInt(parameters[0]);
      var mimetype = parameters[1];
      var name = parameters[2];

      // Create stream
      if (guac_client.onargv) {
        var stream = (streams[stream_index] = new Guacamole.InputStream(
          guac_client,
          stream_index
        ));
        guac_client.onargv(stream, mimetype, name);
      }

      // Otherwise, unsupported
      else
        guac_client.sendAck(
          stream_index,
          "Receiving argument values unsupported",
          0x0100
        );
    },

    audio: function (parameters) {
      var stream_index = parseInt(parameters[0]);
      var mimetype = parameters[1];

      // Create stream
      var stream = (streams[stream_index] = new Guacamole.InputStream(
        guac_client,
        stream_index
      ));

      // Get player instance via callback
      var audioPlayer = null;
      if (guac_client.onaudio)
        audioPlayer = guac_client.onaudio(stream, mimetype);

      // If unsuccessful, try to use a default implementation
      if (!audioPlayer)
        audioPlayer = Guacamole.AudioPlayer.getInstance(stream, mimetype);

      // If we have successfully retrieved an audio player, send success response
      if (audioPlayer) {
        audioPlayers[stream_index] = audioPlayer;
        guac_client.sendAck(stream_index, "OK", 0x0000);
      }

      // Otherwise, mimetype must be unsupported
      else guac_client.sendAck(stream_index, "BAD TYPE", 0x030f);
    },

    blob: function (parameters) {
      // Get stream
      var stream_index = parseInt(parameters[0]);
      var data = parameters[1];
      var stream = streams[stream_index];

      // Write data
      if (stream && stream.onblob) stream.onblob(data);
    },

    body: function handleBody(parameters) {
      // Get object
      var objectIndex = parseInt(parameters[0]);
      var object = objects[objectIndex];

      var streamIndex = parseInt(parameters[1]);
      var mimetype = parameters[2];
      var name = parameters[3];

      // Create stream if handler defined
      if (object && object.onbody) {
        var stream = (streams[streamIndex] = new Guacamole.InputStream(
          guac_client,
          streamIndex
        ));
        object.onbody(stream, mimetype, name);
      }

      // Otherwise, unsupported
      else
        guac_client.sendAck(streamIndex, "Receipt of body unsupported", 0x0100);
    },

    cfill: function (parameters) {
      var channelMask = parseInt(parameters[0]);
      var layer = getLayer(parseInt(parameters[1]));
      var r = parseInt(parameters[2]);
      var g = parseInt(parameters[3]);
      var b = parseInt(parameters[4]);
      var a = parseInt(parameters[5]);

      display.setChannelMask(layer, channelMask);
      display.fillColor(layer, r, g, b, a);
    },

    clip: function (parameters) {
      var layer = getLayer(parseInt(parameters[0]));

      display.clip(layer);
    },

    clipboard: function (parameters) {
      var stream_index = parseInt(parameters[0]);
      var mimetype = parameters[1];

      // Create stream
      if (guac_client.onclipboard) {
        var stream = (streams[stream_index] = new Guacamole.InputStream(
          guac_client,
          stream_index
        ));
        guac_client.onclipboard(stream, mimetype);
      }

      // Otherwise, unsupported
      else guac_client.sendAck(stream_index, "Clipboard unsupported", 0x0100);
    },

    close: function (parameters) {
      var layer = getLayer(parseInt(parameters[0]));

      display.close(layer);
    },

    copy: function (parameters) {
      var srcL = getLayer(parseInt(parameters[0]));
      var srcX = parseInt(parameters[1]);
      var srcY = parseInt(parameters[2]);
      var srcWidth = parseInt(parameters[3]);
      var srcHeight = parseInt(parameters[4]);
      var channelMask = parseInt(parameters[5]);
      var dstL = getLayer(parseInt(parameters[6]));
      var dstX = parseInt(parameters[7]);
      var dstY = parseInt(parameters[8]);

      display.setChannelMask(dstL, channelMask);
      display.copy(srcL, srcX, srcY, srcWidth, srcHeight, dstL, dstX, dstY);
    },

    cstroke: function (parameters) {
      var channelMask = parseInt(parameters[0]);
      var layer = getLayer(parseInt(parameters[1]));
      var cap = lineCap[parseInt(parameters[2])];
      var join = lineJoin[parseInt(parameters[3])];
      var thickness = parseInt(parameters[4]);
      var r = parseInt(parameters[5]);
      var g = parseInt(parameters[6]);
      var b = parseInt(parameters[7]);
      var a = parseInt(parameters[8]);

      display.setChannelMask(layer, channelMask);
      display.strokeColor(layer, cap, join, thickness, r, g, b, a);
    },

    cursor: function (parameters) {
      var cursorHotspotX = parseInt(parameters[0]);
      var cursorHotspotY = parseInt(parameters[1]);
      var srcL = getLayer(parseInt(parameters[2]));
      var srcX = parseInt(parameters[3]);
      var srcY = parseInt(parameters[4]);
      var srcWidth = parseInt(parameters[5]);
      var srcHeight = parseInt(parameters[6]);

      display.setCursor(
        cursorHotspotX,
        cursorHotspotY,
        srcL,
        srcX,
        srcY,
        srcWidth,
        srcHeight
      );
    },

    curve: function (parameters) {
      var layer = getLayer(parseInt(parameters[0]));
      var cp1x = parseInt(parameters[1]);
      var cp1y = parseInt(parameters[2]);
      var cp2x = parseInt(parameters[3]);
      var cp2y = parseInt(parameters[4]);
      var x = parseInt(parameters[5]);
      var y = parseInt(parameters[6]);

      display.curveTo(layer, cp1x, cp1y, cp2x, cp2y, x, y);
    },

    disconnect: function handleDisconnect(parameters) {
      // Explicitly tear down connection
      guac_client.disconnect();
    },

    dispose: function (parameters) {
      var layer_index = parseInt(parameters[0]);

      // If visible layer, remove from parent
      if (layer_index > 0) {
        // Remove from parent
        var layer = getLayer(layer_index);
        display.dispose(layer);

        // Delete reference
        delete layers[layer_index];
      }

      // If buffer, just delete reference
      else if (layer_index < 0) delete layers[layer_index];

      // Attempting to dispose the root layer currently has no effect.
    },

    distort: function (parameters) {
      var layer_index = parseInt(parameters[0]);
      var a = parseFloat(parameters[1]);
      var b = parseFloat(parameters[2]);
      var c = parseFloat(parameters[3]);
      var d = parseFloat(parameters[4]);
      var e = parseFloat(parameters[5]);
      var f = parseFloat(parameters[6]);

      // Only valid for visible layers (not buffers)
      if (layer_index >= 0) {
        var layer = getLayer(layer_index);
        display.distort(layer, a, b, c, d, e, f);
      }
    },

    error: function (parameters) {
      var reason = parameters[0];
      var code = parseInt(parameters[1]);

      // Call handler if defined
      if (guac_client.onerror)
        guac_client.onerror(new Guacamole.Status(code, reason));

      guac_client.disconnect();
    },

    end: function (parameters) {
      var stream_index = parseInt(parameters[0]);

      // Get stream
      var stream = streams[stream_index];
      if (stream) {
        // Signal end of stream if handler defined
        if (stream.onend) stream.onend();

        // Invalidate stream
        delete streams[stream_index];
      }
    },

    file: function (parameters) {
      var stream_index = parseInt(parameters[0]);
      var mimetype = parameters[1];
      var filename = parameters[2];

      // Create stream
      if (guac_client.onfile) {
        var stream = (streams[stream_index] = new Guacamole.InputStream(
          guac_client,
          stream_index
        ));
        guac_client.onfile(stream, mimetype, filename);
      }

      // Otherwise, unsupported
      else
        guac_client.sendAck(stream_index, "File transfer unsupported", 0x0100);
    },

    filesystem: function handleFilesystem(parameters) {
      var objectIndex = parseInt(parameters[0]);
      var name = parameters[1];

      // Create object, if supported
      if (guac_client.onfilesystem) {
        var object = (objects[objectIndex] = new Guacamole.Object(
          guac_client,
          objectIndex
        ));
        guac_client.onfilesystem(object, name);
      }

      // If unsupported, simply ignore the availability of the filesystem
    },

    identity: function (parameters) {
      var layer = getLayer(parseInt(parameters[0]));

      display.setTransform(layer, 1, 0, 0, 1, 0, 0);
    },

    img: function (parameters) {
      var stream_index = parseInt(parameters[0]);
      var channelMask = parseInt(parameters[1]);
      var layer = getLayer(parseInt(parameters[2]));
      var mimetype = parameters[3];
      var x = parseInt(parameters[4]);
      var y = parseInt(parameters[5]);

      // Create stream
      var stream = (streams[stream_index] = new Guacamole.InputStream(
        guac_client,
        stream_index
      ));

      // Draw received contents once decoded
      display.setChannelMask(layer, channelMask);
      display.drawStream(layer, x, y, stream, mimetype);
    },

    jpeg: function (parameters) {
      var channelMask = parseInt(parameters[0]);
      var layer = getLayer(parseInt(parameters[1]));
      var x = parseInt(parameters[2]);
      var y = parseInt(parameters[3]);
      var data = parameters[4];

      display.setChannelMask(layer, channelMask);
      display.draw(layer, x, y, "data:image/jpeg;base64," + data);
    },

    lfill: function (parameters) {
      var channelMask = parseInt(parameters[0]);
      var layer = getLayer(parseInt(parameters[1]));
      var srcLayer = getLayer(parseInt(parameters[2]));

      display.setChannelMask(layer, channelMask);
      display.fillLayer(layer, srcLayer);
    },

    line: function (parameters) {
      var layer = getLayer(parseInt(parameters[0]));
      var x = parseInt(parameters[1]);
      var y = parseInt(parameters[2]);

      display.lineTo(layer, x, y);
    },

    lstroke: function (parameters) {
      var channelMask = parseInt(parameters[0]);
      var layer = getLayer(parseInt(parameters[1]));
      var srcLayer = getLayer(parseInt(parameters[2]));

      display.setChannelMask(layer, channelMask);
      display.strokeLayer(layer, srcLayer);
    },

    mouse: function handleMouse(parameters) {
      var x = parseInt(parameters[0]);
      var y = parseInt(parameters[1]);

      // Display and move software cursor to received coordinates
      display.showCursor(true);
      display.moveCursor(x, y);
    },

    move: function (parameters) {
      var layer_index = parseInt(parameters[0]);
      var parent_index = parseInt(parameters[1]);
      var x = parseInt(parameters[2]);
      var y = parseInt(parameters[3]);
      var z = parseInt(parameters[4]);

      // Only valid for non-default layers
      if (layer_index > 0 && parent_index >= 0) {
        var layer = getLayer(layer_index);
        var parent = getLayer(parent_index);
        display.move(layer, parent, x, y, z);
      }
    },

    name: function (parameters) {
      if (guac_client.onname) guac_client.onname(parameters[0]);
    },

    nest: function (parameters) {
      var parser = getParser(parseInt(parameters[0]));
      parser.receive(parameters[1]);
    },

    pipe: function (parameters) {
      var stream_index = parseInt(parameters[0]);
      var mimetype = parameters[1];
      var name = parameters[2];

      // Create stream
      if (guac_client.onpipe) {
        var stream = (streams[stream_index] = new Guacamole.InputStream(
          guac_client,
          stream_index
        ));
        guac_client.onpipe(stream, mimetype, name);
      }

      // Otherwise, unsupported
      else guac_client.sendAck(stream_index, "Named pipes unsupported", 0x0100);
    },

    png: function (parameters) {
      var channelMask = parseInt(parameters[0]);
      var layer = getLayer(parseInt(parameters[1]));
      var x = parseInt(parameters[2]);
      var y = parseInt(parameters[3]);
      var data = parameters[4];

      display.setChannelMask(layer, channelMask);
      display.draw(layer, x, y, "data:image/png;base64," + data);
    },

    pop: function (parameters) {
      var layer = getLayer(parseInt(parameters[0]));

      display.pop(layer);
    },

    push: function (parameters) {
      var layer = getLayer(parseInt(parameters[0]));

      display.push(layer);
    },

    rect: function (parameters) {
      var layer = getLayer(parseInt(parameters[0]));
      var x = parseInt(parameters[1]);
      var y = parseInt(parameters[2]);
      var w = parseInt(parameters[3]);
      var h = parseInt(parameters[4]);

      display.rect(layer, x, y, w, h);
    },

    required: function required(parameters) {
      if (guac_client.onrequired) guac_client.onrequired(parameters);
    },

    reset: function (parameters) {
      var layer = getLayer(parseInt(parameters[0]));

      display.reset(layer);
    },

    set: function (parameters) {
      var layer = getLayer(parseInt(parameters[0]));
      var name = parameters[1];
      var value = parameters[2];

      // Call property handler if defined
      var handler = layerPropertyHandlers[name];
      if (handler) handler(layer, value);
    },

    shade: function (parameters) {
      var layer_index = parseInt(parameters[0]);
      var a = parseInt(parameters[1]);

      // Only valid for visible layers (not buffers)
      if (layer_index >= 0) {
        var layer = getLayer(layer_index);
        display.shade(layer, a);
      }
    },

    size: function (parameters) {
      var layer_index = parseInt(parameters[0]);
      var layer = getLayer(layer_index);
      var width = parseInt(parameters[1]);
      var height = parseInt(parameters[2]);

      display.resize(layer, width, height);
    },

    start: function (parameters) {
      var layer = getLayer(parseInt(parameters[0]));
      var x = parseInt(parameters[1]);
      var y = parseInt(parameters[2]);

      display.moveTo(layer, x, y);
    },

    sync: function (parameters) {
      var timestamp = parseInt(parameters[0]);

      // Flush display, send sync when done
      display.flush(function displaySyncComplete() {
        // Synchronize all audio players
        for (var index in audioPlayers) {
          var audioPlayer = audioPlayers[index];
          if (audioPlayer) audioPlayer.sync();
        }

        // Send sync response to server
        if (timestamp !== currentTimestamp) {
          tunnel.sendMessage("sync", timestamp);
          currentTimestamp = timestamp;
        }
      });

      // If received first update, no longer waiting.
      if (currentState === STATE_WAITING) setState(STATE_CONNECTED);

      // Call sync handler if defined
      if (guac_client.onsync) guac_client.onsync(timestamp);
    },

    transfer: function (parameters) {
      var srcL = getLayer(parseInt(parameters[0]));
      var srcX = parseInt(parameters[1]);
      var srcY = parseInt(parameters[2]);
      var srcWidth = parseInt(parameters[3]);
      var srcHeight = parseInt(parameters[4]);
      var function_index = parseInt(parameters[5]);
      var dstL = getLayer(parseInt(parameters[6]));
      var dstX = parseInt(parameters[7]);
      var dstY = parseInt(parameters[8]);

      /* SRC */
      if (function_index === 0x3)
        display.put(srcL, srcX, srcY, srcWidth, srcHeight, dstL, dstX, dstY);
      /* Anything else that isn't a NO-OP */ else if (function_index !== 0x5)
        display.transfer(
          srcL,
          srcX,
          srcY,
          srcWidth,
          srcHeight,
          dstL,
          dstX,
          dstY,
          Guacamole.Client.DefaultTransferFunction[function_index]
        );
    },

    transform: function (parameters) {
      var layer = getLayer(parseInt(parameters[0]));
      var a = parseFloat(parameters[1]);
      var b = parseFloat(parameters[2]);
      var c = parseFloat(parameters[3]);
      var d = parseFloat(parameters[4]);
      var e = parseFloat(parameters[5]);
      var f = parseFloat(parameters[6]);

      display.transform(layer, a, b, c, d, e, f);
    },

    undefine: function handleUndefine(parameters) {
      // Get object
      var objectIndex = parseInt(parameters[0]);
      var object = objects[objectIndex];

      // Signal end of object definition
      if (object && object.onundefine) object.onundefine();
    },

    video: function (parameters) {
      var stream_index = parseInt(parameters[0]);
      var layer = getLayer(parseInt(parameters[1]));
      var mimetype = parameters[2];

      // Create stream
      var stream = (streams[stream_index] = new Guacamole.InputStream(
        guac_client,
        stream_index
      ));

      // Get player instance via callback
      var videoPlayer = null;
      if (guac_client.onvideo)
        videoPlayer = guac_client.onvideo(stream, layer, mimetype);

      // If unsuccessful, try to use a default implementation
      if (!videoPlayer)
        videoPlayer = Guacamole.VideoPlayer.getInstance(
          stream,
          layer,
          mimetype
        );

      // If we have successfully retrieved an video player, send success response
      if (videoPlayer) {
        videoPlayers[stream_index] = videoPlayer;
        guac_client.sendAck(stream_index, "OK", 0x0000);
      }

      // Otherwise, mimetype must be unsupported
      else guac_client.sendAck(stream_index, "BAD TYPE", 0x030f);
    },
  };

  tunnel.oninstruction = function (opcode, parameters) {
    var handler = instructionHandlers[opcode];
    if (handler) handler(parameters);
  };

  /**
   * Sends a disconnect instruction to the server and closes the tunnel.
   */
  this.disconnect = function () {
    // Only attempt disconnection not disconnected.
    if (
      currentState != STATE_DISCONNECTED &&
      currentState != STATE_DISCONNECTING
    ) {
      setState(STATE_DISCONNECTING);

      // Stop ping
      if (pingInterval) window.clearInterval(pingInterval);

      // Send disconnect message and disconnect
      tunnel.sendMessage("disconnect");
      tunnel.disconnect();
      setState(STATE_DISCONNECTED);
    }
  };

  /**
   * Connects the underlying tunnel of this Guacamole.Client, passing the
   * given arbitrary data to the tunnel during the connection process.
   *
   * @param data Arbitrary connection data to be sent to the underlying
   *             tunnel during the connection process.
   * @param onOpenCallback socket  onpen 
   * @throws {Guacamole.Status} If an error occurs during connection.
   */
  this.connect = function (data, onOpenCallback) {
    setState(STATE_CONNECTING);

    try {
      tunnel.connect(data, onOpenCallback);
    } catch (status) {
      setState(STATE_IDLE);
      throw status;
    }

    // Ping every 5 seconds (ensure connection alive)
    // pingInterval = window.setInterval(function() {
    //     tunnel.sendMessage("nop");
    // }, 5000);

    setState(STATE_WAITING);
  };
};

/**
 * Map of all Guacamole binary raster operations to transfer functions.
 * @private
 */
Guacamole.Client.DefaultTransferFunction = {
  /* BLACK */
  0x0: function (src, dst) {
    dst.red = dst.green = dst.blue = 0x00;
  },

  /* WHITE */
  0xf: function (src, dst) {
    dst.red = dst.green = dst.blue = 0xff;
  },

  /* SRC */
  0x3: function (src, dst) {
    dst.red = src.red;
    dst.green = src.green;
    dst.blue = src.blue;
    dst.alpha = src.alpha;
  },

  /* DEST (no-op) */
  0x5: function (src, dst) {
    // Do nothing
  },

  /* Invert SRC */
  0xc: function (src, dst) {
    dst.red = 0xff & ~src.red;
    dst.green = 0xff & ~src.green;
    dst.blue = 0xff & ~src.blue;
    dst.alpha = src.alpha;
  },

  /* Invert DEST */
  0xa: function (src, dst) {
    dst.red = 0xff & ~dst.red;
    dst.green = 0xff & ~dst.green;
    dst.blue = 0xff & ~dst.blue;
  },

  /* AND */
  0x1: function (src, dst) {
    dst.red = src.red & dst.red;
    dst.green = src.green & dst.green;
    dst.blue = src.blue & dst.blue;
  },

  /* NAND */
  0xe: function (src, dst) {
    dst.red = 0xff & ~(src.red & dst.red);
    dst.green = 0xff & ~(src.green & dst.green);
    dst.blue = 0xff & ~(src.blue & dst.blue);
  },

  /* OR */
  0x7: function (src, dst) {
    dst.red = src.red | dst.red;
    dst.green = src.green | dst.green;
    dst.blue = src.blue | dst.blue;
  },

  /* NOR */
  0x8: function (src, dst) {
    dst.red = 0xff & ~(src.red | dst.red);
    dst.green = 0xff & ~(src.green | dst.green);
    dst.blue = 0xff & ~(src.blue | dst.blue);
  },

  /* XOR */
  0x6: function (src, dst) {
    dst.red = src.red ^ dst.red;
    dst.green = src.green ^ dst.green;
    dst.blue = src.blue ^ dst.blue;
  },

  /* XNOR */
  0x9: function (src, dst) {
    dst.red = 0xff & ~(src.red ^ dst.red);
    dst.green = 0xff & ~(src.green ^ dst.green);
    dst.blue = 0xff & ~(src.blue ^ dst.blue);
  },

  /* AND inverted source */
  0x4: function (src, dst) {
    dst.red = 0xff & (~src.red & dst.red);
    dst.green = 0xff & (~src.green & dst.green);
    dst.blue = 0xff & (~src.blue & dst.blue);
  },

  /* OR inverted source */
  0xd: function (src, dst) {
    dst.red = 0xff & (~src.red | dst.red);
    dst.green = 0xff & (~src.green | dst.green);
    dst.blue = 0xff & (~src.blue | dst.blue);
  },

  /* AND inverted destination */
  0x2: function (src, dst) {
    dst.red = 0xff & (src.red & ~dst.red);
    dst.green = 0xff & (src.green & ~dst.green);
    dst.blue = 0xff & (src.blue & ~dst.blue);
  },

  /* OR inverted destination */
  0xb: function (src, dst) {
    dst.red = 0xff & (src.red | ~dst.red);
    dst.green = 0xff & (src.green | ~dst.green);
    dst.blue = 0xff & (src.blue | ~dst.blue);
  },
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A reader which automatically handles the given input stream, returning
 * received blobs as a single data URI built over the course of the stream.
 * Note that this object will overwrite any installed event handlers on the
 * given Guacamole.InputStream.
 *
 * @constructor
 * @param {Guacamole.InputStream} stream
 *     The stream that data will be read from.
 */
Guacamole.DataURIReader = function (stream, mimetype) {
  /**
   * Reference to this Guacamole.DataURIReader.
   * @private
   */
  var guac_reader = this;

  /**
   * Current data URI.
   *
   * @private
   * @type {String}
   */
  var uri = "data:" + mimetype + ";base64,";

  // Receive blobs as array buffers
  stream.onblob = function dataURIReaderBlob(data) {
    // Currently assuming data will ALWAYS be safe to simply append. This
    // will not be true if the received base64 data encodes a number of
    // bytes that isn't a multiple of three (as base64 expands in a ratio
    // of exactly 3:4).
    uri += data;
  };

  // Simply call onend when end received
  stream.onend = function dataURIReaderEnd() {
    if (guac_reader.onend) guac_reader.onend();
  };

  /**
   * Returns the data URI of all data received through the underlying stream
   * thus far.
   *
   * @returns {String}
   *     The data URI of all data received through the underlying stream thus
   *     far.
   */
  this.getURI = function getURI() {
    return uri;
  };

  /**
   * Fired once this stream is finished and no further data will be written.
   *
   * @event
   */
  this.onend = null;
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * The Guacamole display. The display does not deal with the Guacamole
 * protocol, and instead implements a set of graphical operations which
 * embody the set of operations present in the protocol. The order operations
 * are executed is guaranteed to be in the same order as their corresponding
 * functions are called.
 *
 * @constructor
 */
Guacamole.Display = function () {
  /**
   * Reference to this Guacamole.Display.
   * @private
   */
  var guac_display = this;

  var displayWidth = 0;
  var displayHeight = 0;
  var displayScale = 1;

  // Create display
  var display = document.createElement("div");
  display.style.position = "relative";
  display.style.width = displayWidth + "px";
  display.style.height = displayHeight + "px";

  // Ensure transformations on display originate at 0,0
  display.style.transformOrigin =
    display.style.webkitTransformOrigin =
    display.style.MozTransformOrigin =
    display.style.OTransformOrigin =
    display.style.msTransformOrigin =
      "0 0";

  // Create default layer
  var default_layer = new Guacamole.Display.VisibleLayer(
    displayWidth,
    displayHeight
  );

  // Create cursor layer
  var cursor = new Guacamole.Display.VisibleLayer(0, 0);
  cursor.setChannelMask(Guacamole.Layer.SRC);

  // Add default layer and cursor to display
  display.appendChild(default_layer.getElement());
  display.appendChild(cursor.getElement());

  // Create bounding div
  var bounds = document.createElement("div");
  bounds.style.position = "relative";
  bounds.style.width = displayWidth * displayScale + "px";
  bounds.style.height = displayHeight * displayScale + "px";

  // Add display to bounds
  bounds.appendChild(display);

  /**
   * The X coordinate of the hotspot of the mouse cursor. The hotspot is
   * the relative location within the image of the mouse cursor at which
   * each click occurs.
   *
   * @type {Number}
   */
  this.cursorHotspotX = 0;

  /**
   * The Y coordinate of the hotspot of the mouse cursor. The hotspot is
   * the relative location within the image of the mouse cursor at which
   * each click occurs.
   *
   * @type {Number}
   */
  this.cursorHotspotY = 0;

  /**
   * The current X coordinate of the local mouse cursor. This is not
   * necessarily the location of the actual mouse - it refers only to
   * the location of the cursor image within the Guacamole display, as
   * last set by moveCursor().
   *
   * @type {Number}
   */
  this.cursorX = 0;

  /**
   * The current X coordinate of the local mouse cursor. This is not
   * necessarily the location of the actual mouse - it refers only to
   * the location of the cursor image within the Guacamole display, as
   * last set by moveCursor().
   *
   * @type {Number}
   */
  this.cursorY = 0;

  /**
   * Fired when the default layer (and thus the entire Guacamole display)
   * is resized.
   *
   * @event
   * @param {Number} width The new width of the Guacamole display.
   * @param {Number} height The new height of the Guacamole display.
   */
  this.onresize = null;

  /**
   * Fired whenever the local cursor image is changed. This can be used to
   * implement special handling of the client-side cursor, or to override
   * the default use of a software cursor layer.
   *
   * @event
   * @param {HTMLCanvasElement} canvas The cursor image.
   * @param {Number} x The X-coordinate of the cursor hotspot.
   * @param {Number} y The Y-coordinate of the cursor hotspot.
   */
  this.oncursor = null;

  /**
   * The queue of all pending Tasks. Tasks will be run in order, with new
   * tasks added at the end of the queue and old tasks removed from the
   * front of the queue (FIFO). These tasks will eventually be grouped
   * into a Frame.
   * @private
   * @type {Task[]}
   */
  var tasks = [];

  /**
   * The queue of all frames. Each frame is a pairing of an array of tasks
   * and a callback which must be called when the frame is rendered.
   * @private
   * @type {Frame[]}
   */
  var frames = [];

  /**
   * Flushes all pending frames.
   * @private
   */
  function __flush_frames() {
    var rendered_frames = 0;

    // Draw all pending frames, if ready
    while (rendered_frames < frames.length) {
      var frame = frames[rendered_frames];
      if (!frame.isReady()) break;

      frame.flush();
      rendered_frames++;
    }

    // Remove rendered frames from array
    frames.splice(0, rendered_frames);
  }

  /**
   * An ordered list of tasks which must be executed atomically. Once
   * executed, an associated (and optional) callback will be called.
   *
   * @private
   * @constructor
   * @param {function} callback The function to call when this frame is
   *                            rendered.
   * @param {Task[]} tasks The set of tasks which must be executed to render
   *                       this frame.
   */
  function Frame(callback, tasks) {
    /**
     * Returns whether this frame is ready to be rendered. This function
     * returns true if and only if ALL underlying tasks are unblocked.
     *
     * @returns {Boolean} true if all underlying tasks are unblocked,
     *                    false otherwise.
     */
    this.isReady = function () {
      // Search for blocked tasks
      for (var i = 0; i < tasks.length; i++) {
        if (tasks[i].blocked) return false;
      }

      // If no blocked tasks, the frame is ready
      return true;
    };

    /**
     * Renders this frame, calling the associated callback, if any, after
     * the frame is complete. This function MUST only be called when no
     * blocked tasks exist. Calling this function with blocked tasks
     * will result in undefined behavior.
     */
    this.flush = function () {
      // Draw all pending tasks.
      for (var i = 0; i < tasks.length; i++) tasks[i].execute();

      // Call callback
      if (callback) callback();
    };
  }

  /**
   * A container for an task handler. Each operation which must be ordered
   * is associated with a Task that goes into a task queue. Tasks in this
   * queue are executed in order once their handlers are set, while Tasks
   * without handlers block themselves and any following Tasks from running.
   *
   * @constructor
   * @private
   * @param {function} taskHandler The function to call when this task
   *                               runs, if any.
   * @param {boolean} blocked Whether this task should start blocked.
   */
  function Task(taskHandler, blocked) {
    var task = this;

    /**
     * Whether this Task is blocked.
     *
     * @type {boolean}
     */
    this.blocked = blocked;

    /**
     * Unblocks this Task, allowing it to run.
     */
    this.unblock = function () {
      if (task.blocked) {
        task.blocked = false;
        __flush_frames();
      }
    };

    /**
     * Calls the handler associated with this task IMMEDIATELY. This
     * function does not track whether this task is marked as blocked.
     * Enforcing the blocked status of tasks is up to the caller.
     */
    this.execute = function () {
      if (taskHandler) taskHandler();
    };
  }

  /**
   * Schedules a task for future execution. The given handler will execute
   * immediately after all previous tasks upon frame flush, unless this
   * task is blocked. If any tasks is blocked, the entire frame will not
   * render (and no tasks within will execute) until all tasks are unblocked.
   *
   * @private
   * @param {function} handler The function to call when possible, if any.
   * @param {boolean} blocked Whether the task should start blocked.
   * @returns {Task} The Task created and added to the queue for future
   *                 running.
   */
  function scheduleTask(handler, blocked) {
    var task = new Task(handler, blocked);
    tasks.push(task);
    return task;
  }

  /**
   * Returns the element which contains the Guacamole display.
   *
   * @return {Element} The element containing the Guacamole display.
   */
  this.getElement = function () {
    return bounds;
  };

  /**
   * Returns the width of this display.
   *
   * @return {Number} The width of this display;
   */
  this.getWidth = function () {
    return displayWidth;
  };

  /**
   * Returns the height of this display.
   *
   * @return {Number} The height of this display;
   */
  this.getHeight = function () {
    return displayHeight;
  };

  /**
   * Returns the default layer of this display. Each Guacamole display always
   * has at least one layer. Other layers can optionally be created within
   * this layer, but the default layer cannot be removed and is the absolute
   * ancestor of all other layers.
   *
   * @return {Guacamole.Display.VisibleLayer} The default layer.
   */
  this.getDefaultLayer = function () {
    return default_layer;
  };

  /**
   * Returns the cursor layer of this display. Each Guacamole display contains
   * a layer for the image of the mouse cursor. This layer is a special case
   * and exists above all other layers, similar to the hardware mouse cursor.
   *
   * @return {Guacamole.Display.VisibleLayer} The cursor layer.
   */
  this.getCursorLayer = function () {
    return cursor;
  };

  /**
   * Creates a new layer. The new layer will be a direct child of the default
   * layer, but can be moved to be a child of any other layer. Layers returned
   * by this function are visible.
   *
   * @return {Guacamole.Display.VisibleLayer} The newly-created layer.
   */
  this.createLayer = function () {
    var layer = new Guacamole.Display.VisibleLayer(displayWidth, displayHeight);
    layer.move(default_layer, 0, 0, 0);
    return layer;
  };

  /**
   * Creates a new buffer. Buffers are invisible, off-screen surfaces. They
   * are implemented in the same manner as layers, but do not provide the
   * same nesting semantics.
   *
   * @return {Guacamole.Layer} The newly-created buffer.
   */
  this.createBuffer = function () {
    var buffer = new Guacamole.Layer(0, 0);
    buffer.autosize = 1;
    return buffer;
  };

  /**
   * Flush all pending draw tasks, if possible, as a new frame. If the entire
   * frame is not ready, the flush will wait until all required tasks are
   * unblocked.
   *
   * @param {function} callback The function to call when this frame is
   *                            flushed. This may happen immediately, or
   *                            later when blocked tasks become unblocked.
   */
  this.flush = function (callback) {
    // Add frame, reset tasks
    frames.push(new Frame(callback, tasks));
    tasks = [];

    // Attempt flush
    __flush_frames();
  };

  /**
     * Sets the hotspot and image of the mouse cursor displayed within the
     * Guacamole display.
     * 
     * @param {Number} hotspotX The X coordinate of the cursor hotspot.
     * @param {Number} hotspotY The Y coordinate of the cursor hotspot.
     * @param {Guacamole.Layer} layer The source layer containing the data which
     *                                should be used as the mouse cursor image.
     * @param {Number} srcx The X coordinate of the upper-left corner of the
     *                      rectangle within the source layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcy The Y coordinate of the upper-left corner of the
     *                      rectangle within the source layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcw The width of the rectangle within the source layer's
     *                      coordinate space to copy data from.
     * @param {Number} srch The height of the rectangle within the source
     *                      layer's coordinate space to copy data from.

     */
  this.setCursor = function (
    hotspotX,
    hotspotY,
    layer,
    srcx,
    srcy,
    srcw,
    srch
  ) {
    scheduleTask(function __display_set_cursor() {
      // Set hotspot
      guac_display.cursorHotspotX = hotspotX;
      guac_display.cursorHotspotY = hotspotY;

      // Reset cursor size
      cursor.resize(srcw, srch);

      // Draw cursor to cursor layer
      cursor.copy(layer, srcx, srcy, srcw, srch, 0, 0);
      guac_display.moveCursor(guac_display.cursorX, guac_display.cursorY);

      // Fire cursor change event
      if (guac_display.oncursor)
        guac_display.oncursor(cursor.toCanvas(), hotspotX, hotspotY);
    });
  };

  /**
   * Sets whether the software-rendered cursor is shown. This cursor differs
   * from the hardware cursor in that it is built into the Guacamole.Display,
   * and relies on its own Guacamole layer to render.
   *
   * @param {Boolean} [shown=true] Whether to show the software cursor.
   */
  this.showCursor = function (shown) {
    var element = cursor.getElement();
    var parent = element.parentNode;

    // Remove from DOM if hidden
    if (shown === false) {
      if (parent) parent.removeChild(element);
    }

    // Otherwise, ensure cursor is child of display
    else if (parent !== display) display.appendChild(element);
  };

  /**
   * Sets the location of the local cursor to the given coordinates. For the
   * sake of responsiveness, this function performs its action immediately.
   * Cursor motion is not maintained within atomic frames.
   *
   * @param {Number} x The X coordinate to move the cursor to.
   * @param {Number} y The Y coordinate to move the cursor to.
   */
  this.moveCursor = function (x, y) {
    // Move cursor layer
    cursor.translate(
      x - guac_display.cursorHotspotX,
      y - guac_display.cursorHotspotY
    );

    // Update stored position
    guac_display.cursorX = x;
    guac_display.cursorY = y;
  };

  /**
   * Changes the size of the given Layer to the given width and height.
   * Resizing is only attempted if the new size provided is actually different
   * from the current size.
   *
   * @param {Guacamole.Layer} layer The layer to resize.
   * @param {Number} width The new width.
   * @param {Number} height The new height.
   */
  this.resize = function (layer, width, height) {
    scheduleTask(function __display_resize() {
      layer.resize(width, height);

      // Resize display if default layer is resized
      if (layer === default_layer) {
        // Update (set) display size
        displayWidth = width;
        displayHeight = height;
        display.style.width = displayWidth + "px";
        display.style.height = displayHeight + "px";

        // Update bounds size
        bounds.style.width = displayWidth * displayScale + "px";
        bounds.style.height = displayHeight * displayScale + "px";

        // Notify of resize
        if (guac_display.onresize) guac_display.onresize(width, height);
      }
    });
  };

  /**
   * Draws the specified image at the given coordinates. The image specified
   * must already be loaded.
   *
   * @param {Guacamole.Layer} layer
   *     The layer to draw upon.
   *
   * @param {Number} x
   *     The destination X coordinate.
   *
   * @param {Number} y
   *     The destination Y coordinate.
   *
   * @param {CanvasImageSource} image
   *     The image to draw. Note that this not a URL.
   */
  this.drawImage = function (layer, x, y, image) {
    scheduleTask(function __display_drawImage() {
      layer.drawImage(x, y, image);
    });
  };

  /**
   * Draws the image contained within the specified Blob at the given
   * coordinates. The Blob specified must already be populated with image
   * data.
   *
   * @param {Guacamole.Layer} layer
   *     The layer to draw upon.
   *
   * @param {Number} x
   *     The destination X coordinate.
   *
   * @param {Number} y
   *     The destination Y coordinate.
   *
   * @param {Blob} blob
   *     The Blob containing the image data to draw.
   */
  this.drawBlob = function (layer, x, y, blob) {
    var task;

    // Prefer createImageBitmap() over blob URLs if available
    if (window.createImageBitmap) {
      var bitmap;

      // Draw image once loaded
      task = scheduleTask(function drawImageBitmap() {
        layer.drawImage(x, y, bitmap);
      }, true);

      // Load image from provided blob
      window.createImageBitmap(blob).then(function bitmapLoaded(decoded) {
        bitmap = decoded;
        task.unblock();
      });
    }

    // Use blob URLs and the Image object if createImageBitmap() is
    // unavailable
    else {
      // Create URL for blob
      var url = URL.createObjectURL(blob);

      // Draw and free blob URL when ready
      task = scheduleTask(function __display_drawBlob() {
        // Draw the image only if it loaded without errors
        if (image.width && image.height) layer.drawImage(x, y, image);

        // Blob URL no longer needed
        URL.revokeObjectURL(url);
      }, true);

      // Load image from URL
      var image = new Image();
      image.onload = task.unblock;
      image.onerror = task.unblock;
      image.src = url;
    }
  };

  /**
   * Draws the image within the given stream at the given coordinates. The
   * image will be loaded automatically, and this and any future operations
   * will wait for the image to finish loading. This function will
   * automatically choose an approriate method for reading and decoding the
   * given image stream, and should be preferred for received streams except
   * where manual decoding of the stream is unavoidable.
   *
   * @param {Guacamole.Layer} layer
   *     The layer to draw upon.
   *
   * @param {Number} x
   *     The destination X coordinate.
   *
   * @param {Number} y
   *     The destination Y coordinate.
   *
   * @param {Guacamole.InputStream} stream
   *     The stream along which image data will be received.
   *
   * @param {String} mimetype
   *     The mimetype of the image within the stream.
   */
  this.drawStream = function drawStream(layer, x, y, stream, mimetype) {
    // If createImageBitmap() is available, load the image as a blob so
    // that function can be used
    if (window.createImageBitmap) {
      var reader = new Guacamole.BlobReader(stream, mimetype);
      reader.onend = function drawImageBlob() {
        guac_display.drawBlob(layer, x, y, reader.getBlob());
      };
    }

    // Lacking createImageBitmap(), fall back to data URIs and the Image
    // object
    else {
      var reader = new Guacamole.DataURIReader(stream, mimetype);
      reader.onend = function drawImageDataURI() {
        guac_display.draw(layer, x, y, reader.getURI());
      };
    }
  };

  /**
   * Draws the image at the specified URL at the given coordinates. The image
   * will be loaded automatically, and this and any future operations will
   * wait for the image to finish loading.
   *
   * @param {Guacamole.Layer} layer The layer to draw upon.
   * @param {Number} x The destination X coordinate.
   * @param {Number} y The destination Y coordinate.
   * @param {String} url The URL of the image to draw.
   */
  this.draw = function (layer, x, y, url) {
    var task = scheduleTask(function __display_draw() {
      // Draw the image only if it loaded without errors
      if (image.width && image.height) layer.drawImage(x, y, image);
    }, true);

    var image = new Image();
    image.onload = task.unblock;
    image.onerror = task.unblock;
    image.src = url;
  };

  /**
   * Plays the video at the specified URL within this layer. The video
   * will be loaded automatically, and this and any future operations will
   * wait for the video to finish loading. Future operations will not be
   * executed until the video finishes playing.
   *
   * @param {Guacamole.Layer} layer The layer to draw upon.
   * @param {String} mimetype The mimetype of the video to play.
   * @param {Number} duration The duration of the video in milliseconds.
   * @param {String} url The URL of the video to play.
   */
  this.play = function (layer, mimetype, duration, url) {
    // Start loading the video
    var video = document.createElement("video");
    video.type = mimetype;
    video.src = url;

    // Start copying frames when playing
    video.addEventListener(
      "play",
      function () {
        function render_callback() {
          layer.drawImage(0, 0, video);
          if (!video.ended) window.setTimeout(render_callback, 20);
        }

        render_callback();
      },
      false
    );

    scheduleTask(video.play);
  };

  /**
   * Transfer a rectangle of image data from one Layer to this Layer using the
   * specified transfer function.
   *
   * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
   * @param {Number} srcx The X coordinate of the upper-left corner of the
   *                      rectangle within the source Layer's coordinate
   *                      space to copy data from.
   * @param {Number} srcy The Y coordinate of the upper-left corner of the
   *                      rectangle within the source Layer's coordinate
   *                      space to copy data from.
   * @param {Number} srcw The width of the rectangle within the source Layer's
   *                      coordinate space to copy data from.
   * @param {Number} srch The height of the rectangle within the source
   *                      Layer's coordinate space to copy data from.
   * @param {Guacamole.Layer} dstLayer The layer to draw upon.
   * @param {Number} x The destination X coordinate.
   * @param {Number} y The destination Y coordinate.
   * @param {Function} transferFunction The transfer function to use to
   *                                    transfer data from source to
   *                                    destination.
   */
  this.transfer = function (
    srcLayer,
    srcx,
    srcy,
    srcw,
    srch,
    dstLayer,
    x,
    y,
    transferFunction
  ) {
    scheduleTask(function __display_transfer() {
      dstLayer.transfer(
        srcLayer,
        srcx,
        srcy,
        srcw,
        srch,
        x,
        y,
        transferFunction
      );
    });
  };

  /**
   * Put a rectangle of image data from one Layer to this Layer directly
   * without performing any alpha blending. Simply copy the data.
   *
   * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
   * @param {Number} srcx The X coordinate of the upper-left corner of the
   *                      rectangle within the source Layer's coordinate
   *                      space to copy data from.
   * @param {Number} srcy The Y coordinate of the upper-left corner of the
   *                      rectangle within the source Layer's coordinate
   *                      space to copy data from.
   * @param {Number} srcw The width of the rectangle within the source Layer's
   *                      coordinate space to copy data from.
   * @param {Number} srch The height of the rectangle within the source
   *                      Layer's coordinate space to copy data from.
   * @param {Guacamole.Layer} dstLayer The layer to draw upon.
   * @param {Number} x The destination X coordinate.
   * @param {Number} y The destination Y coordinate.
   */
  this.put = function (srcLayer, srcx, srcy, srcw, srch, dstLayer, x, y) {
    scheduleTask(function __display_put() {
      dstLayer.put(srcLayer, srcx, srcy, srcw, srch, x, y);
    });
  };

  /**
   * Copy a rectangle of image data from one Layer to this Layer. This
   * operation will copy exactly the image data that will be drawn once all
   * operations of the source Layer that were pending at the time this
   * function was called are complete. This operation will not alter the
   * size of the source Layer even if its autosize property is set to true.
   *
   * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
   * @param {Number} srcx The X coordinate of the upper-left corner of the
   *                      rectangle within the source Layer's coordinate
   *                      space to copy data from.
   * @param {Number} srcy The Y coordinate of the upper-left corner of the
   *                      rectangle within the source Layer's coordinate
   *                      space to copy data from.
   * @param {Number} srcw The width of the rectangle within the source Layer's
   *                      coordinate space to copy data from.
   * @param {Number} srch The height of the rectangle within the source
   *                      Layer's coordinate space to copy data from.
   * @param {Guacamole.Layer} dstLayer The layer to draw upon.
   * @param {Number} x The destination X coordinate.
   * @param {Number} y The destination Y coordinate.
   */
  this.copy = function (srcLayer, srcx, srcy, srcw, srch, dstLayer, x, y) {
    scheduleTask(function __display_copy() {
      dstLayer.copy(srcLayer, srcx, srcy, srcw, srch, x, y);
    });
  };

  /**
   * Starts a new path at the specified point.
   *
   * @param {Guacamole.Layer} layer The layer to draw upon.
   * @param {Number} x The X coordinate of the point to draw.
   * @param {Number} y The Y coordinate of the point to draw.
   */
  this.moveTo = function (layer, x, y) {
    scheduleTask(function __display_moveTo() {
      layer.moveTo(x, y);
    });
  };

  /**
   * Add the specified line to the current path.
   *
   * @param {Guacamole.Layer} layer The layer to draw upon.
   * @param {Number} x The X coordinate of the endpoint of the line to draw.
   * @param {Number} y The Y coordinate of the endpoint of the line to draw.
   */
  this.lineTo = function (layer, x, y) {
    scheduleTask(function __display_lineTo() {
      layer.lineTo(x, y);
    });
  };

  /**
   * Add the specified arc to the current path.
   *
   * @param {Guacamole.Layer} layer The layer to draw upon.
   * @param {Number} x The X coordinate of the center of the circle which
   *                   will contain the arc.
   * @param {Number} y The Y coordinate of the center of the circle which
   *                   will contain the arc.
   * @param {Number} radius The radius of the circle.
   * @param {Number} startAngle The starting angle of the arc, in radians.
   * @param {Number} endAngle The ending angle of the arc, in radians.
   * @param {Boolean} negative Whether the arc should be drawn in order of
   *                           decreasing angle.
   */
  this.arc = function (layer, x, y, radius, startAngle, endAngle, negative) {
    scheduleTask(function __display_arc() {
      layer.arc(x, y, radius, startAngle, endAngle, negative);
    });
  };

  /**
   * Starts a new path at the specified point.
   *
   * @param {Guacamole.Layer} layer The layer to draw upon.
   * @param {Number} cp1x The X coordinate of the first control point.
   * @param {Number} cp1y The Y coordinate of the first control point.
   * @param {Number} cp2x The X coordinate of the second control point.
   * @param {Number} cp2y The Y coordinate of the second control point.
   * @param {Number} x The X coordinate of the endpoint of the curve.
   * @param {Number} y The Y coordinate of the endpoint of the curve.
   */
  this.curveTo = function (layer, cp1x, cp1y, cp2x, cp2y, x, y) {
    scheduleTask(function __display_curveTo() {
      layer.curveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    });
  };

  /**
   * Closes the current path by connecting the end point with the start
   * point (if any) with a straight line.
   *
   * @param {Guacamole.Layer} layer The layer to draw upon.
   */
  this.close = function (layer) {
    scheduleTask(function __display_close() {
      layer.close();
    });
  };

  /**
   * Add the specified rectangle to the current path.
   *
   * @param {Guacamole.Layer} layer The layer to draw upon.
   * @param {Number} x The X coordinate of the upper-left corner of the
   *                   rectangle to draw.
   * @param {Number} y The Y coordinate of the upper-left corner of the
   *                   rectangle to draw.
   * @param {Number} w The width of the rectangle to draw.
   * @param {Number} h The height of the rectangle to draw.
   */
  this.rect = function (layer, x, y, w, h) {
    scheduleTask(function __display_rect() {
      layer.rect(x, y, w, h);
    });
  };

  /**
   * Clip all future drawing operations by the current path. The current path
   * is implicitly closed. The current path can continue to be reused
   * for other operations (such as fillColor()) but a new path will be started
   * once a path drawing operation (path() or rect()) is used.
   *
   * @param {Guacamole.Layer} layer The layer to affect.
   */
  this.clip = function (layer) {
    scheduleTask(function __display_clip() {
      layer.clip();
    });
  };

  /**
   * Stroke the current path with the specified color. The current path
   * is implicitly closed. The current path can continue to be reused
   * for other operations (such as clip()) but a new path will be started
   * once a path drawing operation (path() or rect()) is used.
   *
   * @param {Guacamole.Layer} layer The layer to draw upon.
   * @param {String} cap The line cap style. Can be "round", "square",
   *                     or "butt".
   * @param {String} join The line join style. Can be "round", "bevel",
   *                      or "miter".
   * @param {Number} thickness The line thickness in pixels.
   * @param {Number} r The red component of the color to fill.
   * @param {Number} g The green component of the color to fill.
   * @param {Number} b The blue component of the color to fill.
   * @param {Number} a The alpha component of the color to fill.
   */
  this.strokeColor = function (layer, cap, join, thickness, r, g, b, a) {
    scheduleTask(function __display_strokeColor() {
      layer.strokeColor(cap, join, thickness, r, g, b, a);
    });
  };

  /**
   * Fills the current path with the specified color. The current path
   * is implicitly closed. The current path can continue to be reused
   * for other operations (such as clip()) but a new path will be started
   * once a path drawing operation (path() or rect()) is used.
   *
   * @param {Guacamole.Layer} layer The layer to draw upon.
   * @param {Number} r The red component of the color to fill.
   * @param {Number} g The green component of the color to fill.
   * @param {Number} b The blue component of the color to fill.
   * @param {Number} a The alpha component of the color to fill.
   */
  this.fillColor = function (layer, r, g, b, a) {
    scheduleTask(function __display_fillColor() {
      layer.fillColor(r, g, b, a);
    });
  };

  /**
   * Stroke the current path with the image within the specified layer. The
   * image data will be tiled infinitely within the stroke. The current path
   * is implicitly closed. The current path can continue to be reused
   * for other operations (such as clip()) but a new path will be started
   * once a path drawing operation (path() or rect()) is used.
   *
   * @param {Guacamole.Layer} layer The layer to draw upon.
   * @param {String} cap The line cap style. Can be "round", "square",
   *                     or "butt".
   * @param {String} join The line join style. Can be "round", "bevel",
   *                      or "miter".
   * @param {Number} thickness The line thickness in pixels.
   * @param {Guacamole.Layer} srcLayer The layer to use as a repeating pattern
   *                                   within the stroke.
   */
  this.strokeLayer = function (layer, cap, join, thickness, srcLayer) {
    scheduleTask(function __display_strokeLayer() {
      layer.strokeLayer(cap, join, thickness, srcLayer);
    });
  };

  /**
   * Fills the current path with the image within the specified layer. The
   * image data will be tiled infinitely within the stroke. The current path
   * is implicitly closed. The current path can continue to be reused
   * for other operations (such as clip()) but a new path will be started
   * once a path drawing operation (path() or rect()) is used.
   *
   * @param {Guacamole.Layer} layer The layer to draw upon.
   * @param {Guacamole.Layer} srcLayer The layer to use as a repeating pattern
   *                                   within the fill.
   */
  this.fillLayer = function (layer, srcLayer) {
    scheduleTask(function __display_fillLayer() {
      layer.fillLayer(srcLayer);
    });
  };

  /**
   * Push current layer state onto stack.
   *
   * @param {Guacamole.Layer} layer The layer to draw upon.
   */
  this.push = function (layer) {
    scheduleTask(function __display_push() {
      layer.push();
    });
  };

  /**
   * Pop layer state off stack.
   *
   * @param {Guacamole.Layer} layer The layer to draw upon.
   */
  this.pop = function (layer) {
    scheduleTask(function __display_pop() {
      layer.pop();
    });
  };

  /**
   * Reset the layer, clearing the stack, the current path, and any transform
   * matrix.
   *
   * @param {Guacamole.Layer} layer The layer to draw upon.
   */
  this.reset = function (layer) {
    scheduleTask(function __display_reset() {
      layer.reset();
    });
  };

  /**
   * Sets the given affine transform (defined with six values from the
   * transform's matrix).
   *
   * @param {Guacamole.Layer} layer The layer to modify.
   * @param {Number} a The first value in the affine transform's matrix.
   * @param {Number} b The second value in the affine transform's matrix.
   * @param {Number} c The third value in the affine transform's matrix.
   * @param {Number} d The fourth value in the affine transform's matrix.
   * @param {Number} e The fifth value in the affine transform's matrix.
   * @param {Number} f The sixth value in the affine transform's matrix.
   */
  this.setTransform = function (layer, a, b, c, d, e, f) {
    scheduleTask(function __display_setTransform() {
      layer.setTransform(a, b, c, d, e, f);
    });
  };

  /**
   * Applies the given affine transform (defined with six values from the
   * transform's matrix).
   *
   * @param {Guacamole.Layer} layer The layer to modify.
   * @param {Number} a The first value in the affine transform's matrix.
   * @param {Number} b The second value in the affine transform's matrix.
   * @param {Number} c The third value in the affine transform's matrix.
   * @param {Number} d The fourth value in the affine transform's matrix.
   * @param {Number} e The fifth value in the affine transform's matrix.
   * @param {Number} f The sixth value in the affine transform's matrix.
   */
  this.transform = function (layer, a, b, c, d, e, f) {
    scheduleTask(function __display_transform() {
      layer.transform(a, b, c, d, e, f);
    });
  };

  /**
   * Sets the channel mask for future operations on this Layer.
   *
   * The channel mask is a Guacamole-specific compositing operation identifier
   * with a single bit representing each of four channels (in order): source
   * image where destination transparent, source where destination opaque,
   * destination where source transparent, and destination where source
   * opaque.
   *
   * @param {Guacamole.Layer} layer The layer to modify.
   * @param {Number} mask The channel mask for future operations on this
   *                      Layer.
   */
  this.setChannelMask = function (layer, mask) {
    scheduleTask(function __display_setChannelMask() {
      layer.setChannelMask(mask);
    });
  };

  /**
   * Sets the miter limit for stroke operations using the miter join. This
   * limit is the maximum ratio of the size of the miter join to the stroke
   * width. If this ratio is exceeded, the miter will not be drawn for that
   * joint of the path.
   *
   * @param {Guacamole.Layer} layer The layer to modify.
   * @param {Number} limit The miter limit for stroke operations using the
   *                       miter join.
   */
  this.setMiterLimit = function (layer, limit) {
    scheduleTask(function __display_setMiterLimit() {
      layer.setMiterLimit(limit);
    });
  };

  /**
   * Removes the given layer container entirely, such that it is no longer
   * contained within its parent layer, if any.
   *
   * @param {Guacamole.Display.VisibleLayer} layer
   *     The layer being removed from its parent.
   */
  this.dispose = function dispose(layer) {
    scheduleTask(function disposeLayer() {
      layer.dispose();
    });
  };

  /**
   * Applies the given affine transform (defined with six values from the
   * transform's matrix) to the given layer.
   *
   * @param {Guacamole.Display.VisibleLayer} layer
   *     The layer being distorted.
   *
   * @param {Number} a
   *     The first value in the affine transform's matrix.
   *
   * @param {Number} b
   *     The second value in the affine transform's matrix.
   *
   * @param {Number} c
   *     The third value in the affine transform's matrix.
   *
   * @param {Number} d
   *     The fourth value in the affine transform's matrix.
   *
   * @param {Number} e
   *     The fifth value in the affine transform's matrix.
   *
   * @param {Number} f
   *     The sixth value in the affine transform's matrix.
   */
  this.distort = function distort(layer, a, b, c, d, e, f) {
    scheduleTask(function distortLayer() {
      layer.distort(a, b, c, d, e, f);
    });
  };

  /**
   * Moves the upper-left corner of the given layer to the given X and Y
   * coordinate, sets the Z stacking order, and reparents the layer
   * to the given parent layer.
   *
   * @param {Guacamole.Display.VisibleLayer} layer
   *     The layer being moved.
   *
   * @param {Guacamole.Display.VisibleLayer} parent
   *     The parent to set.
   *
   * @param {Number} x
   *     The X coordinate to move to.
   *
   * @param {Number} y
   *     The Y coordinate to move to.
   *
   * @param {Number} z
   *     The Z coordinate to move to.
   */
  this.move = function move(layer, parent, x, y, z) {
    scheduleTask(function moveLayer() {
      layer.move(parent, x, y, z);
    });
  };

  /**
   * Sets the opacity of the given layer to the given value, where 255 is
   * fully opaque and 0 is fully transparent.
   *
   * @param {Guacamole.Display.VisibleLayer} layer
   *     The layer whose opacity should be set.
   *
   * @param {Number} alpha
   *     The opacity to set.
   */
  this.shade = function shade(layer, alpha) {
    scheduleTask(function shadeLayer() {
      layer.shade(alpha);
    });
  };

  /**
   * Sets the scale of the client display element such that it renders at
   * a relatively smaller or larger size, without affecting the true
   * resolution of the display.
   *
   * @param {Number} scale The scale to resize to, where 1.0 is normal
   *                       size (1:1 scale).
   */
  this.scale = function (scale) {
    display.style.transform =
      display.style.WebkitTransform =
      display.style.MozTransform =
      display.style.OTransform =
      display.style.msTransform =
        "scale(" + scale + "," + scale + ")";

    displayScale = scale;

    // Update bounds size
    bounds.style.width = displayWidth * displayScale + "px";
    bounds.style.height = displayHeight * displayScale + "px";
  };

  /**
   * Returns the scale of the display.
   *
   * @return {Number} The scale of the display.
   */
  this.getScale = function () {
    return displayScale;
  };

  /**
   * Returns a canvas element containing the entire display, with all child
   * layers composited within.
   *
   * @return {HTMLCanvasElement} A new canvas element containing a copy of
   *                             the display.
   */
  this.flatten = function () {
    // Get destination canvas
    var canvas = document.createElement("canvas");
    canvas.width = default_layer.width;
    canvas.height = default_layer.height;

    var context = canvas.getContext("2d");

    // Returns sorted array of children
    function get_children(layer) {
      // Build array of children
      var children = [];
      for (var index in layer.children) children.push(layer.children[index]);

      // Sort
      children.sort(function children_comparator(a, b) {
        // Compare based on Z order
        var diff = a.z - b.z;
        if (diff !== 0) return diff;

        // If Z order identical, use document order
        var a_element = a.getElement();
        var b_element = b.getElement();
        var position = b_element.compareDocumentPosition(a_element);

        if (position & Node.DOCUMENT_POSITION_PRECEDING) return -1;
        if (position & Node.DOCUMENT_POSITION_FOLLOWING) return 1;

        // Otherwise, assume same
        return 0;
      });

      // Done
      return children;
    }

    // Draws the contents of the given layer at the given coordinates
    function draw_layer(layer, x, y) {
      // Draw layer
      if (layer.width > 0 && layer.height > 0) {
        // Save and update alpha
        var initial_alpha = context.globalAlpha;
        context.globalAlpha *= layer.alpha / 255.0;

        // Copy data
        context.drawImage(layer.getCanvas(), x, y);

        // Draw all children
        var children = get_children(layer);
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          draw_layer(child, x + child.x, y + child.y);
        }

        // Restore alpha
        context.globalAlpha = initial_alpha;
      }
    }

    // Draw default layer and all children
    draw_layer(default_layer, 0, 0);

    // Return new canvas copy
    return canvas;
  };
};

/**
 * Simple container for Guacamole.Layer, allowing layers to be easily
 * repositioned and nested. This allows certain operations to be accelerated
 * through DOM manipulation, rather than raster operations.
 *
 * @constructor
 * @augments Guacamole.Layer
 * @param {Number} width The width of the Layer, in pixels. The canvas element
 *                       backing this Layer will be given this width.
 * @param {Number} height The height of the Layer, in pixels. The canvas element
 *                        backing this Layer will be given this height.
 */
Guacamole.Display.VisibleLayer = function (width, height) {
  Guacamole.Layer.apply(this, [width, height]);

  /**
   * Reference to this layer.
   * @private
   */
  var layer = this;

  /**
   * Identifier which uniquely identifies this layer. This is COMPLETELY
   * UNRELATED to the index of the underlying layer, which is specific
   * to the Guacamole protocol, and not relevant at this level.
   *
   * @private
   * @type {Number}
   */
  this.__unique_id = Guacamole.Display.VisibleLayer.__next_id++;

  /**
   * The opacity of the layer container, where 255 is fully opaque and 0 is
   * fully transparent.
   */
  this.alpha = 0xff;

  /**
   * X coordinate of the upper-left corner of this layer container within
   * its parent, in pixels.
   * @type {Number}
   */
  this.x = 0;

  /**
   * Y coordinate of the upper-left corner of this layer container within
   * its parent, in pixels.
   * @type {Number}
   */
  this.y = 0;

  /**
   * Z stacking order of this layer relative to other sibling layers.
   * @type {Number}
   */
  this.z = 0;

  /**
   * The affine transformation applied to this layer container. Each element
   * corresponds to a value from the transformation matrix, with the first
   * three values being the first row, and the last three values being the
   * second row. There are six values total.
   *
   * @type {Number[]}
   */
  this.matrix = [1, 0, 0, 1, 0, 0];

  /**
   * The parent layer container of this layer, if any.
   * @type {Guacamole.Display.VisibleLayer}
   */
  this.parent = null;

  /**
   * Set of all children of this layer, indexed by layer index. This object
   * will have one property per child.
   */
  this.children = {};

  // Set layer position
  var canvas = layer.getCanvas();
  canvas.style.position = "absolute";
  canvas.style.left = "0px";
  canvas.style.top = "0px";

  // Create div with given size
  var div = document.createElement("div");
  div.appendChild(canvas);
  div.style.width = width + "px";
  div.style.height = height + "px";
  div.style.position = "absolute";
  div.style.left = "0px";
  div.style.top = "0px";
  div.style.overflow = "hidden";

  /**
   * Superclass resize() function.
   * @private
   */
  var __super_resize = this.resize;

  this.resize = function (width, height) {
    // Resize containing div
    div.style.width = width + "px";
    div.style.height = height + "px";

    __super_resize(width, height);
  };

  /**
   * Returns the element containing the canvas and any other elements
   * associated with this layer.
   * @returns {Element} The element containing this layer's canvas.
   */
  this.getElement = function () {
    return div;
  };

  /**
   * The translation component of this layer's transform.
   * @private
   */
  var translate = "translate(0px, 0px)"; // (0, 0)

  /**
   * The arbitrary matrix component of this layer's transform.
   * @private
   */
  var matrix = "matrix(1, 0, 0, 1, 0, 0)"; // Identity

  /**
   * Moves the upper-left corner of this layer to the given X and Y
   * coordinate.
   *
   * @param {Number} x The X coordinate to move to.
   * @param {Number} y The Y coordinate to move to.
   */
  this.translate = function (x, y) {
    layer.x = x;
    layer.y = y;

    // Generate translation
    translate = "translate(" + x + "px," + y + "px)";

    // Set layer transform
    div.style.transform =
      div.style.WebkitTransform =
      div.style.MozTransform =
      div.style.OTransform =
      div.style.msTransform =
        translate + " " + matrix;
  };

  /**
   * Moves the upper-left corner of this VisibleLayer to the given X and Y
   * coordinate, sets the Z stacking order, and reparents this VisibleLayer
   * to the given VisibleLayer.
   *
   * @param {Guacamole.Display.VisibleLayer} parent The parent to set.
   * @param {Number} x The X coordinate to move to.
   * @param {Number} y The Y coordinate to move to.
   * @param {Number} z The Z coordinate to move to.
   */
  this.move = function (parent, x, y, z) {
    // Set parent if necessary
    if (layer.parent !== parent) {
      // Maintain relationship
      if (layer.parent) delete layer.parent.children[layer.__unique_id];
      layer.parent = parent;
      parent.children[layer.__unique_id] = layer;

      // Reparent element
      var parent_element = parent.getElement();
      parent_element.appendChild(div);
    }

    // Set location
    layer.translate(x, y);
    layer.z = z;
    div.style.zIndex = z;
  };

  /**
   * Sets the opacity of this layer to the given value, where 255 is fully
   * opaque and 0 is fully transparent.
   *
   * @param {Number} a The opacity to set.
   */
  this.shade = function (a) {
    layer.alpha = a;
    div.style.opacity = a / 255.0;
  };

  /**
   * Removes this layer container entirely, such that it is no longer
   * contained within its parent layer, if any.
   */
  this.dispose = function () {
    // Remove from parent container
    if (layer.parent) {
      delete layer.parent.children[layer.__unique_id];
      layer.parent = null;
    }

    // Remove from parent element
    if (div.parentNode) div.parentNode.removeChild(div);
  };

  /**
   * Applies the given affine transform (defined with six values from the
   * transform's matrix).
   *
   * @param {Number} a The first value in the affine transform's matrix.
   * @param {Number} b The second value in the affine transform's matrix.
   * @param {Number} c The third value in the affine transform's matrix.
   * @param {Number} d The fourth value in the affine transform's matrix.
   * @param {Number} e The fifth value in the affine transform's matrix.
   * @param {Number} f The sixth value in the affine transform's matrix.
   */
  this.distort = function (a, b, c, d, e, f) {
    // Store matrix
    layer.matrix = [a, b, c, d, e, f];

    // Generate matrix transformation
    matrix =
      /* a c e
       * b d f
       * 0 0 1
       */

      "matrix(" + a + "," + b + "," + c + "," + d + "," + e + "," + f + ")";

    // Set layer transform
    div.style.transform =
      div.style.WebkitTransform =
      div.style.MozTransform =
      div.style.OTransform =
      div.style.msTransform =
        translate + " " + matrix;
  };
};

/**
 * The next identifier to be assigned to the layer container. This identifier
 * uniquely identifies each VisibleLayer, but is unrelated to the index of
 * the layer, which exists at the protocol/client level only.
 *
 * @private
 * @type {Number}
 */
Guacamole.Display.VisibleLayer.__next_id = 0;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A hidden input field which attempts to keep itself focused at all times,
 * except when another input field has been intentionally focused, whether
 * programatically or by the user. The actual underlying input field, returned
 * by getElement(), may be used as a reliable source of keyboard-related events,
 * particularly composition and input events which may require a focused input
 * field to be dispatched at all.
 *
 * @constructor
 */
Guacamole.InputSink = function InputSink() {
  /**
   * Reference to this instance of Guacamole.InputSink.
   *
   * @private
   * @type {Guacamole.InputSink}
   */
  var sink = this;

  /**
   * The underlying input field, styled to be invisible.
   *
   * @private
   * @type {Element}
   */
  var field = document.createElement("textarea");
  field.style.position = "fixed";
  field.style.outline = "none";
  field.style.border = "none";
  field.style.margin = "0";
  field.style.padding = "0";
  field.style.height = "0";
  field.style.width = "0";
  field.style.left = "0";
  field.style.bottom = "0";
  field.style.resize = "none";
  field.style.background = "transparent";
  field.style.color = "transparent";

  // Keep field clear when modified via normal keypresses
  field.addEventListener(
    "keypress",
    function clearKeypress(e) {
      field.value = "";
    },
    false
  );

  // Keep field clear when modofied via composition events
  field.addEventListener(
    "compositionend",
    function clearCompletedComposition(e) {
      if (e.data) field.value = "";
    },
    false
  );

  // Keep field clear when modofied via input events
  field.addEventListener(
    "input",
    function clearCompletedInput(e) {
      if (e.data && !e.isComposing) field.value = "";
    },
    false
  );

  // Whenever focus is gained, automatically click to ensure cursor is
  // actually placed within the field (the field may simply be highlighted or
  // outlined otherwise)
  field.addEventListener(
    "focus",
    function focusReceived() {
      window.setTimeout(function deferRefocus() {
        field.click();
        field.select();
      }, 0);
    },
    true
  );

  /**
   * Attempts to focus the underlying input field. The focus attempt occurs
   * asynchronously, and may silently fail depending on browser restrictions.
   */
  this.focus = function focus() {
    window.setTimeout(function deferRefocus() {
      field.focus(); // Focus must be deferred to work reliably across browsers
    }, 0);
  };

  /**
   * Returns the underlying input field. This input field MUST be manually
   * added to the DOM for the Guacamole.InputSink to have any effect.
   *
   * @returns {Element}
   */
  this.getElement = function getElement() {
    return field;
  };

  // Automatically refocus input sink if part of DOM
  document.addEventListener(
    "keydown",
    function refocusSink(e) {
      // Do not refocus if focus is on an input field
      var focused = document.activeElement;
      if (focused && focused !== document.body) {
        // Only consider focused input fields which are actually visible
        var rect = focused.getBoundingClientRect();
        if (rect.left + rect.width > 0 && rect.top + rect.height > 0) return;
      }

      // Refocus input sink instead of handling click
      sink.focus();
    },
    true
  );
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * An input stream abstraction used by the Guacamole client to facilitate
 * transfer of files or other binary data.
 *
 * @constructor
 * @param {Guacamole.Client} client The client owning this stream.
 * @param {Number} index The index of this stream.
 */
Guacamole.InputStream = function (client, index) {
  /**
   * Reference to this stream.
   * @private
   */
  var guac_stream = this;

  /**
   * The index of this stream.
   * @type {Number}
   */
  this.index = index;

  /**
   * Called when a blob of data is received.
   *
   * @event
   * @param {String} data The received base64 data.
   */
  this.onblob = null;

  /**
   * Called when this stream is closed.
   *
   * @event
   */
  this.onend = null;

  /**
   * Acknowledges the receipt of a blob.
   *
   * @param {String} message A human-readable message describing the error
   *                         or status.
   * @param {Number} code The error code, if any, or 0 for success.
   */
  this.sendAck = function (message, code) {
    client.sendAck(guac_stream.index, message, code);
  };
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Integer pool which returns consistently increasing integers while integers
 * are in use, and previously-used integers when possible.
 * @constructor
 */
Guacamole.IntegerPool = function () {
  /**
   * Reference to this integer pool.
   *
   * @private
   */
  var guac_pool = this;

  /**
   * Array of available integers.
   *
   * @private
   * @type {Number[]}
   */
  var pool = [];

  /**
   * The next integer to return if no more integers remain.
   * @type {Number}
   */
  this.next_int = 0;

  /**
   * Returns the next available integer in the pool. If possible, a previously
   * used integer will be returned.
   *
   * @return {Number} The next available integer.
   */
  this.next = function () {
    // If free'd integers exist, return one of those
    if (pool.length > 0) return pool.shift();

    // Otherwise, return a new integer
    return guac_pool.next_int++;
  };

  /**
   * Frees the given integer, allowing it to be reused.
   *
   * @param {Number} integer The integer to free.
   */
  this.free = function (integer) {
    pool.push(integer);
  };
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A reader which automatically handles the given input stream, assembling all
 * received blobs into a JavaScript object by appending them to each other, in
 * order, and decoding the result as JSON. Note that this object will overwrite
 * any installed event handlers on the given Guacamole.InputStream.
 *
 * @constructor
 * @param {Guacamole.InputStream} stream
 *     The stream that JSON will be read from.
 */
Guacamole.JSONReader = function guacamoleJSONReader(stream) {
  /**
   * Reference to this Guacamole.JSONReader.
   *
   * @private
   * @type {Guacamole.JSONReader}
   */
  var guacReader = this;

  /**
   * Wrapped Guacamole.StringReader.
   *
   * @private
   * @type {Guacamole.StringReader}
   */
  var stringReader = new Guacamole.StringReader(stream);

  /**
   * All JSON read thus far.
   *
   * @private
   * @type {String}
   */
  var json = "";

  /**
   * Returns the current length of this Guacamole.JSONReader, in characters.
   *
   * @return {Number}
   *     The current length of this Guacamole.JSONReader.
   */
  this.getLength = function getLength() {
    return json.length;
  };

  /**
   * Returns the contents of this Guacamole.JSONReader as a JavaScript
   * object.
   *
   * @return {Object}
   *     The contents of this Guacamole.JSONReader, as parsed from the JSON
   *     contents of the input stream.
   */
  this.getJSON = function getJSON() {
    return JSON.parse(json);
  };

  // Append all received text
  stringReader.ontext = function ontext(text) {
    // Append received text
    json += text;

    // Call handler, if present
    if (guacReader.onprogress) guacReader.onprogress(text.length);
  };

  // Simply call onend when end received
  stringReader.onend = function onend() {
    if (guacReader.onend) guacReader.onend();
  };

  /**
   * Fired once for every blob of data received.
   *
   * @event
   * @param {Number} length
   *     The number of characters received.
   */
  this.onprogress = null;

  /**
   * Fired once this stream is finished and no further data will be written.
   *
   * @event
   */
  this.onend = null;
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Provides cross-browser and cross-keyboard keyboard for a specific element.
 * Browser and keyboard layout variation is abstracted away, providing events
 * which represent keys as their corresponding X11 keysym.
 *
 * @constructor
 * @param {Element|Document} [element]
 *    The Element to use to provide keyboard events. If omitted, at least one
 *    Element must be manually provided through the listenTo() function for
 *    the Guacamole.Keyboard instance to have any effect.
 */
Guacamole.Keyboard = function Keyboard(element) {
  /**
   * Reference to this Guacamole.Keyboard.
   * @private
   */
  var guac_keyboard = this;

  /**
   * An integer value which uniquely identifies this Guacamole.Keyboard
   * instance with respect to other Guacamole.Keyboard instances.
   *
   * @private
   * @type {Number}
   */
  var guacKeyboardID = Guacamole.Keyboard._nextID++;

  /**
   * The name of the property which is added to event objects via markEvent()
   * to note that they have already been handled by this Guacamole.Keyboard.
   *
   * @private
   * @constant
   * @type {String}
   */
  var EVENT_MARKER = "_GUAC_KEYBOARD_HANDLED_BY_" + guacKeyboardID;

  /**
   * Fired whenever the user presses a key with the element associated
   * with this Guacamole.Keyboard in focus.
   *
   * @event
   * @param {Number} keysym The keysym of the key being pressed.
   * @return {Boolean} true if the key event should be allowed through to the
   *                   browser, false otherwise.
   */
  this.onkeydown = null;

  /**
   * Fired whenever the user releases a key with the element associated
   * with this Guacamole.Keyboard in focus.
   *
   * @event
   * @param {Number} keysym The keysym of the key being released.
   */
  this.onkeyup = null;

  /**
   * Set of known platform-specific or browser-specific quirks which must be
   * accounted for to properly interpret key events, even if the only way to
   * reliably detect that quirk is to platform/browser-sniff.
   *
   * @private
   * @type {Object.<String, Boolean>}
   */
  var quirks = {
    /**
     * Whether keyup events are universally unreliable.
     *
     * @type {Boolean}
     */
    keyupUnreliable: false,

    /**
     * Whether the Alt key is actually a modifier for typable keys and is
     * thus never used for keyboard shortcuts.
     *
     * @type {Boolean}
     */
    altIsTypableOnly: false,

    /**
     * Whether we can rely on receiving a keyup event for the Caps Lock
     * key.
     *
     * @type {Boolean}
     */
    capsLockKeyupUnreliable: false,
  };

  // Set quirk flags depending on platform/browser, if such information is
  // available
  if (navigator && navigator.platform) {
    // All keyup events are unreliable on iOS (sadly)
    if (navigator.platform.match(/ipad|iphone|ipod/i))
      quirks.keyupUnreliable = true;
    // The Alt key on Mac is never used for keyboard shortcuts, and the
    // Caps Lock key never dispatches keyup events
    else if (navigator.platform.match(/^mac/i)) {
      quirks.altIsTypableOnly = true;
      quirks.capsLockKeyupUnreliable = true;
    }
  }

  /**
   * A key event having a corresponding timestamp. This event is non-specific.
   * Its subclasses should be used instead when recording specific key
   * events.
   *
   * @private
   * @constructor
   */
  var KeyEvent = function () {
    /**
     * Reference to this key event.
     */
    var key_event = this;

    /**
     * An arbitrary timestamp in milliseconds, indicating this event's
     * position in time relative to other events.
     *
     * @type {Number}
     */
    this.timestamp = new Date().getTime();

    /**
     * Whether the default action of this key event should be prevented.
     *
     * @type {Boolean}
     */
    this.defaultPrevented = false;

    /**
     * The keysym of the key associated with this key event, as determined
     * by a best-effort guess using available event properties and keyboard
     * state.
     *
     * @type {Number}
     */
    this.keysym = null;

    /**
     * Whether the keysym value of this key event is known to be reliable.
     * If false, the keysym may still be valid, but it's only a best guess,
     * and future key events may be a better source of information.
     *
     * @type {Boolean}
     */
    this.reliable = false;

    /**
     * Returns the number of milliseconds elapsed since this event was
     * received.
     *
     * @return {Number} The number of milliseconds elapsed since this
     *                  event was received.
     */
    this.getAge = function () {
      return new Date().getTime() - key_event.timestamp;
    };
  };

  /**
   * Information related to the pressing of a key, which need not be a key
   * associated with a printable character. The presence or absence of any
   * information within this object is browser-dependent.
   *
   * @private
   * @constructor
   * @augments Guacamole.Keyboard.KeyEvent
   * @param {Number} keyCode The JavaScript key code of the key pressed.
   * @param {String} keyIdentifier The legacy DOM3 "keyIdentifier" of the key
   *                               pressed, as defined at:
   *                               http://www.w3.org/TR/2009/WD-DOM-Level-3-Events-20090908/#events-Events-KeyboardEvent
   * @param {String} key The standard name of the key pressed, as defined at:
   *                     http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
   * @param {Number} location The location on the keyboard corresponding to
   *                          the key pressed, as defined at:
   *                          http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
   */
  var KeydownEvent = function (keyCode, keyIdentifier, key, location) {
    // We extend KeyEvent
    KeyEvent.apply(this);

    /**
     * The JavaScript key code of the key pressed.
     *
     * @type {Number}
     */
    this.keyCode = keyCode;

    /**
     * The legacy DOM3 "keyIdentifier" of the key pressed, as defined at:
     * http://www.w3.org/TR/2009/WD-DOM-Level-3-Events-20090908/#events-Events-KeyboardEvent
     *
     * @type {String}
     */
    this.keyIdentifier = keyIdentifier;

    /**
     * The standard name of the key pressed, as defined at:
     * http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
     *
     * @type {String}
     */
    this.key = key;

    /**
     * The location on the keyboard corresponding to the key pressed, as
     * defined at:
     * http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
     *
     * @type {Number}
     */
    this.location = location;

    // If key is known from keyCode or DOM3 alone, use that
    this.keysym =
      keysym_from_key_identifier(key, location) ||
      keysym_from_keycode(keyCode, location);

    /**
     * Whether the keyup following this keydown event is known to be
     * reliable. If false, we cannot rely on the keyup event to occur.
     *
     * @type {Boolean}
     */
    this.keyupReliable = !quirks.keyupUnreliable;

    // DOM3 and keyCode are reliable sources if the corresponding key is
    // not a printable key
    if (this.keysym && !isPrintable(this.keysym)) this.reliable = true;

    // Use legacy keyIdentifier as a last resort, if it looks sane
    if (!this.keysym && key_identifier_sane(keyCode, keyIdentifier))
      this.keysym = keysym_from_key_identifier(
        keyIdentifier,
        location,
        guac_keyboard.modifiers.shift
      );

    // If a key is pressed while meta is held down, the keyup will
    // never be sent in Chrome (bug #108404)
    if (
      guac_keyboard.modifiers.meta &&
      this.keysym !== 0xffe7 &&
      this.keysym !== 0xffe8
    )
      this.keyupReliable = false;
    // We cannot rely on receiving keyup for Caps Lock on certain platforms
    else if (this.keysym === 0xffe5 && quirks.capsLockKeyupUnreliable)
      this.keyupReliable = false;

    // Determine whether default action for Alt+combinations must be prevented
    var prevent_alt = !guac_keyboard.modifiers.ctrl && !quirks.altIsTypableOnly;

    // Determine whether default action for Ctrl+combinations must be prevented
    var prevent_ctrl = !guac_keyboard.modifiers.alt;

    // We must rely on the (potentially buggy) keyIdentifier if preventing
    // the default action is important
    if (
      (prevent_ctrl && guac_keyboard.modifiers.ctrl) ||
      (prevent_alt && guac_keyboard.modifiers.alt) ||
      guac_keyboard.modifiers.meta ||
      guac_keyboard.modifiers.hyper
    )
      this.reliable = true;

    // Record most recently known keysym by associated key code
    recentKeysym[keyCode] = this.keysym;
  };

  KeydownEvent.prototype = new KeyEvent();

  /**
   * Information related to the pressing of a key, which MUST be
   * associated with a printable character. The presence or absence of any
   * information within this object is browser-dependent.
   *
   * @private
   * @constructor
   * @augments Guacamole.Keyboard.KeyEvent
   * @param {Number} charCode The Unicode codepoint of the character that
   *                          would be typed by the key pressed.
   */
  var KeypressEvent = function (charCode) {
    // We extend KeyEvent
    KeyEvent.apply(this);

    /**
     * The Unicode codepoint of the character that would be typed by the
     * key pressed.
     *
     * @type {Number}
     */
    this.charCode = charCode;

    // Pull keysym from char code
    this.keysym = keysym_from_charcode(charCode);

    // Keypress is always reliable
    this.reliable = true;
  };

  KeypressEvent.prototype = new KeyEvent();

  /**
   * Information related to the pressing of a key, which need not be a key
   * associated with a printable character. The presence or absence of any
   * information within this object is browser-dependent.
   *
   * @private
   * @constructor
   * @augments Guacamole.Keyboard.KeyEvent
   * @param {Number} keyCode The JavaScript key code of the key released.
   * @param {String} keyIdentifier The legacy DOM3 "keyIdentifier" of the key
   *                               released, as defined at:
   *                               http://www.w3.org/TR/2009/WD-DOM-Level-3-Events-20090908/#events-Events-KeyboardEvent
   * @param {String} key The standard name of the key released, as defined at:
   *                     http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
   * @param {Number} location The location on the keyboard corresponding to
   *                          the key released, as defined at:
   *                          http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
   */
  var KeyupEvent = function (keyCode, keyIdentifier, key, location) {
    // We extend KeyEvent
    KeyEvent.apply(this);

    /**
     * The JavaScript key code of the key released.
     *
     * @type {Number}
     */
    this.keyCode = keyCode;

    /**
     * The legacy DOM3 "keyIdentifier" of the key released, as defined at:
     * http://www.w3.org/TR/2009/WD-DOM-Level-3-Events-20090908/#events-Events-KeyboardEvent
     *
     * @type {String}
     */
    this.keyIdentifier = keyIdentifier;

    /**
     * The standard name of the key released, as defined at:
     * http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
     *
     * @type {String}
     */
    this.key = key;

    /**
     * The location on the keyboard corresponding to the key released, as
     * defined at:
     * http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
     *
     * @type {Number}
     */
    this.location = location;

    // If key is known from keyCode or DOM3 alone, use that
    this.keysym =
      keysym_from_keycode(keyCode, location) ||
      keysym_from_key_identifier(key, location); // keyCode is still more reliable for keyup when dead keys are in use

    // Fall back to the most recently pressed keysym associated with the
    // keyCode if the inferred key doesn't seem to actually be pressed
    if (!guac_keyboard.pressed[this.keysym])
      this.keysym = recentKeysym[keyCode] || this.keysym;

    // Keyup is as reliable as it will ever be
    this.reliable = true;
  };

  KeyupEvent.prototype = new KeyEvent();

  /**
   * An array of recorded events, which can be instances of the private
   * KeydownEvent, KeypressEvent, and KeyupEvent classes.
   *
   * @private
   * @type {KeyEvent[]}
   */
  var eventLog = [];

  /**
   * Map of known JavaScript keycodes which do not map to typable characters
   * to their X11 keysym equivalents.
   * @private
   */
  var keycodeKeysyms = {
    8: [0xff08], // backspace
    9: [0xff09], // tab
    12: [0xff0b, 0xff0b, 0xff0b, 0xffb5], // clear       / KP 5
    13: [0xff0d], // enter
    16: [0xffe1, 0xffe1, 0xffe2], // shift
    17: [0xffe3, 0xffe3, 0xffe4], // ctrl
    18: [0xffe9, 0xffe9, 0xfe03], // alt
    19: [0xff13], // pause/break
    20: [0xffe5], // caps lock
    27: [0xff1b], // escape
    32: [0x0020], // space
    33: [0xff55, 0xff55, 0xff55, 0xffb9], // page up     / KP 9
    34: [0xff56, 0xff56, 0xff56, 0xffb3], // page down   / KP 3
    35: [0xff57, 0xff57, 0xff57, 0xffb1], // end         / KP 1
    36: [0xff50, 0xff50, 0xff50, 0xffb7], // home        / KP 7
    37: [0xff51, 0xff51, 0xff51, 0xffb4], // left arrow  / KP 4
    38: [0xff52, 0xff52, 0xff52, 0xffb8], // up arrow    / KP 8
    39: [0xff53, 0xff53, 0xff53, 0xffb6], // right arrow / KP 6
    40: [0xff54, 0xff54, 0xff54, 0xffb2], // down arrow  / KP 2
    45: [0xff63, 0xff63, 0xff63, 0xffb0], // insert      / KP 0
    46: [0xffff, 0xffff, 0xffff, 0xffae], // delete      / KP decimal
    91: [0xffeb], // left window key (hyper_l)
    92: [0xff67], // right window key (menu key?)
    93: null, // select key
    96: [0xffb0], // KP 0
    97: [0xffb1], // KP 1
    98: [0xffb2], // KP 2
    99: [0xffb3], // KP 3
    100: [0xffb4], // KP 4
    101: [0xffb5], // KP 5
    102: [0xffb6], // KP 6
    103: [0xffb7], // KP 7
    104: [0xffb8], // KP 8
    105: [0xffb9], // KP 9
    106: [0xffaa], // KP multiply
    107: [0xffab], // KP add
    109: [0xffad], // KP subtract
    110: [0xffae], // KP decimal
    111: [0xffaf], // KP divide
    112: [0xffbe], // f1
    113: [0xffbf], // f2
    114: [0xffc0], // f3
    115: [0xffc1], // f4
    116: [0xffc2], // f5
    117: [0xffc3], // f6
    118: [0xffc4], // f7
    119: [0xffc5], // f8
    120: [0xffc6], // f9
    121: [0xffc7], // f10
    122: [0xffc8], // f11
    123: [0xffc9], // f12
    144: [0xff7f], // num lock
    145: [0xff14], // scroll lock
    225: [0xfe03], // altgraph (iso_level3_shift)
  };

  /**
   * Map of known JavaScript keyidentifiers which do not map to typable
   * characters to their unshifted X11 keysym equivalents.
   * @private
   */
  var keyidentifier_keysym = {
    Again: [0xff66],
    AllCandidates: [0xff3d],
    Alphanumeric: [0xff30],
    Alt: [0xffe9, 0xffe9, 0xfe03],
    Attn: [0xfd0e],
    AltGraph: [0xfe03],
    ArrowDown: [0xff54],
    ArrowLeft: [0xff51],
    ArrowRight: [0xff53],
    ArrowUp: [0xff52],
    Backspace: [0xff08],
    CapsLock: [0xffe5],
    Cancel: [0xff69],
    Clear: [0xff0b],
    Convert: [0xff21],
    Copy: [0xfd15],
    Crsel: [0xfd1c],
    CrSel: [0xfd1c],
    CodeInput: [0xff37],
    Compose: [0xff20],
    Control: [0xffe3, 0xffe3, 0xffe4],
    ContextMenu: [0xff67],
    Delete: [0xffff],
    Down: [0xff54],
    End: [0xff57],
    Enter: [0xff0d],
    EraseEof: [0xfd06],
    Escape: [0xff1b],
    Execute: [0xff62],
    Exsel: [0xfd1d],
    ExSel: [0xfd1d],
    F1: [0xffbe],
    F2: [0xffbf],
    F3: [0xffc0],
    F4: [0xffc1],
    F5: [0xffc2],
    F6: [0xffc3],
    F7: [0xffc4],
    F8: [0xffc5],
    F9: [0xffc6],
    F10: [0xffc7],
    F11: [0xffc8],
    F12: [0xffc9],
    F13: [0xffca],
    F14: [0xffcb],
    F15: [0xffcc],
    F16: [0xffcd],
    F17: [0xffce],
    F18: [0xffcf],
    F19: [0xffd0],
    F20: [0xffd1],
    F21: [0xffd2],
    F22: [0xffd3],
    F23: [0xffd4],
    F24: [0xffd5],
    Find: [0xff68],
    GroupFirst: [0xfe0c],
    GroupLast: [0xfe0e],
    GroupNext: [0xfe08],
    GroupPrevious: [0xfe0a],
    FullWidth: null,
    HalfWidth: null,
    HangulMode: [0xff31],
    Hankaku: [0xff29],
    HanjaMode: [0xff34],
    Help: [0xff6a],
    Hiragana: [0xff25],
    HiraganaKatakana: [0xff27],
    Home: [0xff50],
    Hyper: [0xffed, 0xffed, 0xffee],
    Insert: [0xff63],
    JapaneseHiragana: [0xff25],
    JapaneseKatakana: [0xff26],
    JapaneseRomaji: [0xff24],
    JunjaMode: [0xff38],
    KanaMode: [0xff2d],
    KanjiMode: [0xff21],
    Katakana: [0xff26],
    Left: [0xff51],
    Meta: [0xffe7, 0xffe7, 0xffe8],
    ModeChange: [0xff7e],
    NumLock: [0xff7f],
    PageDown: [0xff56],
    PageUp: [0xff55],
    Pause: [0xff13],
    Play: [0xfd16],
    PreviousCandidate: [0xff3e],
    PrintScreen: [0xff61],
    Redo: [0xff66],
    Right: [0xff53],
    RomanCharacters: null,
    Scroll: [0xff14],
    Select: [0xff60],
    Separator: [0xffac],
    Shift: [0xffe1, 0xffe1, 0xffe2],
    SingleCandidate: [0xff3c],
    Super: [0xffeb, 0xffeb, 0xffec],
    Tab: [0xff09],
    UIKeyInputDownArrow: [0xff54],
    UIKeyInputEscape: [0xff1b],
    UIKeyInputLeftArrow: [0xff51],
    UIKeyInputRightArrow: [0xff53],
    UIKeyInputUpArrow: [0xff52],
    Up: [0xff52],
    Undo: [0xff65],
    Win: [0xffeb],
    Zenkaku: [0xff28],
    ZenkakuHankaku: [0xff2a],
  };

  /**
   * All keysyms which should not repeat when held down.
   * @private
   */
  var no_repeat = {
    0xfe03: true, // ISO Level 3 Shift (AltGr)
    0xffe1: true, // Left shift
    0xffe2: true, // Right shift
    0xffe3: true, // Left ctrl
    0xffe4: true, // Right ctrl
    0xffe5: true, // Caps Lock
    0xffe7: true, // Left meta
    0xffe8: true, // Right meta
    0xffe9: true, // Left alt
    0xffea: true, // Right alt
    0xffeb: true, // Left hyper
    0xffec: true, // Right hyper
  };

  /**
   * All modifiers and their states.
   */
  this.modifiers = new Guacamole.Keyboard.ModifierState();

  /**
   * The state of every key, indexed by keysym. If a particular key is
   * pressed, the value of pressed for that keysym will be true. If a key
   * is not currently pressed, it will not be defined.
   */
  this.pressed = {};

  /**
   * The state of every key, indexed by keysym, for strictly those keys whose
   * status has been indirectly determined thorugh observation of other key
   * events. If a particular key is implicitly pressed, the value of
   * implicitlyPressed for that keysym will be true. If a key
   * is not currently implicitly pressed (the key is not pressed OR the state
   * of the key is explicitly known), it will not be defined.
   *
   * @private
   * @tyle {Object.<Number, Boolean>}
   */
  var implicitlyPressed = {};

  /**
   * The last result of calling the onkeydown handler for each key, indexed
   * by keysym. This is used to prevent/allow default actions for key events,
   * even when the onkeydown handler cannot be called again because the key
   * is (theoretically) still pressed.
   *
   * @private
   */
  var last_keydown_result = {};

  /**
   * The keysym most recently associated with a given keycode when keydown
   * fired. This object maps keycodes to keysyms.
   *
   * @private
   * @type {Object.<Number, Number>}
   */
  var recentKeysym = {};

  /**
   * Timeout before key repeat starts.
   * @private
   */
  var key_repeat_timeout = null;

  /**
   * Interval which presses and releases the last key pressed while that
   * key is still being held down.
   * @private
   */
  var key_repeat_interval = null;

  /**
   * Given an array of keysyms indexed by location, returns the keysym
   * for the given location, or the keysym for the standard location if
   * undefined.
   *
   * @private
   * @param {Number[]} keysyms
   *     An array of keysyms, where the index of the keysym in the array is
   *     the location value.
   *
   * @param {Number} location
   *     The location on the keyboard corresponding to the key pressed, as
   *     defined at: http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
   */
  var get_keysym = function get_keysym(keysyms, location) {
    if (!keysyms) return null;

    return keysyms[location] || keysyms[0];
  };

  /**
   * Returns true if the given keysym corresponds to a printable character,
   * false otherwise.
   *
   * @param {Number} keysym
   *     The keysym to check.
   *
   * @returns {Boolean}
   *     true if the given keysym corresponds to a printable character,
   *     false otherwise.
   */
  var isPrintable = function isPrintable(keysym) {
    // Keysyms with Unicode equivalents are printable
    return (
      (keysym >= 0x00 && keysym <= 0xff) || (keysym & 0xffff0000) === 0x01000000
    );
  };

  function keysym_from_key_identifier(identifier, location, shifted) {
    if (!identifier) return null;

    var typedCharacter;

    // If identifier is U+xxxx, decode Unicode character
    var unicodePrefixLocation = identifier.indexOf("U+");
    if (unicodePrefixLocation >= 0) {
      var hex = identifier.substring(unicodePrefixLocation + 2);
      typedCharacter = String.fromCharCode(parseInt(hex, 16));
    }

    // If single character and not keypad, use that as typed character
    else if (identifier.length === 1 && location !== 3)
      typedCharacter = identifier;
    // Otherwise, look up corresponding keysym
    else return get_keysym(keyidentifier_keysym[identifier], location);

    // Alter case if necessary
    if (shifted === true) typedCharacter = typedCharacter.toUpperCase();
    else if (shifted === false) typedCharacter = typedCharacter.toLowerCase();

    // Get codepoint
    var codepoint = typedCharacter.charCodeAt(0);
    return keysym_from_charcode(codepoint);
  }

  function isControlCharacter(codepoint) {
    return codepoint <= 0x1f || (codepoint >= 0x7f && codepoint <= 0x9f);
  }

  function keysym_from_charcode(codepoint) {
    // Keysyms for control characters
    if (isControlCharacter(codepoint)) return 0xff00 | codepoint;

    // Keysyms for ASCII chars
    if (codepoint >= 0x0000 && codepoint <= 0x00ff) return codepoint;

    // Keysyms for Unicode
    if (codepoint >= 0x0100 && codepoint <= 0x10ffff)
      return 0x01000000 | codepoint;

    return null;
  }

  function keysym_from_keycode(keyCode, location) {
    return get_keysym(keycodeKeysyms[keyCode], location);
  }

  /**
   * Heuristically detects if the legacy keyIdentifier property of
   * a keydown/keyup event looks incorrectly derived. Chrome, and
   * presumably others, will produce the keyIdentifier by assuming
   * the keyCode is the Unicode codepoint for that key. This is not
   * correct in all cases.
   *
   * @private
   * @param {Number} keyCode
   *     The keyCode from a browser keydown/keyup event.
   *
   * @param {String} keyIdentifier
   *     The legacy keyIdentifier from a browser keydown/keyup event.
   *
   * @returns {Boolean}
   *     true if the keyIdentifier looks sane, false if the keyIdentifier
   *     appears incorrectly derived or is missing entirely.
   */
  var key_identifier_sane = function key_identifier_sane(
    keyCode,
    keyIdentifier
  ) {
    // Missing identifier is not sane
    if (!keyIdentifier) return false;

    // Assume non-Unicode keyIdentifier values are sane
    var unicodePrefixLocation = keyIdentifier.indexOf("U+");
    if (unicodePrefixLocation === -1) return true;

    // If the Unicode codepoint isn't identical to the keyCode,
    // then the identifier is likely correct
    var codepoint = parseInt(
      keyIdentifier.substring(unicodePrefixLocation + 2),
      16
    );
    if (keyCode !== codepoint) return true;

    // The keyCodes for A-Z and 0-9 are actually identical to their
    // Unicode codepoints
    if ((keyCode >= 65 && keyCode <= 90) || (keyCode >= 48 && keyCode <= 57))
      return true;

    // The keyIdentifier does NOT appear sane
    return false;
  };

  /**
   * Marks a key as pressed, firing the keydown event if registered. Key
   * repeat for the pressed key will start after a delay if that key is
   * not a modifier. The return value of this function depends on the
   * return value of the keydown event handler, if any.
   *
   * @param {Number} keysym The keysym of the key to press.
   * @return {Boolean} true if event should NOT be canceled, false otherwise.
   */
  this.press = function (keysym) {
    // Don't bother with pressing the key if the key is unknown
    if (keysym === null) return;

    // Only press if released
    if (!guac_keyboard.pressed[keysym]) {
      // Mark key as pressed
      guac_keyboard.pressed[keysym] = true;

      // Send key event
      if (guac_keyboard.onkeydown) {
        var result = guac_keyboard.onkeydown(keysym);
        last_keydown_result[keysym] = result;

        // Stop any current repeat
        window.clearTimeout(key_repeat_timeout);
        window.clearInterval(key_repeat_interval);

        // Repeat after a delay as long as pressed
        if (!no_repeat[keysym])
          key_repeat_timeout = window.setTimeout(function () {
            key_repeat_interval = window.setInterval(function () {
              guac_keyboard.onkeyup(keysym);
              guac_keyboard.onkeydown(keysym);
            }, 50);
          }, 500);

        return result;
      }
    }

    // Return the last keydown result by default, resort to false if unknown
    return last_keydown_result[keysym] || false;
  };

  /**
   * Marks a key as released, firing the keyup event if registered.
   *
   * @param {Number} keysym The keysym of the key to release.
   */
  this.release = function (keysym) {
    // Only release if pressed
    if (guac_keyboard.pressed[keysym]) {
      // Mark key as released
      delete guac_keyboard.pressed[keysym];
      delete implicitlyPressed[keysym];

      // Stop repeat
      window.clearTimeout(key_repeat_timeout);
      window.clearInterval(key_repeat_interval);

      // Send key event
      if (keysym !== null && guac_keyboard.onkeyup)
        guac_keyboard.onkeyup(keysym);
    }
  };

  /**
   * Presses and releases the keys necessary to type the given string of
   * text.
   *
   * @param {String} str
   *     The string to type.
   */
  this.type = function type(str) {
    // Press/release the key corresponding to each character in the string
    for (var i = 0; i < str.length; i++) {
      // Determine keysym of current character
      var codepoint = str.codePointAt ? str.codePointAt(i) : str.charCodeAt(i);
      var keysym = keysym_from_charcode(codepoint);

      // Press and release key for current character
      guac_keyboard.press(keysym);
      guac_keyboard.release(keysym);
    }
  };

  /**
   * Resets the state of this keyboard, releasing all keys, and firing keyup
   * events for each released key.
   */
  this.reset = function () {
    // Release all pressed keys
    for (var keysym in guac_keyboard.pressed)
      guac_keyboard.release(parseInt(keysym));

    // Clear event log
    eventLog = [];
  };

  /**
   * Given the remote and local state of a particular key, resynchronizes the
   * remote state of that key with the local state through pressing or
   * releasing keysyms.
   *
   * @private
   * @param {Boolean} remoteState
   *     Whether the key is currently pressed remotely.
   *
   * @param {Boolean} localState
   *     Whether the key is currently pressed remotely locally. If the state
   *     of the key is not known, this may be undefined.
   *
   * @param {Number[]} keysyms
   *     The keysyms which represent the key being updated.
   *
   * @param {KeyEvent} keyEvent
   *     Guacamole's current best interpretation of the key event being
   *     processed.
   */
  var updateModifierState = function updateModifierState(
    remoteState,
    localState,
    keysyms,
    keyEvent
  ) {
    var i;

    // Do not trust changes in modifier state for events directly involving
    // that modifier: (1) the flag may erroneously be cleared despite
    // another version of the same key still being held and (2) the change
    // in flag may be due to the current event being processed, thus
    // updating things here is at best redundant and at worst incorrect
    if (keysyms.indexOf(keyEvent.keysym) !== -1) return;

    // Release all related keys if modifier is implicitly released
    if (remoteState && localState === false) {
      for (i = 0; i < keysyms.length; i++) {
        guac_keyboard.release(keysyms[i]);
      }
    }

    // Press if modifier is implicitly pressed
    else if (!remoteState && localState) {
      // Verify that modifier flag isn't already pressed or already set
      // due to another version of the same key being held down
      for (i = 0; i < keysyms.length; i++) {
        if (guac_keyboard.pressed[keysyms[i]]) return;
      }

      // Mark as implicitly pressed only if there is other information
      // within the key event relating to a different key. Some
      // platforms, such as iOS, will send essentially empty key events
      // for modifier keys, using only the modifier flags to signal the
      // identity of the key.
      var keysym = keysyms[0];
      if (keyEvent.keysym) implicitlyPressed[keysym] = true;

      guac_keyboard.press(keysym);
    }
  };

  /**
   * Given a keyboard event, updates the local modifier state and remote
   * key state based on the modifier flags within the event. This function
   * pays no attention to keycodes.
   *
   * @private
   * @param {KeyboardEvent} e
   *     The keyboard event containing the flags to update.
   *
   * @param {KeyEvent} keyEvent
   *     Guacamole's current best interpretation of the key event being
   *     processed.
   */
  var syncModifierStates = function syncModifierStates(e, keyEvent) {
    // Get state
    var state = Guacamole.Keyboard.ModifierState.fromKeyboardEvent(e);

    // Resync state of alt
    updateModifierState(
      guac_keyboard.modifiers.alt,
      state.alt,
      [
        0xffe9, // Left alt
        0xffea, // Right alt
        0xfe03, // AltGr
      ],
      keyEvent
    );

    // Resync state of shift
    updateModifierState(
      guac_keyboard.modifiers.shift,
      state.shift,
      [
        0xffe1, // Left shift
        0xffe2, // Right shift
      ],
      keyEvent
    );

    // Resync state of ctrl
    updateModifierState(
      guac_keyboard.modifiers.ctrl,
      state.ctrl,
      [
        0xffe3, // Left ctrl
        0xffe4, // Right ctrl
      ],
      keyEvent
    );

    // Resync state of meta
    updateModifierState(
      guac_keyboard.modifiers.meta,
      state.meta,
      [
        0xffe7, // Left meta
        0xffe8, // Right meta
      ],
      keyEvent
    );

    // Resync state of hyper
    updateModifierState(
      guac_keyboard.modifiers.hyper,
      state.hyper,
      [
        0xffeb, // Left hyper
        0xffec, // Right hyper
      ],
      keyEvent
    );

    // Update state
    guac_keyboard.modifiers = state;
  };

  /**
   * Returns whether all currently pressed keys were implicitly pressed. A
   * key is implicitly pressed if its status was inferred indirectly from
   * inspection of other key events.
   *
   * @private
   * @returns {Boolean}
   *     true if all currently pressed keys were implicitly pressed, false
   *     otherwise.
   */
  var isStateImplicit = function isStateImplicit() {
    for (var keysym in guac_keyboard.pressed) {
      if (!implicitlyPressed[keysym]) return false;
    }

    return true;
  };

  /**
   * Reads through the event log, removing events from the head of the log
   * when the corresponding true key presses are known (or as known as they
   * can be).
   *
   * @private
   * @return {Boolean} Whether the default action of the latest event should
   *                   be prevented.
   */
  function interpret_events() {
    // Do not prevent default if no event could be interpreted
    var handled_event = interpret_event();
    if (!handled_event) return false;

    // Interpret as much as possible
    var last_event;
    do {
      last_event = handled_event;
      handled_event = interpret_event();
    } while (handled_event !== null);

    // Reset keyboard state if we cannot expect to receive any further
    // keyup events
    if (isStateImplicit()) guac_keyboard.reset();

    return last_event.defaultPrevented;
  }

  /**
   * Releases Ctrl+Alt, if both are currently pressed and the given keysym
   * looks like a key that may require AltGr.
   *
   * @private
   * @param {Number} keysym The key that was just pressed.
   */
  var release_simulated_altgr = function release_simulated_altgr(keysym) {
    // Both Ctrl+Alt must be pressed if simulated AltGr is in use
    if (!guac_keyboard.modifiers.ctrl || !guac_keyboard.modifiers.alt) return;

    // Assume [A-Z] never require AltGr
    if (keysym >= 0x0041 && keysym <= 0x005a) return;

    // Assume [a-z] never require AltGr
    if (keysym >= 0x0061 && keysym <= 0x007a) return;

    // Release Ctrl+Alt if the keysym is printable
    if (keysym <= 0xff || (keysym & 0xff000000) === 0x01000000) {
      guac_keyboard.release(0xffe3); // Left ctrl
      guac_keyboard.release(0xffe4); // Right ctrl
      guac_keyboard.release(0xffe9); // Left alt
      guac_keyboard.release(0xffea); // Right alt
    }
  };

  /**
   * Reads through the event log, interpreting the first event, if possible,
   * and returning that event. If no events can be interpreted, due to a
   * total lack of events or the need for more events, null is returned. Any
   * interpreted events are automatically removed from the log.
   *
   * @private
   * @return {KeyEvent}
   *     The first key event in the log, if it can be interpreted, or null
   *     otherwise.
   */
  var interpret_event = function interpret_event() {
    // Peek at first event in log
    var first = eventLog[0];
    if (!first) return null;

    // Keydown event
    if (first instanceof KeydownEvent) {
      var keysym = null;
      var accepted_events = [];

      // If event itself is reliable, no need to wait for other events
      if (first.reliable) {
        keysym = first.keysym;
        accepted_events = eventLog.splice(0, 1);
      }

      // If keydown is immediately followed by a keypress, use the indicated character
      else if (eventLog[1] instanceof KeypressEvent) {
        keysym = eventLog[1].keysym;
        accepted_events = eventLog.splice(0, 2);
      }

      // If keydown is immediately followed by anything else, then no
      // keypress can possibly occur to clarify this event, and we must
      // handle it now
      else if (eventLog[1]) {
        keysym = first.keysym;
        accepted_events = eventLog.splice(0, 1);
      }

      // Fire a key press if valid events were found
      if (accepted_events.length > 0) {
        if (keysym) {
          // Fire event
          release_simulated_altgr(keysym);
          var defaultPrevented = !guac_keyboard.press(keysym);
          recentKeysym[first.keyCode] = keysym;

          // Release the key now if we cannot rely on the associated
          // keyup event
          if (!first.keyupReliable) guac_keyboard.release(keysym);

          // Record whether default was prevented
          for (var i = 0; i < accepted_events.length; i++)
            accepted_events[i].defaultPrevented = defaultPrevented;
        }

        return first;
      }
    } // end if keydown

    // Keyup event
    else if (first instanceof KeyupEvent && !quirks.keyupUnreliable) {
      // Release specific key if known
      var keysym = first.keysym;
      if (keysym) {
        guac_keyboard.release(keysym);
        delete recentKeysym[first.keyCode];
        first.defaultPrevented = true;
      }

      // Otherwise, fall back to releasing all keys
      else {
        guac_keyboard.reset();
        return first;
      }

      return eventLog.shift();
    } // end if keyup

    // Ignore any other type of event (keypress by itself is invalid, and
    // unreliable keyup events should simply be dumped)
    else return eventLog.shift();

    // No event interpreted
    return null;
  };

  /**
   * Returns the keyboard location of the key associated with the given
   * keyboard event. The location differentiates key events which otherwise
   * have the same keycode, such as left shift vs. right shift.
   *
   * @private
   * @param {KeyboardEvent} e
   *     A JavaScript keyboard event, as received through the DOM via a
   *     "keydown", "keyup", or "keypress" handler.
   *
   * @returns {Number}
   *     The location of the key event on the keyboard, as defined at:
   *     http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
   */
  var getEventLocation = function getEventLocation(e) {
    // Use standard location, if possible
    if ("location" in e) return e.location;

    // Failing that, attempt to use deprecated keyLocation
    if ("keyLocation" in e) return e.keyLocation;

    // If no location is available, assume left side
    return 0;
  };

  /**
   * Attempts to mark the given Event as having been handled by this
   * Guacamole.Keyboard. If the Event has already been marked as handled,
   * false is returned.
   *
   * @param {Event} e
   *     The Event to mark.
   *
   * @returns {Boolean}
   *     true if the given Event was successfully marked, false if the given
   *     Event was already marked.
   */
  var markEvent = function markEvent(e) {
    // Fail if event is already marked
    if (e[EVENT_MARKER]) return false;

    // Mark event otherwise
    e[EVENT_MARKER] = true;
    return true;
  };

  /**
   * Attaches event listeners to the given Element, automatically translating
   * received key, input, and composition events into simple keydown/keyup
   * events signalled through this Guacamole.Keyboard's onkeydown and
   * onkeyup handlers.
   *
   * @param {Element|Document} element
   *     The Element to attach event listeners to for the sake of handling
   *     key or input events.
   */
  this.listenTo = function listenTo(element) {
    // When key pressed
    element.addEventListener(
      "keydown",
      function (e) {
        // Only intercept if handler set
        if (!guac_keyboard.onkeydown) return;

        // Ignore events which have already been handled
        if (!markEvent(e)) return;

        var keyCode;
        if (window.event) keyCode = window.event.keyCode;
        else if (e.which) keyCode = e.which;

        // Fix modifier states
        var keydownEvent = new KeydownEvent(
          keyCode,
          e.keyIdentifier,
          e.key,
          getEventLocation(e)
        );
        syncModifierStates(e, keydownEvent);

        // Ignore (but do not prevent) the "composition" keycode sent by some
        // browsers when an IME is in use (see: http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html)
        if (keyCode === 229) return;

        // Log event
        eventLog.push(keydownEvent);

        // Interpret as many events as possible, prevent default if indicated
        if (interpret_events()) e.preventDefault();
      },
      true
    );

    // When key pressed
    element.addEventListener(
      "keypress",
      function (e) {
        // Only intercept if handler set
        if (!guac_keyboard.onkeydown && !guac_keyboard.onkeyup) return;

        // Ignore events which have already been handled
        if (!markEvent(e)) return;

        var charCode;
        if (window.event) charCode = window.event.keyCode;
        else if (e.which) charCode = e.which;

        // Fix modifier states
        var keypressEvent = new KeypressEvent(charCode);
        syncModifierStates(e, keypressEvent);

        // Log event
        eventLog.push(keypressEvent);

        // Interpret as many events as possible, prevent default if indicated
        if (interpret_events()) e.preventDefault();
      },
      true
    );

    // When key released
    element.addEventListener(
      "keyup",
      function (e) {
        // Only intercept if handler set
        if (!guac_keyboard.onkeyup) return;

        // Ignore events which have already been handled
        if (!markEvent(e)) return;

        e.preventDefault();

        var keyCode;
        if (window.event) keyCode = window.event.keyCode;
        else if (e.which) keyCode = e.which;

        // Fix modifier states
        var keyupEvent = new KeyupEvent(
          keyCode,
          e.keyIdentifier,
          e.key,
          getEventLocation(e)
        );
        syncModifierStates(e, keyupEvent);

        // Log event, call for interpretation
        eventLog.push(keyupEvent);
        interpret_events();
      },
      true
    );

    /**
     * Handles the given "input" event, typing the data within the input text.
     * If the event is complete (text is provided), handling of "compositionend"
     * events is suspended, as such events may conflict with input events.
     *
     * @private
     * @param {InputEvent} e
     *     The "input" event to handle.
     */
    var handleInput = function handleInput(e) {
      // Only intercept if handler set
      if (!guac_keyboard.onkeydown && !guac_keyboard.onkeyup) return;

      // Ignore events which have already been handled
      if (!markEvent(e)) return;

      // Type all content written
      if (e.data && !e.isComposing) {
        element.removeEventListener("compositionend", handleComposition, false);
        guac_keyboard.type(e.data);
      }
    };

    /**
     * Handles the given "compositionend" event, typing the data within the
     * composed text. If the event is complete (composed text is provided),
     * handling of "input" events is suspended, as such events may conflict
     * with composition events.
     *
     * @private
     * @param {CompositionEvent} e
     *     The "compositionend" event to handle.
     */
    var handleComposition = function handleComposition(e) {
      // Only intercept if handler set
      if (!guac_keyboard.onkeydown && !guac_keyboard.onkeyup) return;

      // Ignore events which have already been handled
      if (!markEvent(e)) return;

      // Type all content written
      if (e.data) {
        element.removeEventListener("input", handleInput, false);
        guac_keyboard.type(e.data);
      }
    };

    // Automatically type text entered into the wrapped field
    element.addEventListener("input", handleInput, false);
    element.addEventListener("compositionend", handleComposition, false);
  };

  // Listen to given element, if any
  if (element) guac_keyboard.listenTo(element);
};

/**
 * The unique numerical identifier to assign to the next Guacamole.Keyboard
 * instance.
 *
 * @private
 * @type {Number}
 */
Guacamole.Keyboard._nextID = 0;

/**
 * The state of all supported keyboard modifiers.
 * @constructor
 */
Guacamole.Keyboard.ModifierState = function () {
  /**
   * Whether shift is currently pressed.
   * @type {Boolean}
   */
  this.shift = false;

  /**
   * Whether ctrl is currently pressed.
   * @type {Boolean}
   */
  this.ctrl = false;

  /**
   * Whether alt is currently pressed.
   * @type {Boolean}
   */
  this.alt = false;

  /**
   * Whether meta (apple key) is currently pressed.
   * @type {Boolean}
   */
  this.meta = false;

  /**
   * Whether hyper (windows key) is currently pressed.
   * @type {Boolean}
   */
  this.hyper = false;
};

/**
 * Returns the modifier state applicable to the keyboard event given.
 *
 * @param {KeyboardEvent} e The keyboard event to read.
 * @returns {Guacamole.Keyboard.ModifierState} The current state of keyboard
 *                                             modifiers.
 */
Guacamole.Keyboard.ModifierState.fromKeyboardEvent = function (e) {
  var state = new Guacamole.Keyboard.ModifierState();

  // Assign states from old flags
  state.shift = e.shiftKey;
  state.ctrl = e.ctrlKey;
  state.alt = e.altKey;
  state.meta = e.metaKey;

  // Use DOM3 getModifierState() for others
  if (e.getModifierState) {
    state.hyper =
      e.getModifierState("OS") ||
      e.getModifierState("Super") ||
      e.getModifierState("Hyper") ||
      e.getModifierState("Win");
  }

  return state;
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Abstract ordered drawing surface. Each Layer contains a canvas element and
 * provides simple drawing instructions for drawing to that canvas element,
 * however unlike the canvas element itself, drawing operations on a Layer are
 * guaranteed to run in order, even if such an operation must wait for an image
 * to load before completing.
 *
 * @constructor
 *
 * @param {Number} width The width of the Layer, in pixels. The canvas element
 *                       backing this Layer will be given this width.
 *
 * @param {Number} height The height of the Layer, in pixels. The canvas element
 *                        backing this Layer will be given this height.
 */
Guacamole.Layer = function (width, height) {
  /**
   * Reference to this Layer.
   * @private
   */
  var layer = this;

  /**
   * The number of pixels the width or height of a layer must change before
   * the underlying canvas is resized. The underlying canvas will be kept at
   * dimensions which are integer multiples of this factor.
   *
   * @private
   * @constant
   * @type Number
   */
  var CANVAS_SIZE_FACTOR = 64;

  /**
   * The canvas element backing this Layer.
   * @private
   */
  var canvas = document.createElement("canvas");

  /**
   * The 2D display context of the canvas element backing this Layer.
   * @private
   */
  var context = canvas.getContext("2d");
  context.save();

  /**
   * Whether the layer has not yet been drawn to. Once any draw operation
   * which affects the underlying canvas is invoked, this flag will be set to
   * false.
   *
   * @private
   * @type Boolean
   */
  var empty = true;

  /**
   * Whether a new path should be started with the next path drawing
   * operations.
   * @private
   */
  var pathClosed = true;

  /**
   * The number of states on the state stack.
   *
   * Note that there will ALWAYS be one element on the stack, but that
   * element is not exposed. It is only used to reset the layer to its
   * initial state.
   *
   * @private
   */
  var stackSize = 0;

  /**
   * Map of all Guacamole channel masks to HTML5 canvas composite operation
   * names. Not all channel mask combinations are currently implemented.
   * @private
   */
  var compositeOperation = {
    /* 0x0 NOT IMPLEMENTED */
    0x1: "destination-in",
    0x2: "destination-out",
    /* 0x3 NOT IMPLEMENTED */
    0x4: "source-in",
    /* 0x5 NOT IMPLEMENTED */
    0x6: "source-atop",
    /* 0x7 NOT IMPLEMENTED */
    0x8: "source-out",
    0x9: "destination-atop",
    0xa: "xor",
    0xb: "destination-over",
    0xc: "copy",
    /* 0xD NOT IMPLEMENTED */
    0xe: "source-over",
    0xf: "lighter",
  };

  /**
   * Resizes the canvas element backing this Layer. This function should only
   * be used internally.
   *
   * @private
   * @param {Number} [newWidth=0]
   *     The new width to assign to this Layer.
   *
   * @param {Number} [newHeight=0]
   *     The new height to assign to this Layer.
   */
  var resize = function resize(newWidth, newHeight) {
    // Default size to zero
    newWidth = newWidth || 0;
    newHeight = newHeight || 0;

    // Calculate new dimensions of internal canvas
    var canvasWidth =
      Math.ceil(newWidth / CANVAS_SIZE_FACTOR) * CANVAS_SIZE_FACTOR;
    var canvasHeight =
      Math.ceil(newHeight / CANVAS_SIZE_FACTOR) * CANVAS_SIZE_FACTOR;

    // Resize only if canvas dimensions are actually changing
    if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
      // Copy old data only if relevant and non-empty
      var oldData = null;
      if (!empty && canvas.width !== 0 && canvas.height !== 0) {
        // Create canvas and context for holding old data
        oldData = document.createElement("canvas");
        oldData.width = Math.min(layer.width, newWidth);
        oldData.height = Math.min(layer.height, newHeight);

        var oldDataContext = oldData.getContext("2d");

        // Copy image data from current
        oldDataContext.drawImage(
          canvas,
          0,
          0,
          oldData.width,
          oldData.height,
          0,
          0,
          oldData.width,
          oldData.height
        );
      }

      // Preserve composite operation
      var oldCompositeOperation = context.globalCompositeOperation;

      // Resize canvas
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      // Redraw old data, if any
      if (oldData)
        context.drawImage(
          oldData,
          0,
          0,
          oldData.width,
          oldData.height,
          0,
          0,
          oldData.width,
          oldData.height
        );

      // Restore composite operation
      context.globalCompositeOperation = oldCompositeOperation;

      // Acknowledge reset of stack (happens on resize of canvas)
      stackSize = 0;
      context.save();
    }

    // If the canvas size is not changing, manually force state reset
    else layer.reset();

    // Assign new layer dimensions
    layer.width = newWidth;
    layer.height = newHeight;
  };

  /**
   * Given the X and Y coordinates of the upper-left corner of a rectangle
   * and the rectangle's width and height, resize the backing canvas element
   * as necessary to ensure that the rectangle fits within the canvas
   * element's coordinate space. This function will only make the canvas
   * larger. If the rectangle already fits within the canvas element's
   * coordinate space, the canvas is left unchanged.
   *
   * @private
   * @param {Number} x The X coordinate of the upper-left corner of the
   *                   rectangle to fit.
   * @param {Number} y The Y coordinate of the upper-left corner of the
   *                   rectangle to fit.
   * @param {Number} w The width of the the rectangle to fit.
   * @param {Number} h The height of the the rectangle to fit.
   */
  function fitRect(x, y, w, h) {
    // Calculate bounds
    var opBoundX = w + x;
    var opBoundY = h + y;

    // Determine max width
    var resizeWidth;
    if (opBoundX > layer.width) resizeWidth = opBoundX;
    else resizeWidth = layer.width;

    // Determine max height
    var resizeHeight;
    if (opBoundY > layer.height) resizeHeight = opBoundY;
    else resizeHeight = layer.height;

    // Resize if necessary
    layer.resize(resizeWidth, resizeHeight);
  }

  /**
   * Set to true if this Layer should resize itself to accomodate the
   * dimensions of any drawing operation, and false (the default) otherwise.
   *
   * Note that setting this property takes effect immediately, and thus may
   * take effect on operations that were started in the past but have not
   * yet completed. If you wish the setting of this flag to only modify
   * future operations, you will need to make the setting of this flag an
   * operation with sync().
   *
   * @example
   * // Set autosize to true for all future operations
   * layer.sync(function() {
   *     layer.autosize = true;
   * });
   *
   * @type {Boolean}
   * @default false
   */
  this.autosize = false;

  /**
   * The current width of this layer.
   * @type {Number}
   */
  this.width = width;

  /**
   * The current height of this layer.
   * @type {Number}
   */
  this.height = height;

  /**
   * Returns the canvas element backing this Layer. Note that the dimensions
   * of the canvas may not exactly match those of the Layer, as resizing a
   * canvas while maintaining its state is an expensive operation.
   *
   * @returns {HTMLCanvasElement}
   *     The canvas element backing this Layer.
   */
  this.getCanvas = function getCanvas() {
    return canvas;
  };

  /**
   * Returns a new canvas element containing the same image as this Layer.
   * Unlike getCanvas(), the canvas element returned is guaranteed to have
   * the exact same dimensions as the Layer.
   *
   * @returns {HTMLCanvasElement}
   *     A new canvas element containing a copy of the image content this
   *     Layer.
   */
  this.toCanvas = function toCanvas() {
    // Create new canvas having same dimensions
    var canvas = document.createElement("canvas");
    canvas.width = layer.width;
    canvas.height = layer.height;

    // Copy image contents to new canvas
    var context = canvas.getContext("2d");
    context.drawImage(layer.getCanvas(), 0, 0);

    return canvas;
  };

  /**
   * Changes the size of this Layer to the given width and height. Resizing
   * is only attempted if the new size provided is actually different from
   * the current size.
   *
   * @param {Number} newWidth The new width to assign to this Layer.
   * @param {Number} newHeight The new height to assign to this Layer.
   */
  this.resize = function (newWidth, newHeight) {
    if (newWidth !== layer.width || newHeight !== layer.height)
      resize(newWidth, newHeight);
  };

  /**
   * Draws the specified image at the given coordinates. The image specified
   * must already be loaded.
   *
   * @param {Number} x
   *     The destination X coordinate.
   *
   * @param {Number} y
   *     The destination Y coordinate.
   *
   * @param {CanvasImageSource} image
   *     The image to draw. Note that this is not a URL.
   */
  this.drawImage = function (x, y, image) {
    if (layer.autosize) fitRect(x, y, image.width, image.height);
    context.drawImage(image, x, y);
    empty = false;
  };

  /**
   * Transfer a rectangle of image data from one Layer to this Layer using the
   * specified transfer function.
   *
   * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
   * @param {Number} srcx The X coordinate of the upper-left corner of the
   *                      rectangle within the source Layer's coordinate
   *                      space to copy data from.
   * @param {Number} srcy The Y coordinate of the upper-left corner of the
   *                      rectangle within the source Layer's coordinate
   *                      space to copy data from.
   * @param {Number} srcw The width of the rectangle within the source Layer's
   *                      coordinate space to copy data from.
   * @param {Number} srch The height of the rectangle within the source
   *                      Layer's coordinate space to copy data from.
   * @param {Number} x The destination X coordinate.
   * @param {Number} y The destination Y coordinate.
   * @param {Function} transferFunction The transfer function to use to
   *                                    transfer data from source to
   *                                    destination.
   */
  this.transfer = function (
    srcLayer,
    srcx,
    srcy,
    srcw,
    srch,
    x,
    y,
    transferFunction
  ) {
    var srcCanvas = srcLayer.getCanvas();

    // If entire rectangle outside source canvas, stop
    if (srcx >= srcCanvas.width || srcy >= srcCanvas.height) return;

    // Otherwise, clip rectangle to area
    if (srcx + srcw > srcCanvas.width) srcw = srcCanvas.width - srcx;

    if (srcy + srch > srcCanvas.height) srch = srcCanvas.height - srcy;

    // Stop if nothing to draw.
    if (srcw === 0 || srch === 0) return;

    if (layer.autosize) fitRect(x, y, srcw, srch);

    // Get image data from src and dst
    var src = srcLayer
      .getCanvas()
      .getContext("2d")
      .getImageData(srcx, srcy, srcw, srch);
    var dst = context.getImageData(x, y, srcw, srch);

    // Apply transfer for each pixel
    for (var i = 0; i < srcw * srch * 4; i += 4) {
      // Get source pixel environment
      var src_pixel = new Guacamole.Layer.Pixel(
        src.data[i],
        src.data[i + 1],
        src.data[i + 2],
        src.data[i + 3]
      );

      // Get destination pixel environment
      var dst_pixel = new Guacamole.Layer.Pixel(
        dst.data[i],
        dst.data[i + 1],
        dst.data[i + 2],
        dst.data[i + 3]
      );

      // Apply transfer function
      transferFunction(src_pixel, dst_pixel);

      // Save pixel data
      dst.data[i] = dst_pixel.red;
      dst.data[i + 1] = dst_pixel.green;
      dst.data[i + 2] = dst_pixel.blue;
      dst.data[i + 3] = dst_pixel.alpha;
    }

    // Draw image data
    context.putImageData(dst, x, y);
    empty = false;
  };

  /**
   * Put a rectangle of image data from one Layer to this Layer directly
   * without performing any alpha blending. Simply copy the data.
   *
   * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
   * @param {Number} srcx The X coordinate of the upper-left corner of the
   *                      rectangle within the source Layer's coordinate
   *                      space to copy data from.
   * @param {Number} srcy The Y coordinate of the upper-left corner of the
   *                      rectangle within the source Layer's coordinate
   *                      space to copy data from.
   * @param {Number} srcw The width of the rectangle within the source Layer's
   *                      coordinate space to copy data from.
   * @param {Number} srch The height of the rectangle within the source
   *                      Layer's coordinate space to copy data from.
   * @param {Number} x The destination X coordinate.
   * @param {Number} y The destination Y coordinate.
   */
  this.put = function (srcLayer, srcx, srcy, srcw, srch, x, y) {
    var srcCanvas = srcLayer.getCanvas();

    // If entire rectangle outside source canvas, stop
    if (srcx >= srcCanvas.width || srcy >= srcCanvas.height) return;

    // Otherwise, clip rectangle to area
    if (srcx + srcw > srcCanvas.width) srcw = srcCanvas.width - srcx;

    if (srcy + srch > srcCanvas.height) srch = srcCanvas.height - srcy;

    // Stop if nothing to draw.
    if (srcw === 0 || srch === 0) return;

    if (layer.autosize) fitRect(x, y, srcw, srch);

    // Get image data from src and dst
    var src = srcLayer
      .getCanvas()
      .getContext("2d")
      .getImageData(srcx, srcy, srcw, srch);
    context.putImageData(src, x, y);
    empty = false;
  };

  /**
   * Copy a rectangle of image data from one Layer to this Layer. This
   * operation will copy exactly the image data that will be drawn once all
   * operations of the source Layer that were pending at the time this
   * function was called are complete. This operation will not alter the
   * size of the source Layer even if its autosize property is set to true.
   *
   * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
   * @param {Number} srcx The X coordinate of the upper-left corner of the
   *                      rectangle within the source Layer's coordinate
   *                      space to copy data from.
   * @param {Number} srcy The Y coordinate of the upper-left corner of the
   *                      rectangle within the source Layer's coordinate
   *                      space to copy data from.
   * @param {Number} srcw The width of the rectangle within the source Layer's
   *                      coordinate space to copy data from.
   * @param {Number} srch The height of the rectangle within the source
   *                      Layer's coordinate space to copy data from.
   * @param {Number} x The destination X coordinate.
   * @param {Number} y The destination Y coordinate.
   */
  this.copy = function (srcLayer, srcx, srcy, srcw, srch, x, y) {
    var srcCanvas = srcLayer.getCanvas();

    // If entire rectangle outside source canvas, stop
    if (srcx >= srcCanvas.width || srcy >= srcCanvas.height) return;

    // Otherwise, clip rectangle to area
    if (srcx + srcw > srcCanvas.width) srcw = srcCanvas.width - srcx;

    if (srcy + srch > srcCanvas.height) srch = srcCanvas.height - srcy;

    // Stop if nothing to draw.
    if (srcw === 0 || srch === 0) return;

    if (layer.autosize) fitRect(x, y, srcw, srch);
    context.drawImage(srcCanvas, srcx, srcy, srcw, srch, x, y, srcw, srch);
    empty = false;
  };

  /**
   * Starts a new path at the specified point.
   *
   * @param {Number} x The X coordinate of the point to draw.
   * @param {Number} y The Y coordinate of the point to draw.
   */
  this.moveTo = function (x, y) {
    // Start a new path if current path is closed
    if (pathClosed) {
      context.beginPath();
      pathClosed = false;
    }

    if (layer.autosize) fitRect(x, y, 0, 0);
    context.moveTo(x, y);
  };

  /**
   * Add the specified line to the current path.
   *
   * @param {Number} x The X coordinate of the endpoint of the line to draw.
   * @param {Number} y The Y coordinate of the endpoint of the line to draw.
   */
  this.lineTo = function (x, y) {
    // Start a new path if current path is closed
    if (pathClosed) {
      context.beginPath();
      pathClosed = false;
    }

    if (layer.autosize) fitRect(x, y, 0, 0);
    context.lineTo(x, y);
  };

  /**
   * Add the specified arc to the current path.
   *
   * @param {Number} x The X coordinate of the center of the circle which
   *                   will contain the arc.
   * @param {Number} y The Y coordinate of the center of the circle which
   *                   will contain the arc.
   * @param {Number} radius The radius of the circle.
   * @param {Number} startAngle The starting angle of the arc, in radians.
   * @param {Number} endAngle The ending angle of the arc, in radians.
   * @param {Boolean} negative Whether the arc should be drawn in order of
   *                           decreasing angle.
   */
  this.arc = function (x, y, radius, startAngle, endAngle, negative) {
    // Start a new path if current path is closed
    if (pathClosed) {
      context.beginPath();
      pathClosed = false;
    }

    if (layer.autosize) fitRect(x, y, 0, 0);
    context.arc(x, y, radius, startAngle, endAngle, negative);
  };

  /**
   * Starts a new path at the specified point.
   *
   * @param {Number} cp1x The X coordinate of the first control point.
   * @param {Number} cp1y The Y coordinate of the first control point.
   * @param {Number} cp2x The X coordinate of the second control point.
   * @param {Number} cp2y The Y coordinate of the second control point.
   * @param {Number} x The X coordinate of the endpoint of the curve.
   * @param {Number} y The Y coordinate of the endpoint of the curve.
   */
  this.curveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
    // Start a new path if current path is closed
    if (pathClosed) {
      context.beginPath();
      pathClosed = false;
    }

    if (layer.autosize) fitRect(x, y, 0, 0);
    context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  };

  /**
   * Closes the current path by connecting the end point with the start
   * point (if any) with a straight line.
   */
  this.close = function () {
    context.closePath();
    pathClosed = true;
  };

  /**
   * Add the specified rectangle to the current path.
   *
   * @param {Number} x The X coordinate of the upper-left corner of the
   *                   rectangle to draw.
   * @param {Number} y The Y coordinate of the upper-left corner of the
   *                   rectangle to draw.
   * @param {Number} w The width of the rectangle to draw.
   * @param {Number} h The height of the rectangle to draw.
   */
  this.rect = function (x, y, w, h) {
    // Start a new path if current path is closed
    if (pathClosed) {
      context.beginPath();
      pathClosed = false;
    }

    if (layer.autosize) fitRect(x, y, w, h);
    context.rect(x, y, w, h);
  };

  /**
   * Clip all future drawing operations by the current path. The current path
   * is implicitly closed. The current path can continue to be reused
   * for other operations (such as fillColor()) but a new path will be started
   * once a path drawing operation (path() or rect()) is used.
   */
  this.clip = function () {
    // Set new clipping region
    context.clip();

    // Path now implicitly closed
    pathClosed = true;
  };

  /**
   * Stroke the current path with the specified color. The current path
   * is implicitly closed. The current path can continue to be reused
   * for other operations (such as clip()) but a new path will be started
   * once a path drawing operation (path() or rect()) is used.
   *
   * @param {String} cap The line cap style. Can be "round", "square",
   *                     or "butt".
   * @param {String} join The line join style. Can be "round", "bevel",
   *                      or "miter".
   * @param {Number} thickness The line thickness in pixels.
   * @param {Number} r The red component of the color to fill.
   * @param {Number} g The green component of the color to fill.
   * @param {Number} b The blue component of the color to fill.
   * @param {Number} a The alpha component of the color to fill.
   */
  this.strokeColor = function (cap, join, thickness, r, g, b, a) {
    // Stroke with color
    context.lineCap = cap;
    context.lineJoin = join;
    context.lineWidth = thickness;
    context.strokeStyle =
      "rgba(" + r + "," + g + "," + b + "," + a / 255.0 + ")";
    context.stroke();
    empty = false;

    // Path now implicitly closed
    pathClosed = true;
  };

  /**
   * Fills the current path with the specified color. The current path
   * is implicitly closed. The current path can continue to be reused
   * for other operations (such as clip()) but a new path will be started
   * once a path drawing operation (path() or rect()) is used.
   *
   * @param {Number} r The red component of the color to fill.
   * @param {Number} g The green component of the color to fill.
   * @param {Number} b The blue component of the color to fill.
   * @param {Number} a The alpha component of the color to fill.
   */
  this.fillColor = function (r, g, b, a) {
    // Fill with color
    context.fillStyle = "rgba(" + r + "," + g + "," + b + "," + a / 255.0 + ")";
    context.fill();
    empty = false;

    // Path now implicitly closed
    pathClosed = true;
  };

  /**
   * Stroke the current path with the image within the specified layer. The
   * image data will be tiled infinitely within the stroke. The current path
   * is implicitly closed. The current path can continue to be reused
   * for other operations (such as clip()) but a new path will be started
   * once a path drawing operation (path() or rect()) is used.
   *
   * @param {String} cap The line cap style. Can be "round", "square",
   *                     or "butt".
   * @param {String} join The line join style. Can be "round", "bevel",
   *                      or "miter".
   * @param {Number} thickness The line thickness in pixels.
   * @param {Guacamole.Layer} srcLayer The layer to use as a repeating pattern
   *                                   within the stroke.
   */
  this.strokeLayer = function (cap, join, thickness, srcLayer) {
    // Stroke with image data
    context.lineCap = cap;
    context.lineJoin = join;
    context.lineWidth = thickness;
    context.strokeStyle = context.createPattern(srcLayer.getCanvas(), "repeat");
    context.stroke();
    empty = false;

    // Path now implicitly closed
    pathClosed = true;
  };

  /**
   * Fills the current path with the image within the specified layer. The
   * image data will be tiled infinitely within the stroke. The current path
   * is implicitly closed. The current path can continue to be reused
   * for other operations (such as clip()) but a new path will be started
   * once a path drawing operation (path() or rect()) is used.
   *
   * @param {Guacamole.Layer} srcLayer The layer to use as a repeating pattern
   *                                   within the fill.
   */
  this.fillLayer = function (srcLayer) {
    // Fill with image data
    context.fillStyle = context.createPattern(srcLayer.getCanvas(), "repeat");
    context.fill();
    empty = false;

    // Path now implicitly closed
    pathClosed = true;
  };

  /**
   * Push current layer state onto stack.
   */
  this.push = function () {
    // Save current state onto stack
    context.save();
    stackSize++;
  };

  /**
   * Pop layer state off stack.
   */
  this.pop = function () {
    // Restore current state from stack
    if (stackSize > 0) {
      context.restore();
      stackSize--;
    }
  };

  /**
   * Reset the layer, clearing the stack, the current path, and any transform
   * matrix.
   */
  this.reset = function () {
    // Clear stack
    while (stackSize > 0) {
      context.restore();
      stackSize--;
    }

    // Restore to initial state
    context.restore();
    context.save();

    // Clear path
    context.beginPath();
    pathClosed = false;
  };

  /**
   * Sets the given affine transform (defined with six values from the
   * transform's matrix).
   *
   * @param {Number} a The first value in the affine transform's matrix.
   * @param {Number} b The second value in the affine transform's matrix.
   * @param {Number} c The third value in the affine transform's matrix.
   * @param {Number} d The fourth value in the affine transform's matrix.
   * @param {Number} e The fifth value in the affine transform's matrix.
   * @param {Number} f The sixth value in the affine transform's matrix.
   */
  this.setTransform = function (a, b, c, d, e, f) {
    context.setTransform(
      a,
      b,
      c,
      d,
      e,
      f
      /*0, 0, 1*/
    );
  };

  /**
   * Applies the given affine transform (defined with six values from the
   * transform's matrix).
   *
   * @param {Number} a The first value in the affine transform's matrix.
   * @param {Number} b The second value in the affine transform's matrix.
   * @param {Number} c The third value in the affine transform's matrix.
   * @param {Number} d The fourth value in the affine transform's matrix.
   * @param {Number} e The fifth value in the affine transform's matrix.
   * @param {Number} f The sixth value in the affine transform's matrix.
   */
  this.transform = function (a, b, c, d, e, f) {
    context.transform(
      a,
      b,
      c,
      d,
      e,
      f
      /*0, 0, 1*/
    );
  };

  /**
   * Sets the channel mask for future operations on this Layer.
   *
   * The channel mask is a Guacamole-specific compositing operation identifier
   * with a single bit representing each of four channels (in order): source
   * image where destination transparent, source where destination opaque,
   * destination where source transparent, and destination where source
   * opaque.
   *
   * @param {Number} mask The channel mask for future operations on this
   *                      Layer.
   */
  this.setChannelMask = function (mask) {
    context.globalCompositeOperation = compositeOperation[mask];
  };

  /**
   * Sets the miter limit for stroke operations using the miter join. This
   * limit is the maximum ratio of the size of the miter join to the stroke
   * width. If this ratio is exceeded, the miter will not be drawn for that
   * joint of the path.
   *
   * @param {Number} limit The miter limit for stroke operations using the
   *                       miter join.
   */
  this.setMiterLimit = function (limit) {
    context.miterLimit = limit;
  };

  // Initialize canvas dimensions
  resize(width, height);

  // Explicitly render canvas below other elements in the layer (such as
  // child layers). Chrome and others may fail to render layers properly
  // without this.
  canvas.style.zIndex = -1;
};

/**
 * Channel mask for the composite operation "rout".
 */
Guacamole.Layer.ROUT = 0x2;

/**
 * Channel mask for the composite operation "atop".
 */
Guacamole.Layer.ATOP = 0x6;

/**
 * Channel mask for the composite operation "xor".
 */
Guacamole.Layer.XOR = 0xa;

/**
 * Channel mask for the composite operation "rover".
 */
Guacamole.Layer.ROVER = 0xb;

/**
 * Channel mask for the composite operation "over".
 */
Guacamole.Layer.OVER = 0xe;

/**
 * Channel mask for the composite operation "plus".
 */
Guacamole.Layer.PLUS = 0xf;

/**
 * Channel mask for the composite operation "rin".
 * Beware that WebKit-based browsers may leave the contents of the destionation
 * layer where the source layer is transparent, despite the definition of this
 * operation.
 */
Guacamole.Layer.RIN = 0x1;

/**
 * Channel mask for the composite operation "in".
 * Beware that WebKit-based browsers may leave the contents of the destionation
 * layer where the source layer is transparent, despite the definition of this
 * operation.
 */
Guacamole.Layer.IN = 0x4;

/**
 * Channel mask for the composite operation "out".
 * Beware that WebKit-based browsers may leave the contents of the destionation
 * layer where the source layer is transparent, despite the definition of this
 * operation.
 */
Guacamole.Layer.OUT = 0x8;

/**
 * Channel mask for the composite operation "ratop".
 * Beware that WebKit-based browsers may leave the contents of the destionation
 * layer where the source layer is transparent, despite the definition of this
 * operation.
 */
Guacamole.Layer.RATOP = 0x9;

/**
 * Channel mask for the composite operation "src".
 * Beware that WebKit-based browsers may leave the contents of the destionation
 * layer where the source layer is transparent, despite the definition of this
 * operation.
 */
Guacamole.Layer.SRC = 0xc;

/**
 * Represents a single pixel of image data. All components have a minimum value
 * of 0 and a maximum value of 255.
 *
 * @constructor
 *
 * @param {Number} r The red component of this pixel.
 * @param {Number} g The green component of this pixel.
 * @param {Number} b The blue component of this pixel.
 * @param {Number} a The alpha component of this pixel.
 */
Guacamole.Layer.Pixel = function (r, g, b, a) {
  /**
   * The red component of this pixel, where 0 is the minimum value,
   * and 255 is the maximum.
   */
  this.red = r;

  /**
   * The green component of this pixel, where 0 is the minimum value,
   * and 255 is the maximum.
   */
  this.green = g;

  /**
   * The blue component of this pixel, where 0 is the minimum value,
   * and 255 is the maximum.
   */
  this.blue = b;

  /**
   * The alpha component of this pixel, where 0 is the minimum value,
   * and 255 is the maximum.
   */
  this.alpha = a;
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Provides cross-browser mouse events for a given element. The events of
 * the given element are automatically populated with handlers that translate
 * mouse events into a non-browser-specific event provided by the
 * Guacamole.Mouse instance.
 *
 * @constructor
 * @param {Element} element The Element to use to provide mouse events.
 */
Guacamole.Mouse = function (element) {
  /**
   * Reference to this Guacamole.Mouse.
   * @private
   */
  var guac_mouse = this;

  /**
   * The number of mousemove events to require before re-enabling mouse
   * event handling after receiving a touch event.
   */
  this.touchMouseThreshold = 3;

  /**
   * The minimum amount of pixels scrolled required for a single scroll button
   * click.
   */
  this.scrollThreshold = 53;

  /**
   * The number of pixels to scroll per line.
   */
  this.PIXELS_PER_LINE = 18;

  /**
   * The number of pixels to scroll per page.
   */
  this.PIXELS_PER_PAGE = this.PIXELS_PER_LINE * 16;

  /**
   * The current mouse state. The properties of this state are updated when
   * mouse events fire. This state object is also passed in as a parameter to
   * the handler of any mouse events.
   *
   * @type {Guacamole.Mouse.State}
   */
  this.currentState = new Guacamole.Mouse.State(
    0,
    0,
    false,
    false,
    false,
    false,
    false
  );

  /**
   * Fired whenever the user presses a mouse button down over the element
   * associated with this Guacamole.Mouse.
   *
   * @event
   * @param {Guacamole.Mouse.State} state The current mouse state.
   */
  this.onmousedown = null;

  /**
   * Fired whenever the user releases a mouse button down over the element
   * associated with this Guacamole.Mouse.
   *
   * @event
   * @param {Guacamole.Mouse.State} state The current mouse state.
   */
  this.onmouseup = null;

  /**
   * Fired whenever the user moves the mouse over the element associated with
   * this Guacamole.Mouse.
   *
   * @event
   * @param {Guacamole.Mouse.State} state The current mouse state.
   */
  this.onmousemove = null;

  /**
   * Fired whenever the mouse leaves the boundaries of the element associated
   * with this Guacamole.Mouse.
   *
   * @event
   */
  this.onmouseout = null;

  /**
   * Counter of mouse events to ignore. This decremented by mousemove, and
   * while non-zero, mouse events will have no effect.
   * @private
   */
  var ignore_mouse = 0;

  /**
   * Cumulative scroll delta amount. This value is accumulated through scroll
   * events and results in scroll button clicks if it exceeds a certain
   * threshold.
   *
   * @private
   */
  var scroll_delta = 0;

  function cancelEvent(e) {
    e.stopPropagation();
    if (e.preventDefault) e.preventDefault();
    e.returnValue = false;
  }

  // Block context menu so right-click gets sent properly
  element.addEventListener(
    "contextmenu",
    function (e) {
      cancelEvent(e);
    },
    false
  );

  element.addEventListener(
    "mousemove",
    function (e) {
      cancelEvent(e);

      // If ignoring events, decrement counter
      if (ignore_mouse) {
        ignore_mouse--;
        return;
      }

      guac_mouse.currentState.fromClientPosition(element, e.clientX, e.clientY);

      if (guac_mouse.onmousemove)
        guac_mouse.onmousemove(guac_mouse.currentState);
    },
    false
  );

  element.addEventListener(
    "mousedown",
    function (e) {
      cancelEvent(e);

      const keydownEvent = new Event("keydown");
      document.dispatchEvent(keydownEvent);

      // Do not handle if ignoring events
      if (ignore_mouse) return;

      switch (e.button) {
        case 0:
          guac_mouse.currentState.left = true;
          break;
        case 1:
          guac_mouse.currentState.middle = true;
          break;
        case 2:
          guac_mouse.currentState.right = true;
          break;
      }

      if (guac_mouse.onmousedown)
        guac_mouse.onmousedown(guac_mouse.currentState);
    },
    false
  );

  element.addEventListener(
    "mouseup",
    function (e) {
      cancelEvent(e);

      // Do not handle if ignoring events
      if (ignore_mouse) return;

      switch (e.button) {
        case 0:
          guac_mouse.currentState.left = false;
          break;
        case 1:
          guac_mouse.currentState.middle = false;
          break;
        case 2:
          guac_mouse.currentState.right = false;
          break;
      }

      if (guac_mouse.onmouseup) guac_mouse.onmouseup(guac_mouse.currentState);
    },
    false
  );

  element.addEventListener(
    "mouseout",
    function (e) {
      // Get parent of the element the mouse pointer is leaving
      if (!e) e = window.event;

      // Check that mouseout is due to actually LEAVING the element
      var target = e.relatedTarget || e.toElement;
      while (target) {
        if (target === element) return;
        target = target.parentNode;
      }

      cancelEvent(e);

      // Release all buttons
      if (
        guac_mouse.currentState.left ||
        guac_mouse.currentState.middle ||
        guac_mouse.currentState.right
      ) {
        guac_mouse.currentState.left = false;
        guac_mouse.currentState.middle = false;
        guac_mouse.currentState.right = false;

        if (guac_mouse.onmouseup) guac_mouse.onmouseup(guac_mouse.currentState);
      }

      // Fire onmouseout event
      if (guac_mouse.onmouseout) guac_mouse.onmouseout();
    },
    false
  );

  // Override selection on mouse event element.
  element.addEventListener(
    "selectstart",
    function (e) {
      cancelEvent(e);
    },
    false
  );

  // Ignore all pending mouse events when touch events are the apparent source
  function ignorePendingMouseEvents() {
    ignore_mouse = guac_mouse.touchMouseThreshold;
  }

  element.addEventListener("touchmove", ignorePendingMouseEvents, false);
  element.addEventListener("touchstart", ignorePendingMouseEvents, false);
  element.addEventListener("touchend", ignorePendingMouseEvents, false);

  // Scroll wheel support
  function mousewheel_handler(e) {
    // Determine approximate scroll amount (in pixels)
    var delta = e.deltaY || -e.wheelDeltaY || -e.wheelDelta;

    // If successfully retrieved scroll amount, convert to pixels if not
    // already in pixels
    if (delta) {
      // Convert to pixels if delta was lines
      if (e.deltaMode === 1) delta = e.deltaY * guac_mouse.PIXELS_PER_LINE;
      // Convert to pixels if delta was pages
      else if (e.deltaMode === 2) delta = e.deltaY * guac_mouse.PIXELS_PER_PAGE;
    }

    // Otherwise, assume legacy mousewheel event and line scrolling
    else delta = e.detail * guac_mouse.PIXELS_PER_LINE;

    // Update overall delta
    scroll_delta += delta;

    // Up
    if (scroll_delta <= -guac_mouse.scrollThreshold) {
      // Repeatedly click the up button until insufficient delta remains
      do {
        if (guac_mouse.onmousedown) {
          guac_mouse.currentState.up = true;
          guac_mouse.onmousedown(guac_mouse.currentState);
        }

        if (guac_mouse.onmouseup) {
          guac_mouse.currentState.up = false;
          guac_mouse.onmouseup(guac_mouse.currentState);
        }

        scroll_delta += guac_mouse.scrollThreshold;
      } while (scroll_delta <= -guac_mouse.scrollThreshold);

      // Reset delta
      scroll_delta = 0;
    }

    // Down
    if (scroll_delta >= guac_mouse.scrollThreshold) {
      // Repeatedly click the down button until insufficient delta remains
      do {
        if (guac_mouse.onmousedown) {
          guac_mouse.currentState.down = true;
          guac_mouse.onmousedown(guac_mouse.currentState);
        }

        if (guac_mouse.onmouseup) {
          guac_mouse.currentState.down = false;
          guac_mouse.onmouseup(guac_mouse.currentState);
        }

        scroll_delta -= guac_mouse.scrollThreshold;
      } while (scroll_delta >= guac_mouse.scrollThreshold);

      // Reset delta
      scroll_delta = 0;
    }

    cancelEvent(e);
  }

  element.addEventListener("DOMMouseScroll", mousewheel_handler, false);
  element.addEventListener("mousewheel", mousewheel_handler, false);
  element.addEventListener("wheel", mousewheel_handler, false);

  /**
   * Whether the browser supports CSS3 cursor styling, including hotspot
   * coordinates.
   *
   * @private
   * @type {Boolean}
   */
  var CSS3_CURSOR_SUPPORTED = (function () {
    var div = document.createElement("div");

    // If no cursor property at all, then no support
    if (!("cursor" in div.style)) return false;

    try {
      // Apply simple 1x1 PNG
      div.style.cursor =
        "url(data:image/png;base64," +
        "iVBORw0KGgoAAAANSUhEUgAAAAEAAAAB" +
        "AQMAAAAl21bKAAAAA1BMVEX///+nxBvI" +
        "AAAACklEQVQI12NgAAAAAgAB4iG8MwAA" +
        "AABJRU5ErkJggg==) 0 0, auto";
    } catch (e) {
      return false;
    }

    // Verify cursor property is set to URL with hotspot
    return /\burl\([^()]*\)\s+0\s+0\b/.test(div.style.cursor || "");
  })();

  /**
   * Changes the local mouse cursor to the given canvas, having the given
   * hotspot coordinates. This affects styling of the element backing this
   * Guacamole.Mouse only, and may fail depending on browser support for
   * setting the mouse cursor.
   *
   * If setting the local cursor is desired, it is up to the implementation
   * to do something else, such as use the software cursor built into
   * Guacamole.Display, if the local cursor cannot be set.
   *
   * @param {HTMLCanvasElement} canvas The cursor image.
   * @param {Number} x The X-coordinate of the cursor hotspot.
   * @param {Number} y The Y-coordinate of the cursor hotspot.
   * @return {Boolean} true if the cursor was successfully set, false if the
   *                   cursor could not be set for any reason.
   */
  this.setCursor = function (canvas, x, y) {
    // Attempt to set via CSS3 cursor styling
    if (CSS3_CURSOR_SUPPORTED) {
      var dataURL = canvas.toDataURL("image/png");
      element.style.cursor = "url(" + dataURL + ") " + x + " " + y + ", auto";
      return true;
    }

    // Otherwise, setting cursor failed
    return false;
  };
};

/**
 * Simple container for properties describing the state of a mouse.
 *
 * @constructor
 * @param {Number} x The X position of the mouse pointer in pixels.
 * @param {Number} y The Y position of the mouse pointer in pixels.
 * @param {Boolean} left Whether the left mouse button is pressed.
 * @param {Boolean} middle Whether the middle mouse button is pressed.
 * @param {Boolean} right Whether the right mouse button is pressed.
 * @param {Boolean} up Whether the up mouse button is pressed (the fourth
 *                     button, usually part of a scroll wheel).
 * @param {Boolean} down Whether the down mouse button is pressed (the fifth
 *                       button, usually part of a scroll wheel).
 */
Guacamole.Mouse.State = function (x, y, left, middle, right, up, down) {
  /**
   * Reference to this Guacamole.Mouse.State.
   * @private
   */
  var guac_state = this;

  /**
   * The current X position of the mouse pointer.
   * @type {Number}
   */
  this.x = x;

  /**
   * The current Y position of the mouse pointer.
   * @type {Number}
   */
  this.y = y;

  /**
   * Whether the left mouse button is currently pressed.
   * @type {Boolean}
   */
  this.left = left;

  /**
   * Whether the middle mouse button is currently pressed.
   * @type {Boolean}
   */
  this.middle = middle;

  /**
   * Whether the right mouse button is currently pressed.
   * @type {Boolean}
   */
  this.right = right;

  /**
   * Whether the up mouse button is currently pressed. This is the fourth
   * mouse button, associated with upward scrolling of the mouse scroll
   * wheel.
   * @type {Boolean}
   */
  this.up = up;

  /**
   * Whether the down mouse button is currently pressed. This is the fifth
   * mouse button, associated with downward scrolling of the mouse scroll
   * wheel.
   * @type {Boolean}
   */
  this.down = down;

  /**
   * Updates the position represented within this state object by the given
   * element and clientX/clientY coordinates (commonly available within event
   * objects). Position is translated from clientX/clientY (relative to
   * viewport) to element-relative coordinates.
   *
   * @param {Element} element The element the coordinates should be relative
   *                          to.
   * @param {Number} clientX The X coordinate to translate, viewport-relative.
   * @param {Number} clientY The Y coordinate to translate, viewport-relative.
   */
  this.fromClientPosition = function (element, clientX, clientY) {
    guac_state.x = clientX - element.offsetLeft;
    guac_state.y = clientY - element.offsetTop;

    // This is all JUST so we can get the mouse position within the element
    var parent = element.offsetParent;
    while (parent && !(parent === document.body)) {
      guac_state.x -= parent.offsetLeft - parent.scrollLeft;
      guac_state.y -= parent.offsetTop - parent.scrollTop;

      parent = parent.offsetParent;
    }

    // Element ultimately depends on positioning within document body,
    // take document scroll into account.
    if (parent) {
      var documentScrollLeft =
        document.body.scrollLeft || document.documentElement.scrollLeft;
      var documentScrollTop =
        document.body.scrollTop || document.documentElement.scrollTop;

      guac_state.x -= parent.offsetLeft - documentScrollLeft;
      guac_state.y -= parent.offsetTop - documentScrollTop;
    }
  };
};

/**
 * Provides cross-browser relative touch event translation for a given element.
 *
 * Touch events are translated into mouse events as if the touches occurred
 * on a touchpad (drag to push the mouse pointer, tap to click).
 *
 * @constructor
 * @param {Element} element The Element to use to provide touch events.
 */
Guacamole.Mouse.Touchpad = function (element) {
  /**
   * Reference to this Guacamole.Mouse.Touchpad.
   * @private
   */
  var guac_touchpad = this;

  /**
   * The distance a two-finger touch must move per scrollwheel event, in
   * pixels.
   */
  this.scrollThreshold = 20 * (window.devicePixelRatio || 1);

  /**
   * The maximum number of milliseconds to wait for a touch to end for the
   * gesture to be considered a click.
   */
  this.clickTimingThreshold = 250;

  /**
   * The maximum number of pixels to allow a touch to move for the gesture to
   * be considered a click.
   */
  this.clickMoveThreshold = 10 * (window.devicePixelRatio || 1);

  /**
   * The current mouse state. The properties of this state are updated when
   * mouse events fire. This state object is also passed in as a parameter to
   * the handler of any mouse events.
   *
   * @type {Guacamole.Mouse.State}
   */
  this.currentState = new Guacamole.Mouse.State(
    0,
    0,
    false,
    false,
    false,
    false,
    false
  );

  /**
   * Fired whenever a mouse button is effectively pressed. This can happen
   * as part of a "click" gesture initiated by the user by tapping one
   * or more fingers over the touchpad element, as part of a "scroll"
   * gesture initiated by dragging two fingers up or down, etc.
   *
   * @event
   * @param {Guacamole.Mouse.State} state The current mouse state.
   */
  this.onmousedown = null;

  /**
   * Fired whenever a mouse button is effectively released. This can happen
   * as part of a "click" gesture initiated by the user by tapping one
   * or more fingers over the touchpad element, as part of a "scroll"
   * gesture initiated by dragging two fingers up or down, etc.
   *
   * @event
   * @param {Guacamole.Mouse.State} state The current mouse state.
   */
  this.onmouseup = null;

  /**
   * Fired whenever the user moves the mouse by dragging their finger over
   * the touchpad element.
   *
   * @event
   * @param {Guacamole.Mouse.State} state The current mouse state.
   */
  this.onmousemove = null;

  var touch_count = 0;
  var last_touch_x = 0;
  var last_touch_y = 0;
  var last_touch_time = 0;
  var pixels_moved = 0;

  var touch_buttons = {
    1: "left",
    2: "right",
    3: "middle",
  };

  var gesture_in_progress = false;
  var click_release_timeout = null;

  element.addEventListener(
    "touchend",
    function (e) {
      e.preventDefault();

      // If we're handling a gesture AND this is the last touch
      if (gesture_in_progress && e.touches.length === 0) {
        var time = new Date().getTime();

        // Get corresponding mouse button
        var button = touch_buttons[touch_count];

        // If mouse already down, release anad clear timeout
        if (guac_touchpad.currentState[button]) {
          // Fire button up event
          guac_touchpad.currentState[button] = false;
          if (guac_touchpad.onmouseup)
            guac_touchpad.onmouseup(guac_touchpad.currentState);

          // Clear timeout, if set
          if (click_release_timeout) {
            window.clearTimeout(click_release_timeout);
            click_release_timeout = null;
          }
        }

        // If single tap detected (based on time and distance)
        if (
          time - last_touch_time <= guac_touchpad.clickTimingThreshold &&
          pixels_moved < guac_touchpad.clickMoveThreshold
        ) {
          // Fire button down event
          guac_touchpad.currentState[button] = true;
          if (guac_touchpad.onmousedown)
            guac_touchpad.onmousedown(guac_touchpad.currentState);

          // Delay mouse up - mouse up should be canceled if
          // touchstart within timeout.
          click_release_timeout = window.setTimeout(function () {
            // Fire button up event
            guac_touchpad.currentState[button] = false;
            if (guac_touchpad.onmouseup)
              guac_touchpad.onmouseup(guac_touchpad.currentState);

            // Gesture now over
            gesture_in_progress = false;
          }, guac_touchpad.clickTimingThreshold);
        }

        // If we're not waiting to see if this is a click, stop gesture
        if (!click_release_timeout) gesture_in_progress = false;
      }
    },
    false
  );

  element.addEventListener(
    "touchstart",
    function (e) {
      e.preventDefault();

      // Track number of touches, but no more than three
      touch_count = Math.min(e.touches.length, 3);

      // Clear timeout, if set
      if (click_release_timeout) {
        window.clearTimeout(click_release_timeout);
        click_release_timeout = null;
      }

      // Record initial touch location and time for touch movement
      // and tap gestures
      if (!gesture_in_progress) {
        // Stop mouse events while touching
        gesture_in_progress = true;

        // Record touch location and time
        var starting_touch = e.touches[0];
        last_touch_x = starting_touch.clientX;
        last_touch_y = starting_touch.clientY;
        last_touch_time = new Date().getTime();
        pixels_moved = 0;
      }
    },
    false
  );

  element.addEventListener(
    "touchmove",
    function (e) {
      e.preventDefault();

      // Get change in touch location
      var touch = e.touches[0];
      var delta_x = touch.clientX - last_touch_x;
      var delta_y = touch.clientY - last_touch_y;

      // Track pixels moved
      pixels_moved += Math.abs(delta_x) + Math.abs(delta_y);

      // If only one touch involved, this is mouse move
      if (touch_count === 1) {
        // Calculate average velocity in Manhatten pixels per millisecond
        var velocity = pixels_moved / (new Date().getTime() - last_touch_time);

        // Scale mouse movement relative to velocity
        var scale = 1 + velocity;

        // Update mouse location
        guac_touchpad.currentState.x += delta_x * scale;
        guac_touchpad.currentState.y += delta_y * scale;

        // Prevent mouse from leaving screen

        if (guac_touchpad.currentState.x < 0) guac_touchpad.currentState.x = 0;
        else if (guac_touchpad.currentState.x >= element.offsetWidth)
          guac_touchpad.currentState.x = element.offsetWidth - 1;

        if (guac_touchpad.currentState.y < 0) guac_touchpad.currentState.y = 0;
        else if (guac_touchpad.currentState.y >= element.offsetHeight)
          guac_touchpad.currentState.y = element.offsetHeight - 1;

        // Fire movement event, if defined
        if (guac_touchpad.onmousemove)
          guac_touchpad.onmousemove(guac_touchpad.currentState);

        // Update touch location
        last_touch_x = touch.clientX;
        last_touch_y = touch.clientY;
      }

      // Interpret two-finger swipe as scrollwheel
      else if (touch_count === 2) {
        // If change in location passes threshold for scroll
        if (Math.abs(delta_y) >= guac_touchpad.scrollThreshold) {
          // Decide button based on Y movement direction
          var button;
          if (delta_y > 0) button = "down";
          else button = "up";

          // Fire button down event
          guac_touchpad.currentState[button] = true;
          if (guac_touchpad.onmousedown)
            guac_touchpad.onmousedown(guac_touchpad.currentState);

          // Fire button up event
          guac_touchpad.currentState[button] = false;
          if (guac_touchpad.onmouseup)
            guac_touchpad.onmouseup(guac_touchpad.currentState);

          // Only update touch location after a scroll has been
          // detected
          last_touch_x = touch.clientX;
          last_touch_y = touch.clientY;
        }
      }
    },
    false
  );
};

/**
 * Provides cross-browser absolute touch event translation for a given element.
 *
 * Touch events are translated into mouse events as if the touches occurred
 * on a touchscreen (tapping anywhere on the screen clicks at that point,
 * long-press to right-click).
 *
 * @constructor
 * @param {Element} element The Element to use to provide touch events.
 */
Guacamole.Mouse.Touchscreen = function (element) {
  /**
   * Reference to this Guacamole.Mouse.Touchscreen.
   * @private
   */
  var guac_touchscreen = this;

  /**
   * Whether a gesture is known to be in progress. If false, touch events
   * will be ignored.
   *
   * @private
   */
  var gesture_in_progress = false;

  /**
   * The start X location of a gesture.
   * @private
   */
  var gesture_start_x = null;

  /**
   * The start Y location of a gesture.
   * @private
   */
  var gesture_start_y = null;

  /**
   * The timeout associated with the delayed, cancellable click release.
   *
   * @private
   */
  var click_release_timeout = null;

  /**
   * The timeout associated with long-press for right click.
   *
   * @private
   */
  var long_press_timeout = null;

  /**
   * The distance a two-finger touch must move per scrollwheel event, in
   * pixels.
   */
  this.scrollThreshold = 20 * (window.devicePixelRatio || 1);

  /**
   * The maximum number of milliseconds to wait for a touch to end for the
   * gesture to be considered a click.
   */
  this.clickTimingThreshold = 250;

  /**
   * The maximum number of pixels to allow a touch to move for the gesture to
   * be considered a click.
   */
  this.clickMoveThreshold = 16 * (window.devicePixelRatio || 1);

  /**
   * The amount of time a press must be held for long press to be
   * detected.
   */
  this.longPressThreshold = 500;

  /**
   * The current mouse state. The properties of this state are updated when
   * mouse events fire. This state object is also passed in as a parameter to
   * the handler of any mouse events.
   *
   * @type {Guacamole.Mouse.State}
   */
  this.currentState = new Guacamole.Mouse.State(
    0,
    0,
    false,
    false,
    false,
    false,
    false
  );

  /**
   * Fired whenever a mouse button is effectively pressed. This can happen
   * as part of a "mousedown" gesture initiated by the user by pressing one
   * finger over the touchscreen element, as part of a "scroll" gesture
   * initiated by dragging two fingers up or down, etc.
   *
   * @event
   * @param {Guacamole.Mouse.State} state The current mouse state.
   */
  this.onmousedown = null;

  /**
   * Fired whenever a mouse button is effectively released. This can happen
   * as part of a "mouseup" gesture initiated by the user by removing the
   * finger pressed against the touchscreen element, or as part of a "scroll"
   * gesture initiated by dragging two fingers up or down, etc.
   *
   * @event
   * @param {Guacamole.Mouse.State} state The current mouse state.
   */
  this.onmouseup = null;

  /**
   * Fired whenever the user moves the mouse by dragging their finger over
   * the touchscreen element. Note that unlike Guacamole.Mouse.Touchpad,
   * dragging a finger over the touchscreen element will always cause
   * the mouse button to be effectively down, as if clicking-and-dragging.
   *
   * @event
   * @param {Guacamole.Mouse.State} state The current mouse state.
   */
  this.onmousemove = null;

  /**
   * Presses the given mouse button, if it isn't already pressed. Valid
   * button values are "left", "middle", "right", "up", and "down".
   *
   * @private
   * @param {String} button The mouse button to press.
   */
  function press_button(button) {
    if (!guac_touchscreen.currentState[button]) {
      guac_touchscreen.currentState[button] = true;
      if (guac_touchscreen.onmousedown)
        guac_touchscreen.onmousedown(guac_touchscreen.currentState);
    }
  }

  /**
   * Releases the given mouse button, if it isn't already released. Valid
   * button values are "left", "middle", "right", "up", and "down".
   *
   * @private
   * @param {String} button The mouse button to release.
   */
  function release_button(button) {
    if (guac_touchscreen.currentState[button]) {
      guac_touchscreen.currentState[button] = false;
      if (guac_touchscreen.onmouseup)
        guac_touchscreen.onmouseup(guac_touchscreen.currentState);
    }
  }

  /**
   * Clicks (presses and releases) the given mouse button. Valid button
   * values are "left", "middle", "right", "up", and "down".
   *
   * @private
   * @param {String} button The mouse button to click.
   */
  function click_button(button) {
    press_button(button);
    release_button(button);
  }

  /**
   * Moves the mouse to the given coordinates. These coordinates must be
   * relative to the browser window, as they will be translated based on
   * the touch event target's location within the browser window.
   *
   * @private
   * @param {Number} x The X coordinate of the mouse pointer.
   * @param {Number} y The Y coordinate of the mouse pointer.
   */
  function move_mouse(x, y) {
    guac_touchscreen.currentState.fromClientPosition(element, x, y);
    if (guac_touchscreen.onmousemove)
      guac_touchscreen.onmousemove(guac_touchscreen.currentState);
  }

  /**
   * Returns whether the given touch event exceeds the movement threshold for
   * clicking, based on where the touch gesture began.
   *
   * @private
   * @param {TouchEvent} e The touch event to check.
   * @return {Boolean} true if the movement threshold is exceeded, false
   *                   otherwise.
   */
  function finger_moved(e) {
    var touch = e.touches[0] || e.changedTouches[0];
    var delta_x = touch.clientX - gesture_start_x;
    var delta_y = touch.clientY - gesture_start_y;
    return (
      Math.sqrt(delta_x * delta_x + delta_y * delta_y) >=
      guac_touchscreen.clickMoveThreshold
    );
  }

  /**
   * Begins a new gesture at the location of the first touch in the given
   * touch event.
   *
   * @private
   * @param {TouchEvent} e The touch event beginning this new gesture.
   */
  function begin_gesture(e) {
    var touch = e.touches[0];
    gesture_in_progress = true;
    gesture_start_x = touch.clientX;
    gesture_start_y = touch.clientY;
  }

  /**
   * End the current gesture entirely. Wait for all touches to be done before
   * resuming gesture detection.
   *
   * @private
   */
  function end_gesture() {
    window.clearTimeout(click_release_timeout);
    window.clearTimeout(long_press_timeout);
    gesture_in_progress = false;
  }

  element.addEventListener(
    "touchend",
    function (e) {
      // Do not handle if no gesture
      if (!gesture_in_progress) return;

      // Ignore if more than one touch
      if (e.touches.length !== 0 || e.changedTouches.length !== 1) {
        end_gesture();
        return;
      }

      // Long-press, if any, is over
      window.clearTimeout(long_press_timeout);

      // Always release mouse button if pressed
      release_button("left");

      // If finger hasn't moved enough to cancel the click
      if (!finger_moved(e)) {
        e.preventDefault();

        // If not yet pressed, press and start delay release
        if (!guac_touchscreen.currentState.left) {
          var touch = e.changedTouches[0];
          move_mouse(touch.clientX, touch.clientY);
          press_button("left");

          // Release button after a delay, if not canceled
          click_release_timeout = window.setTimeout(function () {
            release_button("left");
            end_gesture();
          }, guac_touchscreen.clickTimingThreshold);
        }
      } // end if finger not moved
    },
    false
  );

  element.addEventListener(
    "touchstart",
    function (e) {
      // Ignore if more than one touch
      if (e.touches.length !== 1) {
        end_gesture();
        return;
      }

      e.preventDefault();

      // New touch begins a new gesture
      begin_gesture(e);

      // Keep button pressed if tap after left click
      window.clearTimeout(click_release_timeout);

      // Click right button if this turns into a long-press
      long_press_timeout = window.setTimeout(function () {
        var touch = e.touches[0];
        move_mouse(touch.clientX, touch.clientY);
        click_button("right");
        end_gesture();
      }, guac_touchscreen.longPressThreshold);
    },
    false
  );

  element.addEventListener(
    "touchmove",
    function (e) {
      // Do not handle if no gesture
      if (!gesture_in_progress) return;

      // Cancel long press if finger moved
      if (finger_moved(e)) window.clearTimeout(long_press_timeout);

      // Ignore if more than one touch
      if (e.touches.length !== 1) {
        end_gesture();
        return;
      }

      // Update mouse position if dragging
      if (guac_touchscreen.currentState.left) {
        e.preventDefault();

        // Update state
        var touch = e.touches[0];
        move_mouse(touch.clientX, touch.clientY);
      }
    },
    false
  );
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The namespace used by the Guacamole JavaScript API. Absolutely all classes
 * defined by the Guacamole JavaScript API will be within this namespace.
 *
 * @namespace
 */
var Guacamole = Guacamole || {};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * An object used by the Guacamole client to house arbitrarily-many named
 * input and output streams.
 *
 * @constructor
 * @param {Guacamole.Client} client
 *     The client owning this object.
 *
 * @param {Number} index
 *     The index of this object.
 */
Guacamole.Object = function guacamoleObject(client, index) {
  /**
   * Reference to this Guacamole.Object.
   *
   * @private
   * @type {Guacamole.Object}
   */
  var guacObject = this;

  /**
   * Map of stream name to corresponding queue of callbacks. The queue of
   * callbacks is guaranteed to be in order of request.
   *
   * @private
   * @type {Object.<String, Function[]>}
   */
  var bodyCallbacks = {};

  /**
   * Removes and returns the callback at the head of the callback queue for
   * the stream having the given name. If no such callbacks exist, null is
   * returned.
   *
   * @private
   * @param {String} name
   *     The name of the stream to retrieve a callback for.
   *
   * @returns {Function}
   *     The next callback associated with the stream having the given name,
   *     or null if no such callback exists.
   */
  var dequeueBodyCallback = function dequeueBodyCallback(name) {
    // If no callbacks defined, simply return null
    var callbacks = bodyCallbacks[name];
    if (!callbacks) return null;

    // Otherwise, pull off first callback, deleting the queue if empty
    var callback = callbacks.shift();
    if (callbacks.length === 0) delete bodyCallbacks[name];

    // Return found callback
    return callback;
  };

  /**
   * Adds the given callback to the tail of the callback queue for the stream
   * having the given name.
   *
   * @private
   * @param {String} name
   *     The name of the stream to associate with the given callback.
   *
   * @param {Function} callback
   *     The callback to add to the queue of the stream with the given name.
   */
  var enqueueBodyCallback = function enqueueBodyCallback(name, callback) {
    // Get callback queue by name, creating first if necessary
    var callbacks = bodyCallbacks[name];
    if (!callbacks) {
      callbacks = [];
      bodyCallbacks[name] = callbacks;
    }

    // Add callback to end of queue
    callbacks.push(callback);
  };

  /**
   * The index of this object.
   *
   * @type {Number}
   */
  this.index = index;

  /**
   * Called when this object receives the body of a requested input stream.
   * By default, all objects will invoke the callbacks provided to their
   * requestInputStream() functions based on the name of the stream
   * requested. This behavior can be overridden by specifying a different
   * handler here.
   *
   * @event
   * @param {Guacamole.InputStream} inputStream
   *     The input stream of the received body.
   *
   * @param {String} mimetype
   *     The mimetype of the data being received.
   *
   * @param {String} name
   *     The name of the stream whose body has been received.
   */
  this.onbody = function defaultBodyHandler(inputStream, mimetype, name) {
    // Call queued callback for the received body, if any
    var callback = dequeueBodyCallback(name);
    if (callback) callback(inputStream, mimetype);
  };

  /**
   * Called when this object is being undefined. Once undefined, no further
   * communication involving this object may occur.
   *
   * @event
   */
  this.onundefine = null;

  /**
   * Requests read access to the input stream having the given name. If
   * successful, a new input stream will be created.
   *
   * @param {String} name
   *     The name of the input stream to request.
   *
   * @param {Function} [bodyCallback]
   *     The callback to invoke when the body of the requested input stream
   *     is received. This callback will be provided a Guacamole.InputStream
   *     and its mimetype as its two only arguments. If the onbody handler of
   *     this object is overridden, this callback will not be invoked.
   */
  this.requestInputStream = function requestInputStream(name, bodyCallback) {
    // Queue body callback if provided
    if (bodyCallback) enqueueBodyCallback(name, bodyCallback);

    // Send request for input stream
    client.requestObjectInputStream(guacObject.index, name);
  };

  /**
   * Creates a new output stream associated with this object and having the
   * given mimetype and name. The legality of a mimetype and name is dictated
   * by the object itself.
   *
   * @param {String} mimetype
   *     The mimetype of the data which will be sent to the output stream.
   *
   * @param {String} name
   *     The defined name of an output stream within this object.
   *
   * @returns {Guacamole.OutputStream}
   *     An output stream which will write blobs to the named output stream
   *     of this object.
   */
  this.createOutputStream = function createOutputStream(mimetype, name) {
    return client.createObjectOutputStream(guacObject.index, mimetype, name);
  };
};

/**
 * The reserved name denoting the root stream of any object. The contents of
 * the root stream MUST be a JSON map of stream name to mimetype.
 *
 * @constant
 * @type {String}
 */
Guacamole.Object.ROOT_STREAM = "/";

/**
 * The mimetype of a stream containing JSON which maps available stream names
 * to their corresponding mimetype. The root stream of a Guacamole.Object MUST
 * have this mimetype.
 *
 * @constant
 * @type {String}
 */
Guacamole.Object.STREAM_INDEX_MIMETYPE =
  "application/vnd.glyptodon.guacamole.stream-index+json";
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Dynamic on-screen keyboard. Given the layout object for an on-screen
 * keyboard, this object will construct a clickable on-screen keyboard with its
 * own key events.
 *
 * @constructor
 * @param {Guacamole.OnScreenKeyboard.Layout} layout
 *     The layout of the on-screen keyboard to display.
 */
Guacamole.OnScreenKeyboard = function (layout) {
  /**
   * Reference to this Guacamole.OnScreenKeyboard.
   *
   * @private
   * @type {Guacamole.OnScreenKeyboard}
   */
  var osk = this;

  /**
   * Map of currently-set modifiers to the keysym associated with their
   * original press. When the modifier is cleared, this keysym must be
   * released.
   *
   * @private
   * @type {Object.<String, Number>}
   */
  var modifierKeysyms = {};

  /**
   * Map of all key names to their current pressed states. If a key is not
   * pressed, it may not be in this map at all, but all pressed keys will
   * have a corresponding mapping to true.
   *
   * @private
   * @type {Object.<String, Boolean>}
   */
  var pressed = {};

  /**
   * All scalable elements which are part of the on-screen keyboard. Each
   * scalable element is carefully controlled to ensure the interface layout
   * and sizing remains constant, even on browsers that would otherwise
   * experience rounding error due to unit conversions.
   *
   * @private
   * @type {ScaledElement[]}
   */
  var scaledElements = [];

  /**
   * Adds a CSS class to an element.
   *
   * @private
   * @function
   * @param {Element} element
   *     The element to add a class to.
   *
   * @param {String} classname
   *     The name of the class to add.
   */
  var addClass = function addClass(element, classname) {
    // If classList supported, use that
    if (element.classList) element.classList.add(classname);
    // Otherwise, simply append the class
    else element.className += " " + classname;
  };

  /**
   * Removes a CSS class from an element.
   *
   * @private
   * @function
   * @param {Element} element
   *     The element to remove a class from.
   *
   * @param {String} classname
   *     The name of the class to remove.
   */
  var removeClass = function removeClass(element, classname) {
    // If classList supported, use that
    if (element.classList) element.classList.remove(classname);
    // Otherwise, manually filter out classes with given name
    else {
      element.className = element.className.replace(
        /([^ ]+)[ ]*/g,
        function removeMatchingClasses(match, testClassname) {
          // If same class, remove
          if (testClassname === classname) return "";

          // Otherwise, allow
          return match;
        }
      );
    }
  };

  /**
   * Counter of mouse events to ignore. This decremented by mousemove, and
   * while non-zero, mouse events will have no effect.
   *
   * @private
   * @type {Number}
   */
  var ignoreMouse = 0;

  /**
   * Ignores all pending mouse events when touch events are the apparent
   * source. Mouse events are ignored until at least touchMouseThreshold
   * mouse events occur without corresponding touch events.
   *
   * @private
   */
  var ignorePendingMouseEvents = function ignorePendingMouseEvents() {
    ignoreMouse = osk.touchMouseThreshold;
  };

  /**
   * An element whose dimensions are maintained according to an arbitrary
   * scale. The conversion factor for these arbitrary units to pixels is
   * provided later via a call to scale().
   *
   * @private
   * @constructor
   * @param {Element} element
   *     The element whose scale should be maintained.
   *
   * @param {Number} width
   *     The width of the element, in arbitrary units, relative to other
   *     ScaledElements.
   *
   * @param {Number} height
   *     The height of the element, in arbitrary units, relative to other
   *     ScaledElements.
   *
   * @param {Boolean} [scaleFont=false]
   *     Whether the line height and font size should be scaled as well.
   */
  var ScaledElement = function ScaledElement(
    element,
    width,
    height,
    scaleFont
  ) {
    /**
     * The width of this ScaledElement, in arbitrary units, relative to
     * other ScaledElements.
     *
     * @type {Number}
     */
    this.width = width;

    /**
     * The height of this ScaledElement, in arbitrary units, relative to
     * other ScaledElements.
     *
     * @type {Number}
     */
    this.height = height;

    /**
     * Resizes the associated element, updating its dimensions according to
     * the given pixels per unit.
     *
     * @param {Number} pixels
     *     The number of pixels to assign per arbitrary unit.
     */
    this.scale = function (pixels) {
      // Scale element width/height
      element.style.width = width * pixels + "px";
      element.style.height = height * pixels + "px";

      // Scale font, if requested
      if (scaleFont) {
        element.style.lineHeight = height * pixels + "px";
        element.style.fontSize = pixels + "px";
      }
    };
  };

  /**
   * Returns whether all modifiers having the given names are currently
   * active.
   *
   * @private
   * @param {String[]} names
   *     The names of all modifiers to test.
   *
   * @returns {Boolean}
   *     true if all specified modifiers are pressed, false otherwise.
   */
  var modifiersPressed = function modifiersPressed(names) {
    // If any required modifiers are not pressed, return false
    for (var i = 0; i < names.length; i++) {
      // Test whether current modifier is pressed
      var name = names[i];
      if (!(name in modifierKeysyms)) return false;
    }

    // Otherwise, all required modifiers are pressed
    return true;
  };

  /**
   * Returns the single matching Key object associated with the key of the
   * given name, where that Key object's requirements (such as pressed
   * modifiers) are all currently satisfied.
   *
   * @private
   * @param {String} keyName
   *     The name of the key to retrieve.
   *
   * @returns {Guacamole.OnScreenKeyboard.Key}
   *     The Key object associated with the given name, where that object's
   *     requirements are all currently satisfied, or null if no such Key
   *     can be found.
   */
  var getActiveKey = function getActiveKey(keyName) {
    // Get key array for given name
    var keys = osk.keys[keyName];
    if (!keys) return null;

    // Find last matching key
    for (var i = keys.length - 1; i >= 0; i--) {
      // Get candidate key
      var candidate = keys[i];

      // If all required modifiers are pressed, use that key
      if (modifiersPressed(candidate.requires)) return candidate;
    }

    // No valid key
    return null;
  };

  /**
   * Presses the key having the given name, updating the associated key
   * element with the "guac-keyboard-pressed" CSS class. If the key is
   * already pressed, this function has no effect.
   *
   * @private
   * @param {String} keyName
   *     The name of the key to press.
   *
   * @param {String} keyElement
   *     The element associated with the given key.
   */
  var press = function press(keyName, keyElement) {
    // Press key if not yet pressed
    if (!pressed[keyName]) {
      addClass(keyElement, "guac-keyboard-pressed");

      // Get current key based on modifier state
      var key = getActiveKey(keyName);

      // Update modifier state
      if (key.modifier) {
        // Construct classname for modifier
        var modifierClass =
          "guac-keyboard-modifier-" + getCSSName(key.modifier);

        // Retrieve originally-pressed keysym, if modifier was already pressed
        var originalKeysym = modifierKeysyms[key.modifier];

        // Activate modifier if not pressed
        if (!originalKeysym) {
          addClass(keyboard, modifierClass);
          modifierKeysyms[key.modifier] = key.keysym;

          // Send key event
          if (osk.onkeydown) osk.onkeydown(key.keysym);
        }

        // Deactivate if not pressed
        else {
          removeClass(keyboard, modifierClass);
          delete modifierKeysyms[key.modifier];

          // Send key event
          if (osk.onkeyup) osk.onkeyup(originalKeysym);
        }
      }

      // If not modifier, send key event now
      else if (osk.onkeydown) osk.onkeydown(key.keysym);

      // Mark key as pressed
      pressed[keyName] = true;
    }
  };

  /**
   * Releases the key having the given name, removing the
   * "guac-keyboard-pressed" CSS class from the associated element. If the
   * key is already released, this function has no effect.
   *
   * @private
   * @param {String} keyName
   *     The name of the key to release.
   *
   * @param {String} keyElement
   *     The element associated with the given key.
   */
  var release = function release(keyName, keyElement) {
    // Release key if currently pressed
    if (pressed[keyName]) {
      removeClass(keyElement, "guac-keyboard-pressed");

      // Get current key based on modifier state
      var key = getActiveKey(keyName);

      // Send key event if not a modifier key
      if (!key.modifier && osk.onkeyup) osk.onkeyup(key.keysym);

      // Mark key as released
      pressed[keyName] = false;
    }
  };

  // Create keyboard
  var keyboard = document.createElement("div");
  keyboard.className = "guac-keyboard";

  // Do not allow selection or mouse movement to propagate/register.
  keyboard.onselectstart =
    keyboard.onmousemove =
    keyboard.onmouseup =
    keyboard.onmousedown =
      function handleMouseEvents(e) {
        // If ignoring events, decrement counter
        if (ignoreMouse) ignoreMouse--;

        e.stopPropagation();
        return false;
      };

  /**
   * The number of mousemove events to require before re-enabling mouse
   * event handling after receiving a touch event.
   *
   * @type {Number}
   */
  this.touchMouseThreshold = 3;

  /**
   * Fired whenever the user presses a key on this Guacamole.OnScreenKeyboard.
   *
   * @event
   * @param {Number} keysym The keysym of the key being pressed.
   */
  this.onkeydown = null;

  /**
   * Fired whenever the user releases a key on this Guacamole.OnScreenKeyboard.
   *
   * @event
   * @param {Number} keysym The keysym of the key being released.
   */
  this.onkeyup = null;

  /**
   * The keyboard layout provided at time of construction.
   *
   * @type {Guacamole.OnScreenKeyboard.Layout}
   */
  this.layout = new Guacamole.OnScreenKeyboard.Layout(layout);

  /**
   * Returns the element containing the entire on-screen keyboard.
   * @returns {Element} The element containing the entire on-screen keyboard.
   */
  this.getElement = function () {
    return keyboard;
  };

  /**
   * Resizes all elements within this Guacamole.OnScreenKeyboard such that
   * the width is close to but does not exceed the specified width. The
   * height of the keyboard is determined based on the width.
   *
   * @param {Number} width The width to resize this Guacamole.OnScreenKeyboard
   *                       to, in pixels.
   */
  this.resize = function (width) {
    // Get pixel size of a unit
    var unit = Math.floor((width * 10) / osk.layout.width) / 10;

    // Resize all scaled elements
    for (var i = 0; i < scaledElements.length; i++) {
      var scaledElement = scaledElements[i];
      scaledElement.scale(unit);
    }
  };

  /**
   * Given the name of a key and its corresponding definition, which may be
   * an array of keys objects, a number (keysym), a string (key title), or a
   * single key object, returns an array of key objects, deriving any missing
   * properties as needed, and ensuring the key name is defined.
   *
   * @private
   * @param {String} name
   *     The name of the key being coerced into an array of Key objects.
   *
   * @param {Number|String|Guacamole.OnScreenKeyboard.Key|Guacamole.OnScreenKeyboard.Key[]} object
   *     The object defining the behavior of the key having the given name,
   *     which may be the title of the key (a string), the keysym (a number),
   *     a single Key object, or an array of Key objects.
   *
   * @returns {Guacamole.OnScreenKeyboard.Key[]}
   *     An array of all keys associated with the given name.
   */
  var asKeyArray = function asKeyArray(name, object) {
    // If already an array, just coerce into a true Key[]
    if (object instanceof Array) {
      var keys = [];
      for (var i = 0; i < object.length; i++) {
        keys.push(new Guacamole.OnScreenKeyboard.Key(object[i], name));
      }
      return keys;
    }

    // Derive key object from keysym if that's all we have
    if (typeof object === "number") {
      return [
        new Guacamole.OnScreenKeyboard.Key({
          name: name,
          keysym: object,
        }),
      ];
    }

    // Derive key object from title if that's all we have
    if (typeof object === "string") {
      return [
        new Guacamole.OnScreenKeyboard.Key({
          name: name,
          title: object,
        }),
      ];
    }

    // Otherwise, assume it's already a key object, just not an array
    return [new Guacamole.OnScreenKeyboard.Key(object, name)];
  };

  /**
   * Converts the rather forgiving key mapping allowed by
   * Guacamole.OnScreenKeyboard.Layout into a rigorous mapping of key name
   * to key definition, where the key definition is always an array of Key
   * objects.
   *
   * @private
   * @param {Object.<String, Number|String|Guacamole.OnScreenKeyboard.Key|Guacamole.OnScreenKeyboard.Key[]>} keys
   *     A mapping of key name to key definition, where the key definition is
   *     the title of the key (a string), the keysym (a number), a single
   *     Key object, or an array of Key objects.
   *
   * @returns {Object.<String, Guacamole.OnScreenKeyboard.Key[]>}
   *     A more-predictable mapping of key name to key definition, where the
   *     key definition is always simply an array of Key objects.
   */
  var getKeys = function getKeys(keys) {
    var keyArrays = {};

    // Coerce all keys into individual key arrays
    for (var name in layout.keys) {
      keyArrays[name] = asKeyArray(name, keys[name]);
    }

    return keyArrays;
  };

  /**
   * Map of all key names to their corresponding set of keys. Each key name
   * may correspond to multiple keys due to the effect of modifiers.
   *
   * @type {Object.<String, Guacamole.OnScreenKeyboard.Key[]>}
   */
  this.keys = getKeys(layout.keys);

  /**
   * Given an arbitrary string representing the name of some component of the
   * on-screen keyboard, returns a string formatted for use as a CSS class
   * name. The result will be lowercase. Word boundaries previously denoted
   * by CamelCase will be replaced by individual hyphens, as will all
   * contiguous non-alphanumeric characters.
   *
   * @private
   * @param {String} name
   *     An arbitrary string representing the name of some component of the
   *     on-screen keyboard.
   *
   * @returns {String}
   *     A string formatted for use as a CSS class name.
   */
  var getCSSName = function getCSSName(name) {
    // Convert name from possibly-CamelCase to hyphenated lowercase
    var cssName = name
      .replace(/([a-z])([A-Z])/g, "$1-$2")
      .replace(/[^A-Za-z0-9]+/g, "-")
      .toLowerCase();

    return cssName;
  };

  /**
   * Appends DOM elements to the given element as dictated by the layout
   * structure object provided. If a name is provided, an additional CSS
   * class, prepended with "guac-keyboard-", will be added to the top-level
   * element.
   *
   * If the layout structure object is an array, all elements within that
   * array will be recursively appended as children of a group, and the
   * top-level element will be given the CSS class "guac-keyboard-group".
   *
   * If the layout structure object is an object, all properties within that
   * object will be recursively appended as children of a group, and the
   * top-level element will be given the CSS class "guac-keyboard-group". The
   * name of each property will be applied as the name of each child object
   * for the sake of CSS. Each property will be added in sorted order.
   *
   * If the layout structure object is a string, the key having that name
   * will be appended. The key will be given the CSS class
   * "guac-keyboard-key" and "guac-keyboard-key-NAME", where NAME is the name
   * of the key. If the name of the key is a single character, this will
   * first be transformed into the C-style hexadecimal literal for the
   * Unicode codepoint of that character. For example, the key "A" would
   * become "guac-keyboard-key-0x41".
   *
   * If the layout structure object is a number, a gap of that size will be
   * inserted. The gap will be given the CSS class "guac-keyboard-gap", and
   * will be scaled according to the same size units as each key.
   *
   * @private
   * @param {Element} element
   *     The element to append elements to.
   *
   * @param {Array|Object|String|Number} object
   *     The layout structure object to use when constructing the elements to
   *     append.
   *
   * @param {String} [name]
   *     The name of the top-level element being appended, if any.
   */
  var appendElements = function appendElements(element, object, name) {
    var i;

    // Create div which will become the group or key
    var div = document.createElement("div");

    // Add class based on name, if name given
    if (name) addClass(div, "guac-keyboard-" + getCSSName(name));

    // If an array, append each element
    if (object instanceof Array) {
      // Add group class
      addClass(div, "guac-keyboard-group");

      // Append all elements of array
      for (i = 0; i < object.length; i++) appendElements(div, object[i]);
    }

    // If an object, append each property value
    else if (object instanceof Object) {
      // Add group class
      addClass(div, "guac-keyboard-group");

      // Append all children, sorted by name
      var names = Object.keys(object).sort();
      for (i = 0; i < names.length; i++) {
        var name = names[i];
        appendElements(div, object[name], name);
      }
    }

    // If a number, create as a gap
    else if (typeof object === "number") {
      // Add gap class
      addClass(div, "guac-keyboard-gap");

      // Maintain scale
      scaledElements.push(new ScaledElement(div, object, object));
    }

    // If a string, create as a key
    else if (typeof object === "string") {
      // If key name is only one character, use codepoint for name
      var keyName = object;
      if (keyName.length === 1)
        keyName = "0x" + keyName.charCodeAt(0).toString(16);

      // Add key container class
      addClass(div, "guac-keyboard-key-container");

      // Create key element which will contain all possible caps
      var keyElement = document.createElement("div");
      keyElement.className =
        "guac-keyboard-key " + "guac-keyboard-key-" + getCSSName(keyName);

      // Add all associated keys as caps within DOM
      var keys = osk.keys[object];
      if (keys) {
        for (i = 0; i < keys.length; i++) {
          // Get current key
          var key = keys[i];

          // Create cap element for key
          var capElement = document.createElement("div");
          capElement.className = "guac-keyboard-cap";
          capElement.textContent = key.title;

          // Add classes for any requirements
          for (var j = 0; j < key.requires.length; j++) {
            var requirement = key.requires[j];
            addClass(
              capElement,
              "guac-keyboard-requires-" + getCSSName(requirement)
            );
            addClass(
              keyElement,
              "guac-keyboard-uses-" + getCSSName(requirement)
            );
          }

          // Add cap to key within DOM
          keyElement.appendChild(capElement);
        }
      }

      // Add key to DOM, maintain scale
      div.appendChild(keyElement);
      scaledElements.push(
        new ScaledElement(div, osk.layout.keyWidths[object] || 1, 1, true)
      );

      /**
       * Handles a touch event which results in the pressing of an OSK
       * key. Touch events will result in mouse events being ignored for
       * touchMouseThreshold events.
       *
       * @private
       * @param {TouchEvent} e
       *     The touch event being handled.
       */
      var touchPress = function touchPress(e) {
        e.preventDefault();
        ignoreMouse = osk.touchMouseThreshold;
        press(object, keyElement);
      };

      /**
       * Handles a touch event which results in the release of an OSK
       * key. Touch events will result in mouse events being ignored for
       * touchMouseThreshold events.
       *
       * @private
       * @param {TouchEvent} e
       *     The touch event being handled.
       */
      var touchRelease = function touchRelease(e) {
        e.preventDefault();
        ignoreMouse = osk.touchMouseThreshold;
        release(object, keyElement);
      };

      /**
       * Handles a mouse event which results in the pressing of an OSK
       * key. If mouse events are currently being ignored, this handler
       * does nothing.
       *
       * @private
       * @param {MouseEvent} e
       *     The touch event being handled.
       */
      var mousePress = function mousePress(e) {
        e.preventDefault();
        if (ignoreMouse === 0) press(object, keyElement);
      };

      /**
       * Handles a mouse event which results in the release of an OSK
       * key. If mouse events are currently being ignored, this handler
       * does nothing.
       *
       * @private
       * @param {MouseEvent} e
       *     The touch event being handled.
       */
      var mouseRelease = function mouseRelease(e) {
        e.preventDefault();
        if (ignoreMouse === 0) release(object, keyElement);
      };

      // Handle touch events on key
      keyElement.addEventListener("touchstart", touchPress, true);
      keyElement.addEventListener("touchend", touchRelease, true);

      // Handle mouse events on key
      keyElement.addEventListener("mousedown", mousePress, true);
      keyElement.addEventListener("mouseup", mouseRelease, true);
      keyElement.addEventListener("mouseout", mouseRelease, true);
    } // end if object is key name

    // Add newly-created group/key
    element.appendChild(div);
  };

  // Create keyboard layout in DOM
  appendElements(keyboard, layout.layout);
};

/**
 * Represents an entire on-screen keyboard layout, including all available
 * keys, their behaviors, and their relative position and sizing.
 *
 * @constructor
 * @param {Guacamole.OnScreenKeyboard.Layout|Object} template
 *     The object whose identically-named properties will be used to initialize
 *     the properties of this layout.
 */
Guacamole.OnScreenKeyboard.Layout = function (template) {
  /**
   * The language of keyboard layout, such as "en_US". This property is for
   * informational purposes only, but it is recommend to conform to the
   * [language code]_[country code] format.
   *
   * @type {String}
   */
  this.language = template.language;

  /**
   * The type of keyboard layout, such as "qwerty". This property is for
   * informational purposes only, and does not conform to any standard.
   *
   * @type {String}
   */
  this.type = template.type;

  /**
   * Map of key name to corresponding keysym, title, or key object. If only
   * the keysym or title is provided, the key object will be created
   * implicitly. In all cases, the name property of the key object will be
   * taken from the name given in the mapping.
   *
   * @type {Object.<String, Number|String|Guacamole.OnScreenKeyboard.Key|Guacamole.OnScreenKeyboard.Key[]>}
   */
  this.keys = template.keys;

  /**
   * Arbitrarily nested, arbitrarily grouped key names. The contents of the
   * layout will be traversed to produce an identically-nested grouping of
   * keys in the DOM tree. All strings will be transformed into their
   * corresponding sets of keys, while all objects and arrays will be
   * transformed into named groups and anonymous groups respectively. Any
   * numbers present will be transformed into gaps of that size, scaled
   * according to the same units as each key.
   *
   * @type {Object}
   */
  this.layout = template.layout;

  /**
   * The width of the entire keyboard, in arbitrary units. The width of each
   * key is relative to this width, as both width values are assumed to be in
   * the same units. The conversion factor between these units and pixels is
   * derived later via a call to resize() on the Guacamole.OnScreenKeyboard.
   *
   * @type {Number}
   */
  this.width = template.width;

  /**
   * The width of each key, in arbitrary units, relative to other keys in
   * this layout. The true pixel size of each key will be determined by the
   * overall size of the keyboard. If not defined here, the width of each
   * key will default to 1.
   *
   * @type {Object.<String, Number>}
   */
  this.keyWidths = template.keyWidths || {};
};

/**
 * Represents a single key, or a single possible behavior of a key. Each key
 * on the on-screen keyboard must have at least one associated
 * Guacamole.OnScreenKeyboard.Key, whether that key is explicitly defined or
 * implied, and may have multiple Guacamole.OnScreenKeyboard.Key if behavior
 * depends on modifier states.
 *
 * @constructor
 * @param {Guacamole.OnScreenKeyboard.Key|Object} template
 *     The object whose identically-named properties will be used to initialize
 *     the properties of this key.
 *
 * @param {String} [name]
 *     The name to use instead of any name provided within the template, if
 *     any. If omitted, the name within the template will be used, assuming the
 *     template contains a name.
 */
Guacamole.OnScreenKeyboard.Key = function (template, name) {
  /**
   * The unique name identifying this key within the keyboard layout.
   *
   * @type {String}
   */
  this.name = name || template.name;

  /**
   * The human-readable title that will be displayed to the user within the
   * key. If not provided, this will be derived from the key name.
   *
   * @type {String}
   */
  this.title = template.title || this.name;

  /**
   * The keysym to be pressed/released when this key is pressed/released. If
   * not provided, this will be derived from the title if the title is a
   * single character.
   *
   * @type {Number}
   */
  this.keysym =
    template.keysym ||
    (function deriveKeysym(title) {
      // Do not derive keysym if title is not exactly one character
      if (!title || title.length !== 1) return null;

      // For characters between U+0000 and U+00FF, the keysym is the codepoint
      var charCode = title.charCodeAt(0);
      if (charCode >= 0x0000 && charCode <= 0x00ff) return charCode;

      // For characters between U+0100 and U+10FFFF, the keysym is the codepoint or'd with 0x01000000
      if (charCode >= 0x0100 && charCode <= 0x10ffff)
        return 0x01000000 | charCode;

      // Unable to derive keysym
      return null;
    })(this.title);

  /**
   * The name of the modifier set when the key is pressed and cleared when
   * this key is released, if any. The names of modifiers are distinct from
   * the names of keys; both the "RightShift" and "LeftShift" keys may set
   * the "shift" modifier, for example. By default, the key will affect no
   * modifiers.
   *
   * @type {String}
   */
  this.modifier = template.modifier;

  /**
   * An array containing the names of each modifier required for this key to
   * have an effect. For example, a lowercase letter may require nothing,
   * while an uppercase letter would require "shift", assuming the Shift key
   * is named "shift" within the layout. By default, the key will require
   * no modifiers.
   *
   * @type {String[]}
   */
  this.requires = template.requires || [];
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Abstract stream which can receive data.
 *
 * @constructor
 * @param {Guacamole.Client} client The client owning this stream.
 * @param {Number} index The index of this stream.
 */
Guacamole.OutputStream = function (client, index) {
  /**
   * Reference to this stream.
   * @private
   */
  var guac_stream = this;

  /**
   * The index of this stream.
   * @type {Number}
   */
  this.index = index;

  /**
   * Fired whenever an acknowledgement is received from the server, indicating
   * that a stream operation has completed, or an error has occurred.
   *
   * @event
   * @param {Guacamole.Status} status The status of the operation.
   */
  this.onack = null;

  /**
   * Writes the given base64-encoded data to this stream as a blob.
   *
   * @param {String} data The base64-encoded data to send.
   */
  this.sendBlob = function (data) {
    client.sendBlob(guac_stream.index, data);
  };

  /**
   * Closes this stream.
   */
  this.sendEnd = function () {
    client.endStream(guac_stream.index);
  };
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Simple Guacamole protocol parser that invokes an oninstruction event when
 * full instructions are available from data received via receive().
 *
 * @constructor
 */
Guacamole.Parser = function () {
  /**
   * Reference to this parser.
   * @private
   */
  var parser = this;

  /**
   * Current buffer of received data. This buffer grows until a full
   * element is available. After a full element is available, that element
   * is flushed into the element buffer.
   *
   * @private
   */
  var buffer = "";

  /**
   * Buffer of all received, complete elements. After an entire instruction
   * is read, this buffer is flushed, and a new instruction begins.
   *
   * @private
   */
  var element_buffer = [];

  // The location of the last element's terminator
  var element_end = -1;

  // Where to start the next length search or the next element
  var start_index = 0;

  /**
   * Appends the given instruction data packet to the internal buffer of
   * this Guacamole.Parser, executing all completed instructions at
   * the beginning of this buffer, if any.
   *
   * @param {String} packet The instruction data to receive.
   */
  this.receive = function (packet) {
    // Truncate buffer as necessary
    if (start_index > 4096 && element_end >= start_index) {
      buffer = buffer.substring(start_index);

      // Reset parse relative to truncation
      element_end -= start_index;
      start_index = 0;
    }

    // Append data to buffer
    buffer += packet;

    // While search is within currently received data
    while (element_end < buffer.length) {
      // If we are waiting for element data
      if (element_end >= start_index) {
        // We now have enough data for the element. Parse.
        var element = buffer.substring(start_index, element_end);
        var terminator = buffer.substring(element_end, element_end + 1);

        // Add element to array
        element_buffer.push(element);

        // If last element, handle instruction
        if (terminator == ";") {
          // Get opcode
          var opcode = element_buffer.shift();

          // Call instruction handler.
          if (parser.oninstruction != null)
            parser.oninstruction(opcode, element_buffer);

          // Clear elements
          element_buffer.length = 0;
        } else if (terminator != ",") throw new Error("Illegal terminator.");

        // Start searching for length at character after
        // element terminator
        start_index = element_end + 1;
      }

      // Search for end of length
      var length_end = buffer.indexOf(".", start_index);
      if (length_end != -1) {
        // Parse length
        var length = parseInt(buffer.substring(element_end + 1, length_end));
        if (isNaN(length))
          throw new Error("Non-numeric character in element length.");

        // Calculate start of element
        start_index = length_end + 1;

        // Calculate location of element terminator
        element_end = start_index + length;
      }

      // If no period yet, continue search when more data
      // is received
      else {
        start_index = buffer.length;
        break;
      }
    } // end parse loop
  };

  /**
   * Fired once for every complete Guacamole instruction received, in order.
   *
   * @event
   * @param {String} opcode The Guacamole instruction opcode.
   * @param {Array} parameters The parameters provided for the instruction,
   *                           if any.
   */
  this.oninstruction = null;
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A description of the format of raw PCM audio, such as that used by
 * Guacamole.RawAudioPlayer and Guacamole.RawAudioRecorder. This object
 * describes the number of bytes per sample, the number of channels, and the
 * overall sample rate.
 *
 * @constructor
 * @param {Guacamole.RawAudioFormat|Object} template
 *     The object whose properties should be copied into the corresponding
 *     properties of the new Guacamole.RawAudioFormat.
 */
Guacamole.RawAudioFormat = function RawAudioFormat(template) {
  /**
   * The number of bytes in each sample of audio data. This value is
   * independent of the number of channels.
   *
   * @type {Number}
   */
  this.bytesPerSample = template.bytesPerSample;

  /**
   * The number of audio channels (ie: 1 for mono, 2 for stereo).
   *
   * @type {Number}
   */
  this.channels = template.channels;

  /**
   * The number of samples per second, per channel.
   *
   * @type {Number}
   */
  this.rate = template.rate;
};

/**
 * Parses the given mimetype, returning a new Guacamole.RawAudioFormat
 * which describes the type of raw audio data represented by that mimetype. If
 * the mimetype is not a supported raw audio data mimetype, null is returned.
 *
 * @param {String} mimetype
 *     The audio mimetype to parse.
 *
 * @returns {Guacamole.RawAudioFormat}
 *     A new Guacamole.RawAudioFormat which describes the type of raw
 *     audio data represented by the given mimetype, or null if the given
 *     mimetype is not supported.
 */
Guacamole.RawAudioFormat.parse = function parseFormat(mimetype) {
  var bytesPerSample;

  // Rate is absolutely required - if null is still present later, the
  // mimetype must not be supported
  var rate = null;

  // Default for both "audio/L8" and "audio/L16" is one channel
  var channels = 1;

  // "audio/L8" has one byte per sample
  if (mimetype.substring(0, 9) === "audio/L8;") {
    mimetype = mimetype.substring(9);
    bytesPerSample = 1;
  }

  // "audio/L16" has two bytes per sample
  else if (mimetype.substring(0, 10) === "audio/L16;") {
    mimetype = mimetype.substring(10);
    bytesPerSample = 2;
  }

  // All other types are unsupported
  else return null;

  // Parse all parameters
  var parameters = mimetype.split(",");
  for (var i = 0; i < parameters.length; i++) {
    var parameter = parameters[i];

    // All parameters must have an equals sign separating name from value
    var equals = parameter.indexOf("=");
    if (equals === -1) return null;

    // Parse name and value from parameter string
    var name = parameter.substring(0, equals);
    var value = parameter.substring(equals + 1);

    // Handle each supported parameter
    switch (name) {
      // Number of audio channels
      case "channels":
        channels = parseInt(value);
        break;

      // Sample rate
      case "rate":
        rate = parseInt(value);
        break;

      // All other parameters are unsupported
      default:
        return null;
    }
  }

  // The rate parameter is required
  if (rate === null) return null;

  // Return parsed format details
  return new Guacamole.RawAudioFormat({
    bytesPerSample: bytesPerSample,
    channels: channels,
    rate: rate,
  });
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A recording of a Guacamole session. Given a {@link Guacamole.Tunnel}, the
 * Guacamole.SessionRecording automatically handles incoming Guacamole
 * instructions, storing them for playback. Playback of the recording may be
 * controlled through function calls to the Guacamole.SessionRecording, even
 * while the recording has not yet finished being created or downloaded.
 *
 * @constructor
 * @param {Guacamole.Tunnel} tunnel
 *     The Guacamole.Tunnel from which the instructions of the recording should
 *     be read.
 */
Guacamole.SessionRecording = function SessionRecording(tunnel) {
  /**
   * Reference to this Guacamole.SessionRecording.
   *
   * @private
   * @type {Guacamole.SessionRecording}
   */
  var recording = this;

  /**
   * The minimum number of characters which must have been read between
   * keyframes.
   *
   * @private
   * @constant
   * @type {Number}
   */
  var KEYFRAME_CHAR_INTERVAL = 16384;

  /**
   * The minimum number of milliseconds which must elapse between keyframes.
   *
   * @private
   * @constant
   * @type {Number}
   */
  var KEYFRAME_TIME_INTERVAL = 5000;

  /**
   * The maximum amount of time to spend in any particular seek operation
   * before returning control to the main thread, in milliseconds. Seek
   * operations exceeding this amount of time will proceed asynchronously.
   *
   * @private
   * @constant
   * @type {Number}
   */
  var MAXIMUM_SEEK_TIME = 5;

  /**
   * All frames parsed from the provided tunnel.
   *
   * @private
   * @type {Guacamole.SessionRecording._Frame[]}
   */
  var frames = [];

  /**
   * All instructions which have been read since the last frame was added to
   * the frames array.
   *
   * @private
   * @type {Guacamole.SessionRecording._Frame.Instruction[]}
   */
  var instructions = [];

  /**
   * The approximate number of characters which have been read from the
   * provided tunnel since the last frame was flagged for use as a keyframe.
   *
   * @private
   * @type {Number}
   */
  var charactersSinceLastKeyframe = 0;

  /**
   * The timestamp of the last frame which was flagged for use as a keyframe.
   * If no timestamp has yet been flagged, this will be 0.
   *
   * @private
   * @type {Number}
   */
  var lastKeyframeTimestamp = 0;

  /**
   * Tunnel which feeds arbitrary instructions to the client used by this
   * Guacamole.SessionRecording for playback of the session recording.
   *
   * @private
   * @type {Guacamole.SessionRecording._PlaybackTunnel}
   */
  var playbackTunnel = new Guacamole.SessionRecording._PlaybackTunnel();

  /**
   * Guacamole.Client instance used for visible playback of the session
   * recording.
   *
   * @private
   * @type {Guacamole.Client}
   */
  var playbackClient = new Guacamole.Client(playbackTunnel);

  /**
   * The current frame rendered within the playback client. If no frame is
   * yet rendered, this will be -1.
   *
   * @private
   * @type {Number}
   */
  var currentFrame = -1;

  /**
   * The timestamp of the frame when playback began, in milliseconds. If
   * playback is not in progress, this will be null.
   *
   * @private
   * @type {Number}
   */
  var startVideoTimestamp = null;

  /**
   * The real-world timestamp when playback began, in milliseconds. If
   * playback is not in progress, this will be null.
   *
   * @private
   * @type {Number}
   */
  var startRealTimestamp = null;

  /**
   * The ID of the timeout which will continue the in-progress seek
   * operation. If no seek operation is in progress, the ID stored here (if
   * any) will not be valid.
   *
   * @private
   * @type {Number}
   */
  var seekTimeout = null;

  // Start playback client connected
  playbackClient.connect();

  // Hide cursor unless mouse position is received
  playbackClient.getDisplay().showCursor(false);

  // Read instructions from provided tunnel, extracting each frame
  tunnel.oninstruction = function handleInstruction(opcode, args) {
    // Store opcode and arguments for received instruction
    var instruction = new Guacamole.SessionRecording._Frame.Instruction(
      opcode,
      args.slice()
    );
    instructions.push(instruction);
    charactersSinceLastKeyframe += instruction.getSize();

    // Once a sync is received, store all instructions since the last
    // frame as a new frame
    if (opcode === "sync") {
      // Parse frame timestamp from sync instruction
      var timestamp = parseInt(args[0]);

      // Add a new frame containing the instructions read since last frame
      var frame = new Guacamole.SessionRecording._Frame(
        timestamp,
        instructions
      );
      frames.push(frame);

      // This frame should eventually become a keyframe if enough data
      // has been processed and enough recording time has elapsed, or if
      // this is the absolute first frame
      if (
        frames.length === 1 ||
        (charactersSinceLastKeyframe >= KEYFRAME_CHAR_INTERVAL &&
          timestamp - lastKeyframeTimestamp >= KEYFRAME_TIME_INTERVAL)
      ) {
        frame.keyframe = true;
        lastKeyframeTimestamp = timestamp;
        charactersSinceLastKeyframe = 0;
      }

      // Clear set of instructions in preparation for next frame
      instructions = [];

      // Notify that additional content is available
      if (recording.onprogress) recording.onprogress(recording.getDuration());
    }
  };

  /**
   * Converts the given absolute timestamp to a timestamp which is relative
   * to the first frame in the recording.
   *
   * @private
   * @param {Number} timestamp
   *     The timestamp to convert to a relative timestamp.
   *
   * @returns {Number}
   *     The difference in milliseconds between the given timestamp and the
   *     first frame of the recording, or zero if no frames yet exist.
   */
  var toRelativeTimestamp = function toRelativeTimestamp(timestamp) {
    // If no frames yet exist, all timestamps are zero
    if (frames.length === 0) return 0;

    // Calculate timestamp relative to first frame
    return timestamp - frames[0].timestamp;
  };

  /**
   * Searches through the given region of frames for the frame having a
   * relative timestamp closest to the timestamp given.
   *
   * @private
   * @param {Number} minIndex
   *     The index of the first frame in the region (the frame having the
   *     smallest timestamp).
   *
   * @param {Number} maxIndex
   *     The index of the last frame in the region (the frame having the
   *     largest timestamp).
   *
   * @param {Number} timestamp
   *     The relative timestamp to search for, where zero denotes the first
   *     frame in the recording.
   *
   * @returns {Number}
   *     The index of the frame having a relative timestamp closest to the
   *     given value.
   */
  var findFrame = function findFrame(minIndex, maxIndex, timestamp) {
    // Do not search if the region contains only one element
    if (minIndex === maxIndex) return minIndex;

    // Split search region into two halves
    var midIndex = Math.floor((minIndex + maxIndex) / 2);
    var midTimestamp = toRelativeTimestamp(frames[midIndex].timestamp);

    // If timestamp is within lesser half, search again within that half
    if (timestamp < midTimestamp && midIndex > minIndex)
      return findFrame(minIndex, midIndex - 1, timestamp);

    // If timestamp is within greater half, search again within that half
    if (timestamp > midTimestamp && midIndex < maxIndex)
      return findFrame(midIndex + 1, maxIndex, timestamp);

    // Otherwise, we lucked out and found a frame with exactly the
    // desired timestamp
    return midIndex;
  };

  /**
   * Replays the instructions associated with the given frame, sending those
   * instructions to the playback client.
   *
   * @private
   * @param {Number} index
   *     The index of the frame within the frames array which should be
   *     replayed.
   */
  var replayFrame = function replayFrame(index) {
    var frame = frames[index];

    // Replay all instructions within the retrieved frame
    for (var i = 0; i < frame.instructions.length; i++) {
      var instruction = frame.instructions[i];
      playbackTunnel.receiveInstruction(instruction.opcode, instruction.args);
    }

    // Store client state if frame is flagged as a keyframe
    if (frame.keyframe && !frame.clientState) {
      playbackClient.exportState(function storeClientState(state) {
        frame.clientState = state;
      });
    }
  };

  /**
   * Moves the playback position to the given frame, resetting the state of
   * the playback client and replaying frames as necessary. The seek
   * operation will proceed asynchronously. If a seek operation is already in
   * progress, that seek is first aborted. The progress of the seek operation
   * can be observed through the onseek handler and the provided callback.
   *
   * @private
   * @param {Number} index
   *     The index of the frame which should become the new playback
   *     position.
   *
   * @param {function} callback
   *     The callback to invoke once the seek operation has completed.
   *
   * @param {Number} [delay=0]
   *     The number of milliseconds that the seek operation should be
   *     scheduled to take.
   */
  var seekToFrame = function seekToFrame(index, callback, delay) {
    // Abort any in-progress seek
    abortSeek();

    // Replay frames asynchronously
    seekTimeout = window.setTimeout(function continueSeek() {
      var startIndex;

      // Back up until startIndex represents current state
      for (startIndex = index; startIndex >= 0; startIndex--) {
        var frame = frames[startIndex];

        // If we've reached the current frame, startIndex represents
        // current state by definition
        if (startIndex === currentFrame) break;

        // If frame has associated absolute state, make that frame the
        // current state
        if (frame.clientState) {
          playbackClient.importState(frame.clientState);
          break;
        }
      }

      // Advance to frame index after current state
      startIndex++;

      var startTime = new Date().getTime();

      // Replay any applicable incremental frames
      for (; startIndex <= index; startIndex++) {
        // Stop seeking if the operation is taking too long
        var currentTime = new Date().getTime();
        if (currentTime - startTime >= MAXIMUM_SEEK_TIME) break;

        replayFrame(startIndex);
      }

      // Current frame is now at requested index
      currentFrame = startIndex - 1;

      // Notify of changes in position
      if (recording.onseek) recording.onseek(recording.getPosition());

      // If the seek operation has not yet completed, schedule continuation
      if (currentFrame !== index)
        seekToFrame(
          index,
          callback,
          Math.max(delay - (new Date().getTime() - startTime), 0)
        );
      // Notify that the requested seek has completed
      else callback();
    }, delay || 0);
  };

  /**
   * Aborts the seek operation currently in progress, if any. If no seek
   * operation is in progress, this function has no effect.
   *
   * @private
   */
  var abortSeek = function abortSeek() {
    window.clearTimeout(seekTimeout);
  };

  /**
   * Advances playback to the next frame in the frames array and schedules
   * playback of the frame following that frame based on their associated
   * timestamps. If no frames exist after the next frame, playback is paused.
   *
   * @private
   */
  var continuePlayback = function continuePlayback() {
    // If frames remain after advancing, schedule next frame
    if (currentFrame + 1 < frames.length) {
      // Pull the upcoming frame
      var next = frames[currentFrame + 1];

      // Calculate the real timestamp corresponding to when the next
      // frame begins
      var nextRealTimestamp =
        next.timestamp - startVideoTimestamp + startRealTimestamp;

      // Calculate the relative delay between the current time and
      // the next frame start
      var delay = Math.max(nextRealTimestamp - new Date().getTime(), 0);

      // Advance to next frame after enough time has elapsed
      seekToFrame(
        currentFrame + 1,
        function frameDelayElapsed() {
          continuePlayback();
        },
        delay
      );
    }

    // Otherwise stop playback
    else recording.pause();
  };

  /**
   * Fired when new frames have become available while the recording is
   * being downloaded.
   *
   * @event
   * @param {Number} duration
   *     The new duration of the recording, in milliseconds.
   */
  this.onprogress = null;

  /**
   * Fired whenever playback of the recording has started.
   *
   * @event
   */
  this.onplay = null;

  /**
   * Fired whenever playback of the recording has been paused. This may
   * happen when playback is explicitly paused with a call to pause(), or
   * when playback is implicitly paused due to reaching the end of the
   * recording.
   *
   * @event
   */
  this.onpause = null;

  /**
   * Fired whenever the playback position within the recording changes.
   *
   * @event
   * @param {Number} position
   *     The new position within the recording, in milliseconds.
   */
  this.onseek = null;

  /**
   * Connects the underlying tunnel, beginning download of the Guacamole
   * session. Playback of the Guacamole session cannot occur until at least
   * one frame worth of instructions has been downloaded.
   *
   * @param {String} data
   *     The data to send to the tunnel when connecting.
   */
  this.connect = function connect(data) {
    tunnel.connect(data);
  };

  /**
   * Disconnects the underlying tunnel, stopping further download of the
   * Guacamole session.
   */
  this.disconnect = function disconnect() {
    tunnel.disconnect();
  };

  /**
   * Returns the underlying display of the Guacamole.Client used by this
   * Guacamole.SessionRecording for playback. The display contains an Element
   * which can be added to the DOM, causing the display (and thus playback of
   * the recording) to become visible.
   *
   * @return {Guacamole.Display}
   *     The underlying display of the Guacamole.Client used by this
   *     Guacamole.SessionRecording for playback.
   */
  this.getDisplay = function getDisplay() {
    return playbackClient.getDisplay();
  };

  /**
   * Returns whether playback is currently in progress.
   *
   * @returns {Boolean}
   *     true if playback is currently in progress, false otherwise.
   */
  this.isPlaying = function isPlaying() {
    return !!startVideoTimestamp;
  };

  /**
   * Returns the current playback position within the recording, in
   * milliseconds, where zero is the start of the recording.
   *
   * @returns {Number}
   *     The current playback position within the recording, in milliseconds.
   */
  this.getPosition = function getPosition() {
    // Position is simply zero if playback has not started at all
    if (currentFrame === -1) return 0;

    // Return current position as a millisecond timestamp relative to the
    // start of the recording
    return toRelativeTimestamp(frames[currentFrame].timestamp);
  };

  /**
   * Returns the duration of this recording, in milliseconds. If the
   * recording is still being downloaded, this value will gradually increase.
   *
   * @returns {Number}
   *     The duration of this recording, in milliseconds.
   */
  this.getDuration = function getDuration() {
    // If no frames yet exist, duration is zero
    if (frames.length === 0) return 0;

    // Recording duration is simply the timestamp of the last frame
    return toRelativeTimestamp(frames[frames.length - 1].timestamp);
  };

  /**
   * Begins continuous playback of the recording downloaded thus far.
   * Playback of the recording will continue until pause() is invoked or
   * until no further frames exist. Playback is initially paused when a
   * Guacamole.SessionRecording is created, and must be explicitly started
   * through a call to this function. If playback is already in progress,
   * this function has no effect. If a seek operation is in progress,
   * playback resumes at the current position, and the seek is aborted as if
   * completed.
   */
  this.play = function play() {
    // If playback is not already in progress and frames remain,
    // begin playback
    if (!recording.isPlaying() && currentFrame + 1 < frames.length) {
      // Notify that playback is starting
      if (recording.onplay) recording.onplay();

      // Store timestamp of playback start for relative scheduling of
      // future frames
      var next = frames[currentFrame + 1];
      startVideoTimestamp = next.timestamp;
      startRealTimestamp = new Date().getTime();

      // Begin playback of video
      continuePlayback();
    }
  };

  /**
   * Seeks to the given position within the recording. If the recording is
   * currently being played back, playback will continue after the seek is
   * performed. If the recording is currently paused, playback will be
   * paused after the seek is performed. If a seek operation is already in
   * progress, that seek is first aborted. The seek operation will proceed
   * asynchronously.
   *
   * @param {Number} position
   *     The position within the recording to seek to, in milliseconds.
   *
   * @param {function} [callback]
   *     The callback to invoke once the seek operation has completed.
   */
  this.seek = function seek(position, callback) {
    // Do not seek if no frames exist
    if (frames.length === 0) return;

    // Pause playback, preserving playback state
    var originallyPlaying = recording.isPlaying();
    recording.pause();

    // Perform seek
    seekToFrame(
      findFrame(0, frames.length - 1, position),
      function restorePlaybackState() {
        // Restore playback state
        if (originallyPlaying) recording.play();

        // Notify that seek has completed
        if (callback) callback();
      }
    );
  };

  /**
   * Pauses playback of the recording, if playback is currently in progress.
   * If playback is not in progress, this function has no effect. If a seek
   * operation is in progress, the seek is aborted. Playback is initially
   * paused when a Guacamole.SessionRecording is created, and must be
   * explicitly started through a call to play().
   */
  this.pause = function pause() {
    // Abort any in-progress seek / playback
    abortSeek();

    // Stop playback only if playback is in progress
    if (recording.isPlaying()) {
      // Notify that playback is stopping
      if (recording.onpause) recording.onpause();

      // Playback is stopped
      startVideoTimestamp = null;
      startRealTimestamp = null;
    }
  };
};

/**
 * A single frame of Guacamole session data. Each frame is made up of the set
 * of instructions used to generate that frame, and the timestamp as dictated
 * by the "sync" instruction terminating the frame. Optionally, a frame may
 * also be associated with a snapshot of Guacamole client state, such that the
 * frame can be rendered without replaying all previous frames.
 *
 * @private
 * @constructor
 * @param {Number} timestamp
 *     The timestamp of this frame, as dictated by the "sync" instruction which
 *     terminates the frame.
 *
 * @param {Guacamole.SessionRecording._Frame.Instruction[]} instructions
 *     All instructions which are necessary to generate this frame relative to
 *     the previous frame in the Guacamole session.
 */
Guacamole.SessionRecording._Frame = function _Frame(timestamp, instructions) {
  /**
   * Whether this frame should be used as a keyframe if possible. This value
   * is purely advisory. The stored clientState must eventually be manually
   * set for the frame to be used as a keyframe. By default, frames are not
   * keyframes.
   *
   * @type {Boolean}
   * @default false
   */
  this.keyframe = false;

  /**
   * The timestamp of this frame, as dictated by the "sync" instruction which
   * terminates the frame.
   *
   * @type {Number}
   */
  this.timestamp = timestamp;

  /**
   * All instructions which are necessary to generate this frame relative to
   * the previous frame in the Guacamole session.
   *
   * @type {Guacamole.SessionRecording._Frame.Instruction[]}
   */
  this.instructions = instructions;

  /**
   * A snapshot of client state after this frame was rendered, as returned by
   * a call to exportState(). If no such snapshot has been taken, this will
   * be null.
   *
   * @type {Object}
   * @default null
   */
  this.clientState = null;
};

/**
 * A Guacamole protocol instruction. Each Guacamole protocol instruction is
 * made up of an opcode and set of arguments.
 *
 * @private
 * @constructor
 * @param {String} opcode
 *     The opcode of this Guacamole instruction.
 *
 * @param {String[]} args
 *     All arguments associated with this Guacamole instruction.
 */
Guacamole.SessionRecording._Frame.Instruction = function Instruction(
  opcode,
  args
) {
  /**
   * Reference to this Guacamole.SessionRecording._Frame.Instruction.
   *
   * @private
   * @type {Guacamole.SessionRecording._Frame.Instruction}
   */
  var instruction = this;

  /**
   * The opcode of this Guacamole instruction.
   *
   * @type {String}
   */
  this.opcode = opcode;

  /**
   * All arguments associated with this Guacamole instruction.
   *
   * @type {String[]}
   */
  this.args = args;

  /**
   * Returns the approximate number of characters which make up this
   * instruction. This value is only approximate as it excludes the length
   * prefixes and various delimiters used by the Guacamole protocol; only
   * the content of the opcode and each argument is taken into account.
   *
   * @returns {Number}
   *     The approximate size of this instruction, in characters.
   */
  this.getSize = function getSize() {
    // Init with length of opcode
    var size = instruction.opcode.length;

    // Add length of all arguments
    for (var i = 0; i < instruction.args.length; i++)
      size += instruction.args[i].length;

    return size;
  };
};

/**
 * A read-only Guacamole.Tunnel implementation which streams instructions
 * received through explicit calls to its receiveInstruction() function.
 *
 * @private
 * @constructor
 * @augments {Guacamole.Tunnel}
 */
Guacamole.SessionRecording._PlaybackTunnel = function _PlaybackTunnel() {
  /**
   * Reference to this Guacamole.SessionRecording._PlaybackTunnel.
   *
   * @private
   * @type {Guacamole.SessionRecording._PlaybackTunnel}
   */
  var tunnel = this;

  this.connect = function connect(data) {
    // Do nothing
  };

  this.sendMessage = function sendMessage(elements) {
    // Do nothing
  };

  this.disconnect = function disconnect() {
    // Do nothing
  };

  /**
   * Invokes this tunnel's oninstruction handler, notifying users of this
   * tunnel (such as a Guacamole.Client instance) that an instruction has
   * been received. If the oninstruction handler has not been set, this
   * function has no effect.
   *
   * @param {String} opcode
   *     The opcode of the Guacamole instruction.
   *
   * @param {String[]} args
   *     All arguments associated with this Guacamole instruction.
   */
  this.receiveInstruction = function receiveInstruction(opcode, args) {
    if (tunnel.oninstruction) tunnel.oninstruction(opcode, args);
  };
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A Guacamole status. Each Guacamole status consists of a status code, defined
 * by the protocol, and an optional human-readable message, usually only
 * included for debugging convenience.
 *
 * @constructor
 * @param {Number} code
 *     The Guacamole status code, as defined by Guacamole.Status.Code.
 *
 * @param {String} [message]
 *     An optional human-readable message.
 */
Guacamole.Status = function (code, message) {
  /**
   * Reference to this Guacamole.Status.
   * @private
   */
  var guac_status = this;

  /**
   * The Guacamole status code.
   * @see Guacamole.Status.Code
   * @type {Number}
   */
  this.code = code;

  /**
   * An arbitrary human-readable message associated with this status, if any.
   * The human-readable message is not required, and is generally provided
   * for debugging purposes only. For user feedback, it is better to translate
   * the Guacamole status code into a message.
   *
   * @type {String}
   */
  this.message = message;

  /**
   * Returns whether this status represents an error.
   * @returns {Boolean} true if this status represents an error, false
   *                    otherwise.
   */
  this.isError = function () {
    return guac_status.code < 0 || guac_status.code > 0x00ff;
  };
};

/**
 * Enumeration of all Guacamole status codes.
 */
Guacamole.Status.Code = {
  /**
   * The operation succeeded.
   *
   * @type {Number}
   */
  SUCCESS: 0x0000,

  /**
   * The requested operation is unsupported.
   *
   * @type {Number}
   */
  UNSUPPORTED: 0x0100,

  /**
   * The operation could not be performed due to an internal failure.
   *
   * @type {Number}
   */
  SERVER_ERROR: 0x0200,

  /**
   * The operation could not be performed as the server is busy.
   *
   * @type {Number}
   */
  SERVER_BUSY: 0x0201,

  /**
   * The operation could not be performed because the upstream server is not
   * responding.
   *
   * @type {Number}
   */
  UPSTREAM_TIMEOUT: 0x0202,

  /**
   * The operation was unsuccessful due to an error or otherwise unexpected
   * condition of the upstream server.
   *
   * @type {Number}
   */
  UPSTREAM_ERROR: 0x0203,

  /**
   * The operation could not be performed as the requested resource does not
   * exist.
   *
   * @type {Number}
   */
  RESOURCE_NOT_FOUND: 0x0204,

  /**
   * The operation could not be performed as the requested resource is
   * already in use.
   *
   * @type {Number}
   */
  RESOURCE_CONFLICT: 0x0205,

  /**
   * The operation could not be performed as the requested resource is now
   * closed.
   *
   * @type {Number}
   */
  RESOURCE_CLOSED: 0x0206,

  /**
   * The operation could not be performed because the upstream server does
   * not appear to exist.
   *
   * @type {Number}
   */
  UPSTREAM_NOT_FOUND: 0x0207,

  /**
   * The operation could not be performed because the upstream server is not
   * available to service the request.
   *
   * @type {Number}
   */
  UPSTREAM_UNAVAILABLE: 0x0208,

  /**
   * The session within the upstream server has ended because it conflicted
   * with another session.
   *
   * @type {Number}
   */
  SESSION_CONFLICT: 0x0209,

  /**
   * The session within the upstream server has ended because it appeared to
   * be inactive.
   *
   * @type {Number}
   */
  SESSION_TIMEOUT: 0x020a,

  /**
   * The session within the upstream server has been forcibly terminated.
   *
   * @type {Number}
   */
  SESSION_CLOSED: 0x020b,

  /**
   * The operation could not be performed because bad parameters were given.
   *
   * @type {Number}
   */
  CLIENT_BAD_REQUEST: 0x0300,

  /**
   * Permission was denied to perform the operation, as the user is not yet
   * authorized (not yet logged in, for example).
   *
   * @type {Number}
   */
  CLIENT_UNAUTHORIZED: 0x0301,

  /**
   * Permission was denied to perform the operation, and this permission will
   * not be granted even if the user is authorized.
   *
   * @type {Number}
   */
  CLIENT_FORBIDDEN: 0x0303,

  /**
   * The client took too long to respond.
   *
   * @type {Number}
   */
  CLIENT_TIMEOUT: 0x0308,

  /**
   * The client sent too much data.
   *
   * @type {Number}
   */
  CLIENT_OVERRUN: 0x030d,

  /**
   * The client sent data of an unsupported or unexpected type.
   *
   * @type {Number}
   */
  CLIENT_BAD_TYPE: 0x030f,

  /**
   * The operation failed because the current client is already using too
   * many resources.
   *
   * @type {Number}
   */
  CLIENT_TOO_MANY: 0x031d,
};

/**
 * Returns the Guacamole protocol status code which most closely
 * represents the given HTTP status code.
 *
 * @param {Number} status
 *     The HTTP status code to translate into a Guacamole protocol status
 *     code.
 *
 * @returns {Number}
 *     The Guacamole protocol status code which most closely represents the
 *     given HTTP status code.
 */
Guacamole.Status.Code.fromHTTPCode = function fromHTTPCode(status) {
  // Translate status codes with known equivalents
  switch (status) {
    // HTTP 400 - Bad request
    case 400:
      return Guacamole.Status.Code.CLIENT_BAD_REQUEST;

    // HTTP 403 - Forbidden
    case 403:
      return Guacamole.Status.Code.CLIENT_FORBIDDEN;

    // HTTP 404 - Resource not found
    case 404:
      return Guacamole.Status.Code.RESOURCE_NOT_FOUND;

    // HTTP 429 - Too many requests
    case 429:
      return Guacamole.Status.Code.CLIENT_TOO_MANY;

    // HTTP 503 - Server unavailable
    case 503:
      return Guacamole.Status.Code.SERVER_BUSY;
  }

  // Default all other codes to generic internal error
  return Guacamole.Status.Code.SERVER_ERROR;
};

/**
 * Returns the Guacamole protocol status code which most closely
 * represents the given WebSocket status code.
 *
 * @param {Number} code
 *     The WebSocket status code to translate into a Guacamole protocol
 *     status code.
 *
 * @returns {Number}
 *     The Guacamole protocol status code which most closely represents the
 *     given WebSocket status code.
 */
Guacamole.Status.Code.fromWebSocketCode = function fromWebSocketCode(code) {
  // Translate status codes with known equivalents
  switch (code) {
    // Successful disconnect (no error)
    case 1000: // Normal Closure
      return Guacamole.Status.Code.SUCCESS;

    // Codes which indicate the server is not reachable
    case 1006: // Abnormal Closure (also signalled by JavaScript when the connection cannot be opened in the first place)
    case 1015: // TLS Handshake
      return Guacamole.Status.Code.UPSTREAM_NOT_FOUND;

    // Codes which indicate the server is reachable but busy/unavailable
    case 1001: // Going Away
    case 1012: // Service Restart
    case 1013: // Try Again Later
    case 1014: // Bad Gateway
      return Guacamole.Status.Code.UPSTREAM_UNAVAILABLE;
  }

  // Default all other codes to generic internal error
  return Guacamole.Status.Code.SERVER_ERROR;
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A reader which automatically handles the given input stream, returning
 * strictly text data. Note that this object will overwrite any installed event
 * handlers on the given Guacamole.InputStream.
 *
 * @constructor
 * @param {Guacamole.InputStream} stream The stream that data will be read
 *                                       from.
 */
Guacamole.StringReader = function (stream) {
  /**
   * Reference to this Guacamole.InputStream.
   * @private
   */
  var guac_reader = this;

  /**
   * Wrapped Guacamole.ArrayBufferReader.
   * @private
   * @type {Guacamole.ArrayBufferReader}
   */
  var array_reader = new Guacamole.ArrayBufferReader(stream);

  /**
   * The number of bytes remaining for the current codepoint.
   *
   * @private
   * @type {Number}
   */
  var bytes_remaining = 0;

  /**
   * The current codepoint value, as calculated from bytes read so far.
   *
   * @private
   * @type {Number}
   */
  var codepoint = 0;

  /**
   * Decodes the given UTF-8 data into a Unicode string. The data may end in
   * the middle of a multibyte character.
   *
   * @private
   * @param {ArrayBuffer} buffer Arbitrary UTF-8 data.
   * @return {String} A decoded Unicode string.
   */
  function __decode_utf8(buffer) {
    var text = "";

    var bytes = new Uint8Array(buffer);
    for (var i = 0; i < bytes.length; i++) {
      // Get current byte
      var value = bytes[i];

      // Start new codepoint if nothing yet read
      if (bytes_remaining === 0) {
        // 1 byte (0xxxxxxx)
        if ((value | 0x7f) === 0x7f) text += String.fromCharCode(value);
        // 2 byte (110xxxxx)
        else if ((value | 0x1f) === 0xdf) {
          codepoint = value & 0x1f;
          bytes_remaining = 1;
        }

        // 3 byte (1110xxxx)
        else if ((value | 0x0f) === 0xef) {
          codepoint = value & 0x0f;
          bytes_remaining = 2;
        }

        // 4 byte (11110xxx)
        else if ((value | 0x07) === 0xf7) {
          codepoint = value & 0x07;
          bytes_remaining = 3;
        }

        // Invalid byte
        else text += "\uFFFD";
      }

      // Continue existing codepoint (10xxxxxx)
      else if ((value | 0x3f) === 0xbf) {
        codepoint = (codepoint << 6) | (value & 0x3f);
        bytes_remaining--;

        // Write codepoint if finished
        if (bytes_remaining === 0) text += String.fromCharCode(codepoint);
      }

      // Invalid byte
      else {
        bytes_remaining = 0;
        text += "\uFFFD";
      }
    }

    return text;
  }

  // Receive blobs as strings
  array_reader.ondata = function (buffer) {
    // Decode UTF-8
    var text = __decode_utf8(buffer);

    // Call handler, if present
    if (guac_reader.ontext) guac_reader.ontext(text);
  };

  // Simply call onend when end received
  array_reader.onend = function () {
    if (guac_reader.onend) guac_reader.onend();
  };

  /**
   * Fired once for every blob of text data received.
   *
   * @event
   * @param {String} text The data packet received.
   */
  this.ontext = null;

  /**
   * Fired once this stream is finished and no further data will be written.
   * @event
   */
  this.onend = null;
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A writer which automatically writes to the given output stream with text
 * data.
 *
 * @constructor
 * @param {Guacamole.OutputStream} stream The stream that data will be written
 *                                        to.
 */
Guacamole.StringWriter = function (stream) {
  /**
   * Reference to this Guacamole.StringWriter.
   * @private
   */
  var guac_writer = this;

  /**
   * Wrapped Guacamole.ArrayBufferWriter.
   * @private
   * @type {Guacamole.ArrayBufferWriter}
   */
  var array_writer = new Guacamole.ArrayBufferWriter(stream);

  /**
   * Internal buffer for UTF-8 output.
   * @private
   */
  var buffer = new Uint8Array(8192);

  /**
   * The number of bytes currently in the buffer.
   * @private
   */
  var length = 0;

  // Simply call onack for acknowledgements
  array_writer.onack = function (status) {
    if (guac_writer.onack) guac_writer.onack(status);
  };

  /**
   * Expands the size of the underlying buffer by the given number of bytes,
   * updating the length appropriately.
   *
   * @private
   * @param {Number} bytes The number of bytes to add to the underlying
   *                       buffer.
   */
  function __expand(bytes) {
    // Resize buffer if more space needed
    if (length + bytes >= buffer.length) {
      var new_buffer = new Uint8Array((length + bytes) * 2);
      new_buffer.set(buffer);
      buffer = new_buffer;
    }

    length += bytes;
  }

  /**
   * Appends a single Unicode character to the current buffer, resizing the
   * buffer if necessary. The character will be encoded as UTF-8.
   *
   * @private
   * @param {Number} codepoint The codepoint of the Unicode character to
   *                           append.
   */
  function __append_utf8(codepoint) {
    var mask;
    var bytes;

    // 1 byte
    if (codepoint <= 0x7f) {
      mask = 0x00;
      bytes = 1;
    }

    // 2 byte
    else if (codepoint <= 0x7ff) {
      mask = 0xc0;
      bytes = 2;
    }

    // 3 byte
    else if (codepoint <= 0xffff) {
      mask = 0xe0;
      bytes = 3;
    }

    // 4 byte
    else if (codepoint <= 0x1fffff) {
      mask = 0xf0;
      bytes = 4;
    }

    // If invalid codepoint, append replacement character
    else {
      __append_utf8(0xfffd);
      return;
    }

    // Offset buffer by size
    __expand(bytes);
    var offset = length - 1;

    // Add trailing bytes, if any
    for (var i = 1; i < bytes; i++) {
      buffer[offset--] = 0x80 | (codepoint & 0x3f);
      codepoint >>= 6;
    }

    // Set initial byte
    buffer[offset] = mask | codepoint;
  }

  /**
   * Encodes the given string as UTF-8, returning an ArrayBuffer containing
   * the resulting bytes.
   *
   * @private
   * @param {String} text The string to encode as UTF-8.
   * @return {Uint8Array} The encoded UTF-8 data.
   */
  function __encode_utf8(text) {
    // Fill buffer with UTF-8
    for (var i = 0; i < text.length; i++) {
      var codepoint = text.charCodeAt(i);
      __append_utf8(codepoint);
    }

    // Flush buffer
    if (length > 0) {
      var out_buffer = buffer.subarray(0, length);
      length = 0;
      return out_buffer;
    }
  }

  /**
   * Sends the given text.
   *
   * @param {String} text The text to send.
   */
  this.sendText = function (text) {
    if (text.length) array_writer.sendData(__encode_utf8(text));
  };

  /**
   * Signals that no further text will be sent, effectively closing the
   * stream.
   */
  this.sendEnd = function () {
    array_writer.sendEnd();
  };

  /**
   * Fired for received data, if acknowledged by the server.
   * @event
   * @param {Guacamole.Status} status The status of the operation.
   */
  this.onack = null;
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Core object providing abstract communication for Guacamole. This object
 * is a null implementation whose functions do nothing. Guacamole applications
 * should use {@link Guacamole.HTTPTunnel} instead, or implement their own tunnel based
 * on this one.
 *
 * @constructor
 * @see Guacamole.HTTPTunnel
 */
Guacamole.Tunnel = function () {
  /**
   * Connect to the tunnel with the given optional data. This data is
   * typically used for authentication. The format of data accepted is
   * up to the tunnel implementation.
   *
   * @param {String} data The data to send to the tunnel when connecting.
   */
  this.connect = function (data) {};

  /**
   * Disconnect from the tunnel.
   */
  this.disconnect = function () {};

  /**
   * Send the given message through the tunnel to the service on the other
   * side. All messages are guaranteed to be received in the order sent.
   *
   * @param {...*} elements
   *     The elements of the message to send to the service on the other side
   *     of the tunnel.
   */
  this.sendMessage = function (elements) {};

  /**
   * Changes the stored numeric state of this tunnel, firing the onstatechange
   * event if the new state is different and a handler has been defined.
   *
   * @private
   * @param {Number} state
   *     The new state of this tunnel.
   */
  this.setState = function (state) {
    // Notify only if state changes
    if (state !== this.state) {
      this.state = state;
      if (this.onstatechange) this.onstatechange(state);
    }
  };

  /**
   * Changes the stored UUID that uniquely identifies this tunnel, firing the
   * onuuid event if a handler has been defined.
   *
   * @private
   * @param {String} uuid
   *     The new state of this tunnel.
   */
  this.setUUID = function setUUID(uuid) {
    this.uuid = uuid;
    if (this.onuuid) this.onuuid(uuid);
  };

  /**
   * Returns whether this tunnel is currently connected.
   *
   * @returns {Boolean}
   *     true if this tunnel is currently connected, false otherwise.
   */
  this.isConnected = function isConnected() {
    return (
      this.state === Guacamole.Tunnel.State.OPEN ||
      this.state === Guacamole.Tunnel.State.UNSTABLE
    );
  };

  /**
   * The current state of this tunnel.
   *
   * @type {Number}
   */
  this.state = Guacamole.Tunnel.State.CONNECTING;

  /**
   * The maximum amount of time to wait for data to be received, in
   * milliseconds. If data is not received within this amount of time,
   * the tunnel is closed with an error. The default value is 15000.
   *
   * @type {Number}
   */
  this.receiveTimeout = 15000;

  /**
   * The amount of time to wait for data to be received before considering
   * the connection to be unstable, in milliseconds. If data is not received
   * within this amount of time, the tunnel status is updated to warn that
   * the connection appears unresponsive and may close. The default value is
   * 1500.
   *
   * @type {Number}
   */
  this.unstableThreshold = 1500;

  /**
   * The UUID uniquely identifying this tunnel. If not yet known, this will
   * be null.
   *
   * @type {String}
   */
  this.uuid = null;

  /**
   * Fired when the UUID that uniquely identifies this tunnel is known.
   *
   * @event
   * @param {String}
   *     The UUID uniquely identifying this tunnel.
   */
  this.onuuid = null;

  /**
   * Fired whenever an error is encountered by the tunnel.
   *
   * @event
   * @param {Guacamole.Status} status A status object which describes the
   *                                  error.
   */
  this.onerror = null;

  /**
   * Fired whenever the state of the tunnel changes.
   *
   * @event
   * @param {Number} state The new state of the client.
   */
  this.onstatechange = null;

  /**
   * Fired once for every complete Guacamole instruction received, in order.
   *
   * @event
   * @param {String} opcode The Guacamole instruction opcode.
   * @param {Array} parameters The parameters provided for the instruction,
   *                           if any.
   */
  this.oninstruction = null;
};

/**
 * The Guacamole protocol instruction opcode reserved for arbitrary internal
 * use by tunnel implementations. The value of this opcode is guaranteed to be
 * the empty string (""). Tunnel implementations may use this opcode for any
 * purpose. It is currently used by the HTTP tunnel to mark the end of the HTTP
 * response, and by the WebSocket tunnel to transmit the tunnel UUID and send
 * connection stability test pings/responses.
 *
 * @constant
 * @type {String}
 */
Guacamole.Tunnel.INTERNAL_DATA_OPCODE = "";

/**
 * All possible tunnel states.
 */
Guacamole.Tunnel.State = {
  /**
   * A connection is in pending. It is not yet known whether connection was
   * successful.
   *
   * @type {Number}
   */
  CONNECTING: 0,

  /**
   * Connection was successful, and data is being received.
   *
   * @type {Number}
   */
  OPEN: 1,

  /**
   * The connection is closed. Connection may not have been successful, the
   * tunnel may have been explicitly closed by either side, or an error may
   * have occurred.
   *
   * @type {Number}
   */
  CLOSED: 2,

  /**
   * The connection is open, but communication through the tunnel appears to
   * be disrupted, and the connection may close as a result.
   *
   * @type {Number}
   */
  UNSTABLE: 3,
};

/**
 * Guacamole Tunnel implemented over HTTP via XMLHttpRequest.
 *
 * @constructor
 * @augments Guacamole.Tunnel
 *
 * @param {String} tunnelURL
 *     The URL of the HTTP tunneling service.
 *
 * @param {Boolean} [crossDomain=false]
 *     Whether tunnel requests will be cross-domain, and thus must use CORS
 *     mechanisms and headers. By default, it is assumed that tunnel requests
 *     will be made to the same domain.
 *
 * @param {Object} [extraTunnelHeaders={}]
 *     Key value pairs containing the header names and values of any additional
 *     headers to be sent in tunnel requests. By default, no extra headers will
 *     be added.
 */
Guacamole.HTTPTunnel = function (tunnelURL, crossDomain, extraTunnelHeaders) {
  /**
   * Reference to this HTTP tunnel.
   * @private
   */
  var tunnel = this;

  var TUNNEL_CONNECT = tunnelURL + "?connect";
  var TUNNEL_READ = tunnelURL + "?read:";
  var TUNNEL_WRITE = tunnelURL + "?write:";

  var POLLING_ENABLED = 1;
  var POLLING_DISABLED = 0;

  // Default to polling - will be turned off automatically if not needed
  var pollingMode = POLLING_ENABLED;

  var sendingMessages = false;
  var outputMessageBuffer = "";

  // If requests are expected to be cross-domain, the cookie that the HTTP
  // tunnel depends on will only be sent if withCredentials is true
  var withCredentials = !!crossDomain;

  /**
   * The current receive timeout ID, if any.
   * @private
   */
  var receive_timeout = null;

  /**
   * The current connection stability timeout ID, if any.
   *
   * @private
   * @type {Number}
   */
  var unstableTimeout = null;

  /**
   * The current connection stability test ping interval ID, if any. This
   * will only be set upon successful connection.
   *
   * @private
   * @type {Number}
   */
  var pingInterval = null;

  /**
   * The number of milliseconds to wait between connection stability test
   * pings.
   *
   * @private
   * @constant
   * @type {Number}
   */
  var PING_FREQUENCY = 500;

  /**
   * Additional headers to be sent in tunnel requests. This dictionary can be
   * populated with key/value header pairs to pass information such as authentication
   * tokens, etc.
   *
   * @private
   */
  var extraHeaders = extraTunnelHeaders || {};

  /**
   * Adds the configured additional headers to the given request.
   *
   * @param {XMLHttpRequest} request
   *     The request where the configured extra headers will be added.
   *
   * @param {Object} headers
   *     The headers to be added to the request.
   *
   * @private
   */
  function addExtraHeaders(request, headers) {
    for (var name in headers) {
      request.setRequestHeader(name, headers[name]);
    }
  }

  /**
   * Initiates a timeout which, if data is not received, causes the tunnel
   * to close with an error.
   *
   * @private
   */
  function reset_timeout() {
    // Get rid of old timeouts (if any)
    window.clearTimeout(receive_timeout);
    window.clearTimeout(unstableTimeout);

    // Clear unstable status
    if (tunnel.state === Guacamole.Tunnel.State.UNSTABLE)
      tunnel.setState(Guacamole.Tunnel.State.OPEN);

    // Set new timeout for tracking overall connection timeout
    receive_timeout = window.setTimeout(function () {
      close_tunnel(
        new Guacamole.Status(
          Guacamole.Status.Code.UPSTREAM_TIMEOUT,
          "Server timeout."
        )
      );
    }, tunnel.receiveTimeout);

    // Set new timeout for tracking suspected connection instability
    unstableTimeout = window.setTimeout(function () {
      tunnel.setState(Guacamole.Tunnel.State.UNSTABLE);
    }, tunnel.unstableThreshold);
  }

  /**
   * Closes this tunnel, signaling the given status and corresponding
   * message, which will be sent to the onerror handler if the status is
   * an error status.
   *
   * @private
   * @param {Guacamole.Status} status The status causing the connection to
   *                                  close;
   */
  function close_tunnel(status) {
    // Get rid of old timeouts (if any)
    window.clearTimeout(receive_timeout);
    window.clearTimeout(unstableTimeout);

    // Cease connection test pings
    window.clearInterval(pingInterval);

    // Ignore if already closed
    if (tunnel.state === Guacamole.Tunnel.State.CLOSED) return;

    // If connection closed abnormally, signal error.
    if (status.code !== Guacamole.Status.Code.SUCCESS && tunnel.onerror) {
      // Ignore RESOURCE_NOT_FOUND if we've already connected, as that
      // only signals end-of-stream for the HTTP tunnel.
      if (
        tunnel.state === Guacamole.Tunnel.State.CONNECTING ||
        status.code !== Guacamole.Status.Code.RESOURCE_NOT_FOUND
      )
        tunnel.onerror(status);
    }

    // Reset output message buffer
    sendingMessages = false;

    // Mark as closed
    tunnel.setState(Guacamole.Tunnel.State.CLOSED);
  }

  this.sendMessage = function () {
    // Do not attempt to send messages if not connected
    if (!tunnel.isConnected()) return;

    // Do not attempt to send empty messages
    if (arguments.length === 0) return;

    /**
     * Converts the given value to a length/string pair for use as an
     * element in a Guacamole instruction.
     *
     * @private
     * @param value The value to convert.
     * @return {String} The converted value.
     */
    function getElement(value) {
      var string = new String(value);
      return string.length + "." + string;
    }

    // Initialized message with first element
    var message = getElement(arguments[0]);

    // Append remaining elements
    for (var i = 1; i < arguments.length; i++)
      message += "," + getElement(arguments[i]);

    // Final terminator
    message += ";";

    // Add message to buffer
    outputMessageBuffer += message;

    // Send if not currently sending
    if (!sendingMessages) sendPendingMessages();
  };

  function sendPendingMessages() {
    // Do not attempt to send messages if not connected
    if (!tunnel.isConnected()) return;

    if (outputMessageBuffer.length > 0) {
      sendingMessages = true;

      var message_xmlhttprequest = new XMLHttpRequest();
      message_xmlhttprequest.open("POST", TUNNEL_WRITE + tunnel.uuid);
      message_xmlhttprequest.withCredentials = withCredentials;
      addExtraHeaders(message_xmlhttprequest, extraHeaders);
      message_xmlhttprequest.setRequestHeader(
        "Content-type",
        "application/octet-stream"
      );

      // Once response received, send next queued event.
      message_xmlhttprequest.onreadystatechange = function () {
        if (message_xmlhttprequest.readyState === 4) {
          reset_timeout();

          // If an error occurs during send, handle it
          if (message_xmlhttprequest.status !== 200)
            handleHTTPTunnelError(message_xmlhttprequest);
          // Otherwise, continue the send loop
          else sendPendingMessages();
        }
      };

      message_xmlhttprequest.send(outputMessageBuffer);
      outputMessageBuffer = ""; // Clear buffer
    } else sendingMessages = false;
  }

  function handleHTTPTunnelError(xmlhttprequest) {
    // Pull status code directly from headers provided by Guacamole
    var code = parseInt(
      xmlhttprequest.getResponseHeader("Guacamole-Status-Code")
    );
    if (code) {
      var message = xmlhttprequest.getResponseHeader("Guacamole-Error-Message");
      close_tunnel(new Guacamole.Status(code, message));
    }

    // Failing that, derive a Guacamole status code from the HTTP status
    // code provided by the browser
    else if (xmlhttprequest.status)
      close_tunnel(
        new Guacamole.Status(
          Guacamole.Status.Code.fromHTTPCode(xmlhttprequest.status),
          xmlhttprequest.statusText
        )
      );
    // Otherwise, assume server is unreachable
    else
      close_tunnel(
        new Guacamole.Status(Guacamole.Status.Code.UPSTREAM_NOT_FOUND)
      );
  }

  function handleResponse(xmlhttprequest) {
    var interval = null;
    var nextRequest = null;

    var dataUpdateEvents = 0;

    // The location of the last element's terminator
    var elementEnd = -1;

    // Where to start the next length search or the next element
    var startIndex = 0;

    // Parsed elements
    var elements = new Array();

    function parseResponse() {
      // Do not handle responses if not connected
      if (!tunnel.isConnected()) {
        // Clean up interval if polling
        if (interval !== null) clearInterval(interval);

        return;
      }

      // Do not parse response yet if not ready
      if (xmlhttprequest.readyState < 2) return;

      // Attempt to read status
      var status;
      try {
        status = xmlhttprequest.status;
      } catch (e) {
        // If status could not be read, assume successful.
        status = 200;
      }

      // Start next request as soon as possible IF request was successful
      if (!nextRequest && status === 200) nextRequest = makeRequest();

      // Parse stream when data is received and when complete.
      if (xmlhttprequest.readyState === 3 || xmlhttprequest.readyState === 4) {
        reset_timeout();

        // Also poll every 30ms (some browsers don't repeatedly call onreadystatechange for new data)
        if (pollingMode === POLLING_ENABLED) {
          if (xmlhttprequest.readyState === 3 && !interval)
            interval = setInterval(parseResponse, 30);
          else if (xmlhttprequest.readyState === 4 && interval)
            clearInterval(interval);
        }

        // If canceled, stop transfer
        if (xmlhttprequest.status === 0) {
          tunnel.disconnect();
          return;
        }

        // Halt on error during request
        else if (xmlhttprequest.status !== 200) {
          handleHTTPTunnelError(xmlhttprequest);
          return;
        }

        // Attempt to read in-progress data
        var current;
        try {
          current = xmlhttprequest.responseText;
        } catch (e) {
          // Do not attempt to parse if data could not be read
          return;
        }

        // While search is within currently received data
        while (elementEnd < current.length) {
          // If we are waiting for element data
          if (elementEnd >= startIndex) {
            // We now have enough data for the element. Parse.
            var element = current.substring(startIndex, elementEnd);
            var terminator = current.substring(elementEnd, elementEnd + 1);

            // Add element to array
            elements.push(element);

            // If last element, handle instruction
            if (terminator === ";") {
              // Get opcode
              var opcode = elements.shift();

              // Call instruction handler.
              if (tunnel.oninstruction) tunnel.oninstruction(opcode, elements);

              // Clear elements
              elements.length = 0;
            }

            // Start searching for length at character after
            // element terminator
            startIndex = elementEnd + 1;
          }

          // Search for end of length
          var lengthEnd = current.indexOf(".", startIndex);
          if (lengthEnd !== -1) {
            // Parse length
            var length = parseInt(current.substring(elementEnd + 1, lengthEnd));

            // If we're done parsing, handle the next response.
            if (length === 0) {
              // Clean up interval if polling
              if (interval) clearInterval(interval);

              // Clean up object
              xmlhttprequest.onreadystatechange = null;
              xmlhttprequest.abort();

              // Start handling next request
              if (nextRequest) handleResponse(nextRequest);

              // Done parsing
              break;
            }

            // Calculate start of element
            startIndex = lengthEnd + 1;

            // Calculate location of element terminator
            elementEnd = startIndex + length;
          }

          // If no period yet, continue search when more data
          // is received
          else {
            startIndex = current.length;
            break;
          }
        } // end parse loop
      }
    }

    // If response polling enabled, attempt to detect if still
    // necessary (via wrapping parseResponse())
    if (pollingMode === POLLING_ENABLED) {
      xmlhttprequest.onreadystatechange = function () {
        // If we receive two or more readyState==3 events,
        // there is no need to poll.
        if (xmlhttprequest.readyState === 3) {
          dataUpdateEvents++;
          if (dataUpdateEvents >= 2) {
            pollingMode = POLLING_DISABLED;
            xmlhttprequest.onreadystatechange = parseResponse;
          }
        }

        parseResponse();
      };
    }

    // Otherwise, just parse
    else xmlhttprequest.onreadystatechange = parseResponse;

    parseResponse();
  }

  /**
   * Arbitrary integer, unique for each tunnel read request.
   * @private
   */
  var request_id = 0;

  function makeRequest() {
    // Make request, increment request ID
    var xmlhttprequest = new XMLHttpRequest();
    xmlhttprequest.open("GET", TUNNEL_READ + tunnel.uuid + ":" + request_id++);
    xmlhttprequest.withCredentials = withCredentials;
    addExtraHeaders(xmlhttprequest, extraHeaders);
    xmlhttprequest.send(null);

    return xmlhttprequest;
  }

  this.connect = function (data) {
    // Start waiting for connect
    reset_timeout();

    // Mark the tunnel as connecting
    tunnel.setState(Guacamole.Tunnel.State.CONNECTING);

    // Start tunnel and connect
    var connect_xmlhttprequest = new XMLHttpRequest();
    connect_xmlhttprequest.onreadystatechange = function () {
      if (connect_xmlhttprequest.readyState !== 4) return;

      // If failure, throw error
      if (connect_xmlhttprequest.status !== 200) {
        handleHTTPTunnelError(connect_xmlhttprequest);
        return;
      }

      reset_timeout();

      // Get UUID from response
      tunnel.setUUID(connect_xmlhttprequest.responseText);

      // Mark as open
      tunnel.setState(Guacamole.Tunnel.State.OPEN);

      // Ping tunnel endpoint regularly to test connection stability
      // pingInterval = setInterval(function sendPing() {
      //     tunnel.sendMessage("nop");
      // }, PING_FREQUENCY);

      // Start reading data
      handleResponse(makeRequest());
    };

    connect_xmlhttprequest.open("POST", TUNNEL_CONNECT, true);
    connect_xmlhttprequest.withCredentials = withCredentials;
    addExtraHeaders(connect_xmlhttprequest, extraHeaders);
    connect_xmlhttprequest.setRequestHeader(
      "Content-type",
      "application/x-www-form-urlencoded; charset=UTF-8"
    );
    connect_xmlhttprequest.send(data);
  };

  this.disconnect = function () {
    close_tunnel(
      new Guacamole.Status(Guacamole.Status.Code.SUCCESS, "Manually closed.")
    );
  };
};

Guacamole.HTTPTunnel.prototype = new Guacamole.Tunnel();

/**
 * Guacamole Tunnel implemented over WebSocket via XMLHttpRequest.
 *
 * @constructor
 * @augments Guacamole.Tunnel
 * @param {String} tunnelURL The URL of the WebSocket tunneling service.
 */
Guacamole.WebSocketTunnel = function (tunnelURL) {
  /**
   * Reference to this WebSocket tunnel.
   * @private
   */
  var tunnel = this;

  /**
   * The WebSocket used by this tunnel.
   * @private
   */
  var socket = null;

  /**
   * The current receive timeout ID, if any.
   * @private
   */
  var receive_timeout = null;

  /**
   * The current connection stability timeout ID, if any.
   *
   * @private
   * @type {Number}
   */
  var unstableTimeout = null;

  /**
   * The current connection stability test ping interval ID, if any. This
   * will only be set upon successful connection.
   *
   * @private
   * @type {Number}
   */
  var pingInterval = null;

  /**
   * The WebSocket protocol corresponding to the protocol used for the current
   * location.
   * @private
   */
  var ws_protocol = {
    "http:": "ws:",
    "https:": "wss:",
  };

  /**
   * The number of milliseconds to wait between connection stability test
   * pings.
   *
   * @private
   * @constant
   * @type {Number}
   */
  var PING_FREQUENCY = 500;

  // Transform current URL to WebSocket URL

  // If not already a websocket URL
  if (
    tunnelURL.substring(0, 3) !== "ws:" &&
    tunnelURL.substring(0, 4) !== "wss:"
  ) {
    var protocol = ws_protocol[window.location.protocol];

    // If absolute URL, convert to absolute WS URL
    if (tunnelURL.substring(0, 1) === "/")
      tunnelURL = protocol + "//" + window.location.host + tunnelURL;
    // Otherwise, construct absolute from relative URL
    else {
      // Get path from pathname
      var slash = window.location.pathname.lastIndexOf("/");
      var path = window.location.pathname.substring(0, slash + 1);

      // Construct absolute URL
      tunnelURL = protocol + "//" + window.location.host + path + tunnelURL;
    }
  }

  /**
   * Initiates a timeout which, if data is not received, causes the tunnel
   * to close with an error.
   *
   * @private
   */
  function reset_timeout() {
    // Get rid of old timeouts (if any)
    window.clearTimeout(receive_timeout);
    window.clearTimeout(unstableTimeout);

    // Clear unstable status
    if (tunnel.state === Guacamole.Tunnel.State.UNSTABLE)
      tunnel.setState(Guacamole.Tunnel.State.OPEN);

    // Set new timeout for tracking overall connection timeout
    receive_timeout = window.setTimeout(function () {
      close_tunnel(
        new Guacamole.Status(
          Guacamole.Status.Code.UPSTREAM_TIMEOUT,
          "Server timeout."
        )
      );
    }, tunnel.receiveTimeout);

    // Set new timeout for tracking suspected connection instability
    unstableTimeout = window.setTimeout(function () {
      tunnel.setState(Guacamole.Tunnel.State.UNSTABLE);
    }, tunnel.unstableThreshold);
  }

  /**
   * Closes this tunnel, signaling the given status and corresponding
   * message, which will be sent to the onerror handler if the status is
   * an error status.
   *
   * @private
   * @param {Guacamole.Status} status The status causing the connection to
   *                                  close;
   */
  function close_tunnel(status) {
    // Get rid of old timeouts (if any)
    window.clearTimeout(receive_timeout);
    window.clearTimeout(unstableTimeout);

    // Cease connection test pings
    window.clearInterval(pingInterval);

    // Ignore if already closed
    if (tunnel.state === Guacamole.Tunnel.State.CLOSED) return;

    // If connection closed abnormally, signal error.
    if (status.code !== Guacamole.Status.Code.SUCCESS && tunnel.onerror)
      tunnel.onerror(status);

    // Mark as closed
    tunnel.setState(Guacamole.Tunnel.State.CLOSED);

    socket.close();
  }

  this.sendMessage = function (elements) {
    // Do not attempt to send messages if not connected
    if (!tunnel.isConnected()) return;

    // Do not attempt to send empty messages
    if (arguments.length === 0) return;

    /**
     * Converts the given value to a length/string pair for use as an
     * element in a Guacamole instruction.
     *
     * @private
     * @param value The value to convert.
     * @return {String} The converted value.
     */
    function getElement(value) {
      var string = new String(value);
      return string.length + "." + string;
    }

    // Initialized message with first element
    var message = getElement(arguments[0]);

    // Append remaining elements
    for (var i = 1; i < arguments.length; i++)
      message += "," + getElement(arguments[i]);

    // Final terminator
    message += ";";

    socket.send(message);
  };

  this.connect = function (data, onOpenCallback) {
    reset_timeout();

    // Mark the tunnel as connecting
    tunnel.setState(Guacamole.Tunnel.State.CONNECTING);

    // Connect socket
    socket = new WebSocket(tunnelURL + (data ? `?${data}` : ""), "guacamole");

    socket.onopen = function (event) {
      onOpenCallback && onOpenCallback(socket);
      reset_timeout();
      // Ping tunnel endpoint regularly to test connection stability
      // pingInterval = setInterval(function sendPing() {
      //     tunnel.sendMessage(Guacamole.Tunnel.INTERNAL_DATA_OPCODE,
      //         "ping", new Date().getTime());
      // }, PING_FREQUENCY);
    };

    socket.onclose = function (event) {
      // Pull status code directly from closure reason provided by Guacamole
      if (event.reason)
        close_tunnel(
          new Guacamole.Status(parseInt(event.reason), event.reason)
        );
      // Failing that, derive a Guacamole status code from the WebSocket
      // status code provided by the browser
      else if (event.code)
        close_tunnel(
          new Guacamole.Status(
            Guacamole.Status.Code.fromWebSocketCode(event.code)
          )
        );
      // Otherwise, assume server is unreachable
      else
        close_tunnel(
          new Guacamole.Status(Guacamole.Status.Code.UPSTREAM_NOT_FOUND)
        );
    };

    socket.onmessage = function (event) {
      reset_timeout();

      var message = event.data;
      var startIndex = 0;
      var elementEnd;

      var elements = [];

      do {
        // Search for end of length
        var lengthEnd = message.indexOf(".", startIndex);
        if (lengthEnd !== -1) {
          // Parse length
          var length = parseInt(message.substring(elementEnd + 1, lengthEnd));

          // Calculate start of element
          startIndex = lengthEnd + 1;

          // Calculate location of element terminator
          elementEnd = startIndex + length;
        }

        // If no period, incomplete instruction.
        else
          close_tunnel(
            new Guacamole.Status(
              Guacamole.Status.Code.SERVER_ERROR,
              "Incomplete instruction."
            )
          );

        // We now have enough data for the element. Parse.
        var element = message.substring(startIndex, elementEnd);
        var terminator = message.substring(elementEnd, elementEnd + 1);

        // Add element to array
        elements.push(element);

        // If last element, handle instruction
        if (terminator === ";") {
          // Get opcode
          var opcode = elements.shift();

          // Update state and UUID when first instruction received
          if (tunnel.uuid === null) {
            // Associate tunnel UUID if received
            if (opcode === Guacamole.Tunnel.INTERNAL_DATA_OPCODE)
              tunnel.setUUID(elements[0]);

            // Tunnel is now open and UUID is available
            tunnel.setState(Guacamole.Tunnel.State.OPEN);
          }

          // Call instruction handler.
          if (
            opcode !== Guacamole.Tunnel.INTERNAL_DATA_OPCODE &&
            tunnel.oninstruction
          )
            tunnel.oninstruction(opcode, elements);

          // Clear elements
          elements.length = 0;
        }

        // Start searching for length at character after
        // element terminator
        startIndex = elementEnd + 1;
      } while (startIndex < message.length);
    };
  };

  this.disconnect = function () {
    close_tunnel(
      new Guacamole.Status(Guacamole.Status.Code.SUCCESS, "Manually closed.")
    );
  };
};

Guacamole.WebSocketTunnel.prototype = new Guacamole.Tunnel();

/**
 * Guacamole Tunnel which cycles between all specified tunnels until
 * no tunnels are left. Another tunnel is used if an error occurs but
 * no instructions have been received. If an instruction has been
 * received, or no tunnels remain, the error is passed directly out
 * through the onerror handler (if defined).
 *
 * @constructor
 * @augments Guacamole.Tunnel
 * @param {...*} tunnelChain
 *     The tunnels to use, in order of priority.
 */
Guacamole.ChainedTunnel = function (tunnelChain) {
  /**
   * Reference to this chained tunnel.
   * @private
   */
  var chained_tunnel = this;

  /**
   * Data passed in via connect(), to be used for
   * wrapped calls to other tunnels' connect() functions.
   * @private
   */
  var connect_data;

  /**
   * Array of all tunnels passed to this ChainedTunnel through the
   * constructor arguments.
   * @private
   */
  var tunnels = [];

  /**
   * The tunnel committed via commit_tunnel(), if any, or null if no tunnel
   * has yet been committed.
   *
   * @private
   * @type {Guacamole.Tunnel}
   */
  var committedTunnel = null;

  // Load all tunnels into array
  for (var i = 0; i < arguments.length; i++) tunnels.push(arguments[i]);

  /**
   * Sets the current tunnel.
   *
   * @private
   * @param {Guacamole.Tunnel} tunnel The tunnel to set as the current tunnel.
   */
  function attach(tunnel) {
    // Set own functions to tunnel's functions
    chained_tunnel.disconnect = tunnel.disconnect;
    chained_tunnel.sendMessage = tunnel.sendMessage;

    /**
     * Fails the currently-attached tunnel, attaching a new tunnel if
     * possible.
     *
     * @private
     * @param {Guacamole.Status} [status]
     *     An object representing the failure that occured in the
     *     currently-attached tunnel, if known.
     *
     * @return {Guacamole.Tunnel}
     *     The next tunnel, or null if there are no more tunnels to try or
     *     if no more tunnels should be tried.
     */
    var failTunnel = function failTunnel(status) {
      // Do not attempt to continue using next tunnel on server timeout
      if (status && status.code === Guacamole.Status.Code.UPSTREAM_TIMEOUT) {
        tunnels = [];
        return null;
      }

      // Get next tunnel
      var next_tunnel = tunnels.shift();

      // If there IS a next tunnel, try using it.
      if (next_tunnel) {
        tunnel.onerror = null;
        tunnel.oninstruction = null;
        tunnel.onstatechange = null;
        attach(next_tunnel);
      }

      return next_tunnel;
    };

    /**
     * Use the current tunnel from this point forward. Do not try any more
     * tunnels, even if the current tunnel fails.
     *
     * @private
     */
    function commit_tunnel() {
      tunnel.onstatechange = chained_tunnel.onstatechange;
      tunnel.oninstruction = chained_tunnel.oninstruction;
      tunnel.onerror = chained_tunnel.onerror;
      tunnel.onuuid = chained_tunnel.onuuid;

      // Assign UUID if already known
      if (tunnel.uuid) chained_tunnel.setUUID(tunnel.uuid);

      committedTunnel = tunnel;
    }

    // Wrap own onstatechange within current tunnel
    tunnel.onstatechange = function (state) {
      switch (state) {
        // If open, use this tunnel from this point forward.
        case Guacamole.Tunnel.State.OPEN:
          commit_tunnel();
          if (chained_tunnel.onstatechange) chained_tunnel.onstatechange(state);
          break;

        // If closed, mark failure, attempt next tunnel
        case Guacamole.Tunnel.State.CLOSED:
          if (!failTunnel() && chained_tunnel.onstatechange)
            chained_tunnel.onstatechange(state);
          break;
      }
    };

    // Wrap own oninstruction within current tunnel
    tunnel.oninstruction = function (opcode, elements) {
      // Accept current tunnel
      commit_tunnel();

      // Invoke handler
      if (chained_tunnel.oninstruction)
        chained_tunnel.oninstruction(opcode, elements);
    };

    // Attach next tunnel on error
    tunnel.onerror = function (status) {
      // Mark failure, attempt next tunnel
      if (!failTunnel(status) && chained_tunnel.onerror)
        chained_tunnel.onerror(status);
    };

    // Attempt connection
    tunnel.connect(connect_data);
  }

  this.connect = function (data) {
    // Remember connect data
    connect_data = data;

    // Get committed tunnel if exists or the first tunnel on the list
    var next_tunnel = committedTunnel ? committedTunnel : tunnels.shift();

    // Attach first tunnel
    if (next_tunnel) attach(next_tunnel);
    // If there IS no first tunnel, error
    else if (chained_tunnel.onerror)
      chained_tunnel.onerror(
        Guacamole.Status.Code.SERVER_ERROR,
        "No tunnels to try."
      );
  };
};

Guacamole.ChainedTunnel.prototype = new Guacamole.Tunnel();

/**
 * Guacamole Tunnel which replays a Guacamole protocol dump from a static file
 * received via HTTP. Instructions within the file are parsed and handled as
 * quickly as possible, while the file is being downloaded.
 *
 * @constructor
 * @augments Guacamole.Tunnel
 * @param {String} url
 *     The URL of a Guacamole protocol dump.
 *
 * @param {Boolean} [crossDomain=false]
 *     Whether tunnel requests will be cross-domain, and thus must use CORS
 *     mechanisms and headers. By default, it is assumed that tunnel requests
 *     will be made to the same domain.
 *
 * @param {Object} [extraTunnelHeaders={}]
 *     Key value pairs containing the header names and values of any additional
 *     headers to be sent in tunnel requests. By default, no extra headers will
 *     be added.
 */
Guacamole.StaticHTTPTunnel = function StaticHTTPTunnel(
  url,
  crossDomain,
  extraTunnelHeaders
) {
  /**
   * Reference to this Guacamole.StaticHTTPTunnel.
   *
   * @private
   */
  var tunnel = this;

  /**
   * The current, in-progress HTTP request. If no request is currently in
   * progress, this will be null.
   *
   * @private
   * @type {XMLHttpRequest}
   */
  var xhr = null;

  /**
   * Additional headers to be sent in tunnel requests. This dictionary can be
   * populated with key/value header pairs to pass information such as authentication
   * tokens, etc.
   *
   * @private
   */
  var extraHeaders = extraTunnelHeaders || {};

  /**
   * Adds the configured additional headers to the given request.
   *
   * @param {XMLHttpRequest} request
   *     The request where the configured extra headers will be added.
   *
   * @param {Object} headers
   *     The headers to be added to the request.
   *
   * @private
   */
  function addExtraHeaders(request, headers) {
    for (var name in headers) {
      request.setRequestHeader(name, headers[name]);
    }
  }

  this.sendMessage = function sendMessage(elements) {
    // Do nothing
  };

  this.connect = function connect(data) {
    // Ensure any existing connection is killed
    tunnel.disconnect();

    // Connection is now starting
    tunnel.setState(Guacamole.Tunnel.State.CONNECTING);

    // Start a new connection
    xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.withCredentials = !!crossDomain;
    addExtraHeaders(xhr, extraHeaders);
    xhr.responseType = "text";
    xhr.send(null);

    var offset = 0;

    // Create Guacamole protocol parser specifically for this connection
    var parser = new Guacamole.Parser();

    // Invoke tunnel's oninstruction handler for each parsed instruction
    parser.oninstruction = function instructionReceived(opcode, args) {
      if (tunnel.oninstruction) tunnel.oninstruction(opcode, args);
    };

    // Continuously parse received data
    xhr.onreadystatechange = function readyStateChanged() {
      // Parse while data is being received
      if (xhr.readyState === 3 || xhr.readyState === 4) {
        // Connection is open
        tunnel.setState(Guacamole.Tunnel.State.OPEN);

        var buffer = xhr.responseText;
        var length = buffer.length;

        // Parse only the portion of data which is newly received
        if (offset < length) {
          parser.receive(buffer.substring(offset));
          offset = length;
        }
      }

      // Clean up and close when done
      if (xhr.readyState === 4) tunnel.disconnect();
    };

    // Reset state and close upon error
    xhr.onerror = function httpError() {
      // Fail if file could not be downloaded via HTTP
      if (tunnel.onerror)
        tunnel.onerror(
          new Guacamole.Status(
            Guacamole.Status.Code.fromHTTPCode(xhr.status),
            xhr.statusText
          )
        );

      tunnel.disconnect();
    };
  };

  this.disconnect = function disconnect() {
    // Abort and dispose of XHR if a request is in progress
    if (xhr) {
      xhr.abort();
      xhr = null;
    }

    // Connection is now closed
    tunnel.setState(Guacamole.Tunnel.State.CLOSED);
  };
};

Guacamole.StaticHTTPTunnel.prototype = new Guacamole.Tunnel();
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * The unique ID of this version of the Guacamole JavaScript API. This ID will
 * be the version string of the guacamole-common-js Maven project, and can be
 * used in downstream applications as a sanity check that the proper version
 * of the APIs is being used (in case an older version is cached, for example).
 *
 * @type {String}
 */
Guacamole.API_VERSION = "1.3.0";
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Abstract video player which accepts, queues and plays back arbitrary video
 * data. It is up to implementations of this class to provide some means of
 * handling a provided Guacamole.InputStream and rendering the received data to
 * the provided Guacamole.Display.VisibleLayer. Data received along the
 * provided stream is to be played back immediately.
 *
 * @constructor
 */
Guacamole.VideoPlayer = function VideoPlayer() {
  /**
   * Notifies this Guacamole.VideoPlayer that all video up to the current
   * point in time has been given via the underlying stream, and that any
   * difference in time between queued video data and the current time can be
   * considered latency.
   */
  this.sync = function sync() {
    // Default implementation - do nothing
  };
};

/**
 * Determines whether the given mimetype is supported by any built-in
 * implementation of Guacamole.VideoPlayer, and thus will be properly handled
 * by Guacamole.VideoPlayer.getInstance().
 *
 * @param {String} mimetype
 *     The mimetype to check.
 *
 * @returns {Boolean}
 *     true if the given mimetype is supported by any built-in
 *     Guacamole.VideoPlayer, false otherwise.
 */
Guacamole.VideoPlayer.isSupportedType = function isSupportedType(mimetype) {
  // There are currently no built-in video players (and therefore no
  // supported types)
  return false;
};

/**
 * Returns a list of all mimetypes supported by any built-in
 * Guacamole.VideoPlayer, in rough order of priority. Beware that only the core
 * mimetypes themselves will be listed. Any mimetype parameters, even required
 * ones, will not be included in the list.
 *
 * @returns {String[]}
 *     A list of all mimetypes supported by any built-in Guacamole.VideoPlayer,
 *     excluding any parameters.
 */
Guacamole.VideoPlayer.getSupportedTypes = function getSupportedTypes() {
  // There are currently no built-in video players (and therefore no
  // supported types)
  return [];
};

/**
 * Returns an instance of Guacamole.VideoPlayer providing support for the given
 * video format. If support for the given video format is not available, null
 * is returned.
 *
 * @param {Guacamole.InputStream} stream
 *     The Guacamole.InputStream to read video data from.
 *
 * @param {Guacamole.Display.VisibleLayer} layer
 *     The destination layer in which this Guacamole.VideoPlayer should play
 *     the received video data.
 *
 * @param {String} mimetype
 *     The mimetype of the video data in the provided stream.
 *
 * @return {Guacamole.VideoPlayer}
 *     A Guacamole.VideoPlayer instance supporting the given mimetype and
 *     reading from the given stream, or null if support for the given mimetype
 *     is absent.
 */
Guacamole.VideoPlayer.getInstance = function getInstance(
  stream,
  layer,
  mimetype
) {
  // There are currently no built-in video players
  return null;
};

angular.module("templates-main", [
  "app/client/templates/client.html",
  "app/client/templates/connection.html",
  "app/client/templates/connectionGroup.html",
  "app/client/templates/file.html",
  "app/client/templates/guacClient.html",
  "app/client/templates/guacClientPanel.html",
  "app/client/templates/guacFileBrowser.html",
  "app/client/templates/guacFileTransfer.html",
  "app/client/templates/guacFileTransferManager.html",
  "app/client/templates/guacThumbnail.html",
  "app/client/templates/guacViewport.html",
  "app/clipboard/templates/guacClipboard.html",
  "app/element/templates/blank.html",
  "app/form/templates/checkboxField.html",
  "app/form/templates/dateField.html",
  "app/form/templates/emailField.html",
  "app/form/templates/form.html",
  "app/form/templates/formField.html",
  "app/form/templates/guacInputColor.html",
  "app/form/templates/languageField.html",
  "app/form/templates/numberField.html",
  "app/form/templates/passwordField.html",
  "app/form/templates/redirectField.html",
  "app/form/templates/selectField.html",
  "app/form/templates/terminalColorSchemeField.html",
  "app/form/templates/textAreaField.html",
  "app/form/templates/textField.html",
  "app/form/templates/timeField.html",
  "app/form/templates/timeZoneField.html",
  "app/groupList/templates/guacGroupList.html",
  "app/groupList/templates/guacGroupListFilter.html",
  "app/home/templates/connection.html",
  "app/home/templates/connectionGroup.html",
  "app/home/templates/guacRecentConnections.html",
  "app/home/templates/home.html",
  "app/list/templates/guacFilter.html",
  "app/list/templates/guacPager.html",
  "app/list/templates/guacUserItem.html",
  "app/login/templates/login.html",
  "app/manage/templates/connectionGroupPermission.html",
  "app/manage/templates/connectionPermission.html",
  "app/manage/templates/connectionPermissionEditor.html",
  "app/manage/templates/dataSourceTabs.html",
  "app/manage/templates/identifierSetEditor.html",
  "app/manage/templates/locationChooser.html",
  "app/manage/templates/locationChooserConnectionGroup.html",
  "app/manage/templates/manageConnection.html",
  "app/manage/templates/manageConnectionGroup.html",
  "app/manage/templates/manageSharingProfile.html",
  "app/manage/templates/manageUser.html",
  "app/manage/templates/manageUserGroup.html",
  "app/manage/templates/managementButtons.html",
  "app/manage/templates/sharingProfilePermission.html",
  "app/manage/templates/systemPermissionEditor.html",
  "app/navigation/templates/guacMenu.html",
  "app/navigation/templates/guacPageList.html",
  "app/navigation/templates/guacSectionTabs.html",
  "app/navigation/templates/guacUserMenu.html",
  "app/notification/templates/guacNotification.html",
  "app/osk/templates/guacOsk.html",
  "app/settings/templates/connection.html",
  "app/settings/templates/connectionGroup.html",
  "app/settings/templates/newConnection.html",
  "app/settings/templates/newConnectionGroup.html",
  "app/settings/templates/newSharingProfile.html",
  "app/settings/templates/settings.html",
  "app/settings/templates/settingsConnectionHistory.html",
  "app/settings/templates/settingsConnections.html",
  "app/settings/templates/settingsPreferences.html",
  "app/settings/templates/settingsSessions.html",
  "app/settings/templates/settingsUserGroups.html",
  "app/settings/templates/settingsUsers.html",
  "app/settings/templates/sharingProfile.html",
  "app/textInput/templates/guacKey.html",
  "app/textInput/templates/guacTextInput.html",
]);

angular.module("app/client/templates/client.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/client/templates/client.html",
      "<guac-viewport><div class=client-view><div class=client-view-content><div class=client-body guac-touch-drag=clientDrag guac-touch-pinch=clientPinch><guac-client client=client></guac-client><div id=other-connections><guac-client-panel clients=otherClients></guac-client-panel></div></div><div class=client-bottom><div class=text-input-container ng-if=showTextInput><guac-text-input></guac-text-input></div><div class=keyboard-container ng-if=showOSK><guac-osk layout=\"'CLIENT.URL_OSK_LAYOUT' | translate\"></guac-osk></div></div></div></div><div id=file-transfer-dialog ng-show=hasTransfers()><guac-file-transfer-manager client=client></guac-file-transfer-manager></div><div id=connection-warning ng-show=isConnectionUnstable()>{{'CLIENT.TEXT_CLIENT_STATUS_UNSTABLE' | translate}}</div><div class=menu ng-class=\"{open: menu.shown}\" id=guac-menu><div class=menu-content ng-if=menu.shown><div class=header><h2 ng-hide=rootConnectionGroups>{{client.name}}</h2><h2 class=connection-select-menu ng-show=rootConnectionGroups><guac-menu menu-title=client.name interactive=true><div class=all-connections><guac-group-list-filter connection-groups=rootConnectionGroups filtered-connection-groups=filteredRootConnectionGroups placeholder=\"'CLIENT.FIELD_PLACEHOLDER_FILTER' | translate\" connection-properties=filteredConnectionProperties connection-group-properties=filteredConnectionGroupProperties></guac-group-list-filter><guac-group-list connection-groups=filteredRootConnectionGroups templates=\"{'connection': 'app/client/templates/connection.html','connection-group' : 'app/client/templates/connectionGroup.html'}\" page-size=10></guac-group-list></div></guac-menu></h2><div class=share-menu ng-show=canShareConnection()><guac-menu menu-title=\"'CLIENT.ACTION_SHARE' | translate\"><ul ng-repeat=\"sharingProfile in sharingProfiles\"><li><a ng-click=share(sharingProfile)>{{sharingProfile.name}}</a></li></ul></guac-menu></div><guac-user-menu local-actions=clientMenuActions></guac-user-menu></div><div class=menu-body guac-touch-drag=menuDrag guac-scroll=menu.scrollState><div class=menu-section id=share-links ng-show=isShared()><div class=content><h3>{{'CLIENT.INFO_CONNECTION_SHARED' | translate}}</h3><p class=description translate=CLIENT.HELP_SHARE_LINK translate-values=\"{LINKS : getShareLinkCount()}\"></p><table><tr ng-repeat=\"link in client.shareLinks | toArray | orderBy: value.name\"><th>{{link.value.name}}</th><td><a href={{link.value.href}} target=_blank>{{link.value.href}}</a></td></tr></table></div></div><div class=menu-section id=clipboard-settings><h3>{{'CLIENT.SECTION_HEADER_CLIPBOARD' | translate}}</h3><div class=content><p class=description>{{'CLIENT.HELP_CLIPBOARD' | translate}}</p><guac-clipboard data=client.clipboardData></guac-clipboard></div></div><div class=menu-section id=devices ng-show=client.filesystems.length><h3>{{'CLIENT.SECTION_HEADER_DEVICES' | translate}}</h3><div class=content><div class=\"device filesystem\" ng-repeat=\"filesystem in client.filesystems\" ng-click=showFilesystemMenu(filesystem)>{{filesystem.name}}</div></div></div><div class=\"menu-section connection-parameters\" id=connection-settings ng-show=client.protocol><guac-form namespace=getProtocolNamespace(client.protocol) content=client.forms model=menu.connectionParameters model-only=true></guac-form></div><div class=menu-section id=keyboard-settings><h3>{{'CLIENT.SECTION_HEADER_INPUT_METHOD' | translate}}</h3><div class=content><div class=choice><label><input id=ime-none name=input-method ng-change=closeMenu() ng-model=menu.inputMethod type=radio value=none> {{'CLIENT.NAME_INPUT_METHOD_NONE' | translate}}</label><p class=caption><label for=ime-none>{{'CLIENT.HELP_INPUT_METHOD_NONE' | translate}}</label></p></div><div class=choice><div class=figure><label for=ime-text><img src=images/settings/tablet-keys.png alt=\"\"></label></div><label><input id=ime-text name=input-method ng-change=closeMenu() ng-model=menu.inputMethod type=radio value=text> {{'CLIENT.NAME_INPUT_METHOD_TEXT' | translate}}</label><p class=caption><label for=ime-text>{{'CLIENT.HELP_INPUT_METHOD_TEXT' | translate}}</label></p></div><div class=choice><label><input id=ime-osk name=input-method ng-change=closeMenu() ng-model=menu.inputMethod type=radio value=osk> {{'CLIENT.NAME_INPUT_METHOD_OSK' | translate}}</label><p class=caption><label for=ime-osk>{{'CLIENT.HELP_INPUT_METHOD_OSK' | translate}}</label></p></div></div></div><div class=menu-section id=mouse-settings><h3>{{'CLIENT.SECTION_HEADER_MOUSE_MODE' | translate}}</h3><div class=content><p class=description>{{'CLIENT.HELP_MOUSE_MODE' | translate}}</p><div class=choice><input name=mouse-mode ng-change=closeMenu() ng-model=client.clientProperties.emulateAbsoluteMouse type=radio ng-value=true checked=checked id=absolute><div class=figure><label for=absolute><img src=images/settings/touchscreen.png alt=\"{{'CLIENT.NAME_MOUSE_MODE_ABSOLUTE' | translate}}\"></label><p class=caption><label for=absolute>{{'CLIENT.HELP_MOUSE_MODE_ABSOLUTE' | translate}}</label></p></div></div><div class=choice><input name=mouse-mode ng-change=closeMenu() ng-model=client.clientProperties.emulateAbsoluteMouse type=radio ng-value=false id=relative><div class=figure><label for=relative><img src=images/settings/touchpad.png alt=\"{{'CLIENT.NAME_MOUSE_MODE_RELATIVE' | translate}}\"></label><p class=caption><label for=relative>{{'CLIENT.HELP_MOUSE_MODE_RELATIVE' | translate}}</label></p></div></div></div></div><div class=menu-section id=display-settings><h3>{{'CLIENT.SECTION_HEADER_DISPLAY' | translate}}</h3><div class=content><div id=zoom-settings><div ng-click=zoomOut() id=zoom-out><img src=images/settings/zoom-out.png alt=-></div><div class=zoom-ctrl><input type=number class=zoom-ctrl guac-zoom-ctrl ng-model=client.clientProperties.scale ng-model-options=\"{ updateOn: 'blur submit' }\" ng-change=zoomSet()>%</div><div ng-click=zoomIn() id=zoom-in><img src=images/settings/zoom-in.png alt=+></div></div><div><label><input ng-model=menu.autoFit ng-change=changeAutoFit() ng-disabled=autoFitDisabled() type=checkbox id=auto-fit> {{'CLIENT.TEXT_ZOOM_AUTO_FIT' | translate}}</label></div></div></div></div></div></div><div id=filesystem-menu class=menu ng-class=\"{open: isFilesystemMenuShown()}\"><div class=menu-content><div class=header><h2>{{filesystemMenuContents.name}}</h2><button class=\"upload button\" guac-upload=uploadFiles>{{'CLIENT.ACTION_UPLOAD_FILES' | translate}}</button><button class=back ng-click=hideFilesystemMenu()>{{'CLIENT.ACTION_NAVIGATE_BACK' | translate}}</button></div><div class=\"header breadcrumbs\"><div class=\"breadcrumb root\" ng-click=\"changeDirectory(filesystemMenuContents, filesystemMenuContents.root)\"></div><div class=breadcrumb ng-repeat=\"file in getPath(filesystemMenuContents.currentDirectory)\" ng-click=\"changeDirectory(filesystemMenuContents, file)\">{{file.name}}</div></div><div class=menu-body><guac-file-browser client=client filesystem=filesystemMenuContents></guac-file-browser></div></div></div></guac-viewport>"
    );
  },
]);
angular.module("app/client/templates/connection.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/client/templates/connection.html",
      '<a class=connection ng-href="{{ item.getClientURL() }}"><div class="icon type" ng-class=item.protocol></div><span class=name>{{item.name}}</span></a>'
    );
  },
]);
angular.module("app/client/templates/connectionGroup.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/client/templates/connectionGroup.html",
      '<a class=connection-group ng-href="{{ item.getClientURL() }}"><div ng-show=item.balancing class="icon type balancer"></div><span class=name>{{item.name}}</span></a>'
    );
  },
]);
angular.module("app/client/templates/file.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/client/templates/file.html",
      "<div class=list-item><div class=caption><div class=icon></div>{{::name}}</div></div>"
    );
  },
]);
angular.module("app/client/templates/guacClient.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/client/templates/guacClient.html",
      '<div class=main guac-resize=mainElementResized><div class=displayOuter><div class=displayMiddle><div class="display software-cursor"></div></div></div></div>'
    );
  },
]);
angular.module("app/client/templates/guacClientPanel.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/client/templates/guacClientPanel.html",
      "<div class=client-panel ng-class=\"{ 'has-clients': hasClients(), 'hidden' : panelHidden() }\"><div class=client-panel-handle ng-click=togglePanel()></div><ul class=client-panel-connection-list><li ng-repeat=\"client in clients | toArray | orderBy: [ '-value.lastUsed', 'value.title' ]\" ng-class=\"{ 'needs-attention' : hasStatusUpdate(client.value) }\" ng-show=isManaged(client.value) class=client-panel-connection><button class=close-other-connection ng-click=disconnect(client.value)><img ng-attr-alt=\"{{ 'CLIENT.ACTION_DISCONNECT' | translate }}\" ng-attr-title=\"{{ 'CLIENT.ACTION_DISCONNECT' | translate }}\" src=images/x.png></button><a href=#/client/{{client.value.id}}><div class=thumbnail><guac-thumbnail client=client.value></guac-thumbnail></div><div class=name>{{ client.value.title }}</div></a></li></ul></div>"
    );
  },
]);
angular.module("app/client/templates/guacFileBrowser.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/client/templates/guacFileBrowser.html",
      "<div class=file-browser><div class=current-directory-contents></div></div>"
    );
  },
]);
angular.module("app/client/templates/guacFileTransfer.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/client/templates/guacFileTransfer.html",
      "<div class=transfer ng-class=\"{'in-progress': isInProgress(), 'savable': isSavable(), 'error': hasError()}\" ng-click=save()><div class=transfer-status><div class=filename><div class=progress><div ng-style=\"{'width': getPercentDone() + '%'}\" class=bar></div></div>{{transfer.filename}}</div><p class=error-text>{{getErrorText() | translate}}</p></div><div class=text translate=CLIENT.TEXT_FILE_TRANSFER_PROGRESS translate-values=\"{PROGRESS: getProgressValue(), UNIT: getProgressUnit()}\"></div></div>"
    );
  },
]);
angular.module("app/client/templates/guacFileTransferManager.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/client/templates/guacFileTransferManager.html",
      "<div class=transfer-manager><div class=header><h2>{{'CLIENT.SECTION_HEADER_FILE_TRANSFERS' | translate}}</h2><button ng-click=clearCompletedTransfers()>{{'CLIENT.ACTION_CLEAR_COMPLETED_TRANSFERS' | translate}}</button></div><div class=transfer-manager-body><div class=transfers><guac-file-transfer transfer=upload ng-repeat=\"upload in client.uploads\"></guac-file-transfer><guac-file-transfer transfer=download ng-repeat=\"download in client.downloads\"></guac-file-transfer></div></div></div>"
    );
  },
]);
angular.module("app/client/templates/guacThumbnail.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/client/templates/guacThumbnail.html",
      '<div class=thumbnail-main guac-resize=updateDisplayScale><div class=display></div><img alt="" ng-src={{thumbnail}}></div>'
    );
  },
]);
angular.module("app/client/templates/guacViewport.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/client/templates/guacViewport.html",
      "<div class=viewport ng-transclude></div>"
    );
  },
]);
angular.module("app/clipboard/templates/guacClipboard.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/clipboard/templates/guacClipboard.html",
      "<textarea class=clipboard></textarea>"
    );
  },
]);
angular.module("app/element/templates/blank.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/element/templates/blank.html",
      '<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=UTF-8"><title>_</title></head><body></body></html>'
    );
  },
]);
angular.module("app/form/templates/checkboxField.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/form/templates/checkboxField.html",
      '<input type=checkbox ng-attr-id="{{ fieldId }}" ng-disabled=disabled ng-model=typedValue guac-focus=focused autocorrect=off autocapitalize=off>'
    );
  },
]);
angular.module("app/form/templates/dateField.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/form/templates/dateField.html",
      '<div class=date-field><input type=date ng-disabled=disabled ng-attr-id="{{ fieldId }}" ng-model=typedValue ng-model-options=modelOptions guac-lenient-date guac-focus=focused placeholder="{{\'FORM.FIELD_PLACEHOLDER_DATE\' | translate}}" autocorrect=off autocapitalize=off></div>'
    );
  },
]);
angular.module("app/form/templates/emailField.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/form/templates/emailField.html",
      '<div class=email-field><input type=email ng-disabled=disabled ng-attr-id="{{ fieldId }}" ng-model=model ng-hide=readOnly guac-focus=focused autocorrect=off autocapitalize=off><a href=mailto:{{model}} ng-show=readOnly>{{model}}</a></div>'
    );
  },
]);
angular.module("app/form/templates/form.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/form/templates/form.html",
      '<div class=form-group><div ng-repeat="form in forms" class=form ng-show=containsVisible(form.fields)><h3 ng-show=form.name>{{getSectionHeader(form) | translate}}</h3><div class=fields><guac-form-field ng-repeat="field in form.fields" namespace=namespace ng-if=isVisible(field) data-disabled=disabled focused=isFocused(field) field=field model=values[field.name]></guac-form-field></div></div></div>'
    );
  },
]);
angular.module("app/form/templates/formField.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/form/templates/formField.html",
      '<div class=labeled-field ng-class="{empty: !model}" ng-show=isFieldVisible()><div class=field-header><label ng-attr-for="{{ fieldId }}">{{getFieldHeader() | translate}}</label></div><div class=form-field></div></div>'
    );
  },
]);
angular.module("app/form/templates/guacInputColor.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/form/templates/guacInputColor.html",
      "<div class=guac-input-color ng-class=\"{'dark' : isDark(),'read-only' : !isColorPickerAvailable()}\" ng-click=selectColor() ng-style=\"{'background-color' : model}\"><ng-transclude></ng-transclude></div>"
    );
  },
]);
angular.module("app/form/templates/languageField.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/form/templates/languageField.html",
      '<select guac-focus=focused ng-attr-id="{{ fieldId }}" ng-model=model ng-options="language.key as language.value for language in languages | toArray | orderBy: key"></select>'
    );
  },
]);
angular.module("app/form/templates/numberField.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/form/templates/numberField.html",
      '<input type=number ng-disabled=disabled ng-attr-id="{{ fieldId }}" ng-model=typedValue guac-focus=focused autocorrect=off autocapitalize=off>'
    );
  },
]);
angular.module("app/form/templates/passwordField.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/form/templates/passwordField.html",
      '<div class=password-field><input type={{passwordInputType}} ng-disabled=disabled ng-attr-id="{{ fieldId }}" ng-model=model ng-trim=false guac-focus=focused autocorrect=off autocapitalize=off><div class="icon toggle-password" ng-click=togglePassword() title="{{getTogglePasswordHelpText() | translate}}"></div></div>'
    );
  },
]);
angular.module("app/form/templates/redirectField.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/form/templates/redirectField.html",
      "<div class=redirect-field-container><div class=redirect-field><p ng-show=field.translatableMessage translate={{field.translatableMessage.key}} translate-values={{field.translatableMessage.variables}}></p></div></div>"
    );
  },
]);
angular.module("app/form/templates/selectField.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/form/templates/selectField.html",
      '<select ng-attr-id="{{ fieldId }}" ng-disabled=disabled guac-focus=focused ng-model=model ng-options="option as getFieldOption(option) | translate for option in field.options | orderBy: value"></select>'
    );
  },
]);
angular.module("app/form/templates/terminalColorSchemeField.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/form/templates/terminalColorSchemeField.html",
      '<div class=terminal-color-scheme-field ng-class="{\'custom-color-scheme-details-visible\' : detailsShown,\'custom-color-scheme-details-hidden\' : !detailsShown}"><select ng-attr-id="{{ fieldId }}" ng-model=selectedColorScheme><option ng-repeat="option in field.options | orderBy: value" ng-value=option>{{ getFieldOption(option) | translate }}</option><option value=custom>{{ \'COLOR_SCHEME.FIELD_OPTION_CUSTOM\' | translate }}</option></select><div class=custom-color-scheme ng-show=isCustom()><div class="custom-color-scheme-section default-color foreground"><guac-input-color model=customColorScheme.foreground palette=defaultPalette>{{ \'COLOR_SCHEME.FIELD_HEADER_FOREGROUND\' | translate }}</guac-input-color></div><div class="custom-color-scheme-section default-color background"><guac-input-color model=customColorScheme.background palette=defaultPalette>{{ \'COLOR_SCHEME.FIELD_HEADER_BACKGROUND\' | translate }}</guac-input-color></div><div class="custom-color-scheme-section palette low-intensity"><guac-input-color ng-repeat="index in lowIntensity" model=customColorScheme.colors[index] palette=defaultPalette>{{ index }}</guac-input-color></div><div class="custom-color-scheme-section palette high-intensity"><guac-input-color ng-repeat="index in highIntensity" model=customColorScheme.colors[index] palette=defaultPalette>{{ index }}</guac-input-color></div></div><h4 class=custom-color-scheme-details-header ng-show=isCustom()>{{\'COLOR_SCHEME.SECTION_HEADER_DETAILS\' | translate}}<a class=custom-color-scheme-show-details ng-click=showDetails()>{{\'COLOR_SCHEME.ACTION_SHOW_DETAILS\' | translate}}</a><a class=custom-color-scheme-hide-details ng-click=hideDetails()>{{\'COLOR_SCHEME.ACTION_HIDE_DETAILS\' | translate}}</a></h4><textarea class=custom-color-scheme-details spellcheck=false ng-model=model ng-show=isCustom()></textarea></div>'
    );
  },
]);
angular.module("app/form/templates/textAreaField.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/form/templates/textAreaField.html",
      '<textarea ng-attr-id="{{ fieldId }}" ng-model=model ng-disabled=disabled guac-focus=focused autocorrect=off autocapitalize=off></textarea>'
    );
  },
]);
angular.module("app/form/templates/textField.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/form/templates/textField.html",
      '<div class=text-field><input type=text ng-attr-id="{{ fieldId }}" ng-attr-list="{{ dataListId }}" ng-model=model ng-disabled=disabled guac-focus=focused autocorrect=off autocapitalize=off><datalist ng-if=dataListId ng-attr-id="{{ dataListId }}"><option ng-repeat="option in field.options | orderBy: option" value="{{ option }}">{{ getFieldOption(option) | translate }}</option></datalist></div>'
    );
  },
]);
angular.module("app/form/templates/timeField.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/form/templates/timeField.html",
      '<div class=time-field><input type=time ng-disabled=disabled ng-attr-id="{{ fieldId }}" ng-model=typedValue ng-model-options=modelOptions guac-focus=focused guac-lenient-time placeholder="{{\'FORM.FIELD_PLACEHOLDER_TIME\' | translate}}" autocorrect=off autocapitalize=off></div>'
    );
  },
]);
angular.module("app/form/templates/timeZoneField.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/form/templates/timeZoneField.html",
      '<div class=time-zone-field><select class=time-zone-region ng-disabled=disabled guac-focus=focused ng-attr-id="{{ fieldId }}" ng-model=region ng-options="name for name in regions | orderBy: name"></select><select class=time-zone ng-disabled="disabled || !region" ng-model=model ng-options="timeZone.value as timeZone.key for timeZone in timeZones[region] | toArray | orderBy: key"></select></div>'
    );
  },
]);
angular.module("app/groupList/templates/guacGroupList.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/groupList/templates/guacGroupList.html",
      '<div class=group-list><script type=text/ng-template id=nestedItem.html><div class={{item.type}} ng-if=isVisible(item.type) ng-class="{balancer: item.balancing,expanded: item.expanded,expandable : item.expandable,empty: !item.children.length}"><div class=caption><div class="icon expand" ng-click=toggleExpanded(item) ng-if=item.expandable></div><ng-include src=templates[item.type]></div><div class=children ng-if=item.expanded><div class=list-item ng-repeat="item in item.children | orderBy : \'name\'" ng-include="\'nestedItem.html\'"></div></div></div></script><div class=group-list-page><div class=list-item ng-repeat="item in childrenPage" ng-include="\'nestedItem.html\'"></div></div><guac-pager page=childrenPage items="rootItems | orderBy : [\'weight\', \'name\']" page-size=pageSize></guac-pager></div>'
    );
  },
]);
angular.module("app/groupList/templates/guacGroupListFilter.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/groupList/templates/guacGroupListFilter.html",
      '<div class="group-list-filter filter"><input class=search-string placeholder={{placeholder()}} type=text ng-model=searchString></div>'
    );
  },
]);
angular.module("app/home/templates/connection.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/home/templates/connection.html",
      '<a class=home-connection ng-href="{{ item.getClientURL() }}" ng-class="{active: item.getActiveConnections()}"><div class="icon type" ng-class=item.protocol></div><span class=name>{{item.name}}</span><span class=activeUserCount ng-show=item.getActiveConnections() translate=HOME.INFO_ACTIVE_USER_COUNT translate-values="{USERS: item.getActiveConnections()}"></span></a>'
    );
  },
]);
angular.module("app/home/templates/connectionGroup.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/home/templates/connectionGroup.html",
      '<a class=home-connection-group ng-href="{{ item.getClientURL() }}"><div ng-show=item.balancing class="icon type balancer"></div><span class=name>{{item.name}}</span></a>'
    );
  },
]);
angular.module("app/home/templates/guacRecentConnections.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/home/templates/guacRecentConnections.html",
      '<div><p class=placeholder ng-hide=hasRecentConnections()>{{\'HOME.INFO_NO_RECENT_CONNECTIONS\' | translate}}</p><div ng-repeat="activeConnection in activeConnections" class=connection><a href=#/client/{{activeConnection.client.id}}><div class=thumbnail><guac-thumbnail client=activeConnection.client></guac-thumbnail></div><div class=caption><span class=name>{{activeConnection.name}}</span></div></a></div><div ng-repeat="recentConnection in recentConnections" class=connection><a href=#/client/{{recentConnection.entry.id}}><div class=thumbnail><img alt={{recentConnection.name}} ng-src={{recentConnection.entry.thumbnail}}></div><div class=caption><span class=name>{{recentConnection.name}}</span></div></a></div></div>'
    );
  },
]);
angular.module("app/home/templates/home.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/home/templates/home.html",
      "<div class=view ng-class=\"{loading: !isLoaded()}\"><div class=connection-list-ui><div class=header><h2>{{'HOME.SECTION_HEADER_RECENT_CONNECTIONS' | translate}}</h2><guac-user-menu></guac-user-menu></div><div class=recent-connections><guac-recent-connections root-groups=rootConnectionGroups></guac-recent-connections></div><div class=header><h2>{{'HOME.SECTION_HEADER_ALL_CONNECTIONS' | translate}}</h2><guac-group-list-filter connection-groups=rootConnectionGroups filtered-connection-groups=filteredRootConnectionGroups placeholder=\"'HOME.FIELD_PLACEHOLDER_FILTER' | translate\" connection-properties=filteredConnectionProperties connection-group-properties=filteredConnectionGroupProperties></guac-group-list-filter></div><div class=all-connections><guac-group-list connection-groups=filteredRootConnectionGroups templates=\"{'connection': 'app/home/templates/connection.html','connection-group' : 'app/home/templates/connectionGroup.html'}\" page-size=20></guac-group-list></div></div></div>"
    );
  },
]);
angular.module("app/list/templates/guacFilter.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/list/templates/guacFilter.html",
      "<div class=filter><input class=search-string placeholder={{placeholder()}} type=text ng-model=searchString></div>"
    );
  },
]);
angular.module("app/list/templates/guacPager.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/list/templates/guacPager.html",
      '<div class=pager ng-show="pageNumbers.length > 1"><div class="first-page icon" ng-class="{disabled: !canSelectPage(firstPage)}" ng-click=selectPage(firstPage)><div class="prev-page icon" ng-class="{disabled: !canSelectPage(previousPage)}" ng-click=selectPage(previousPage)><div class=more-pages ng-show=hasMorePagesBefore()>...</div><ul class=page-numbers><li class=set-page ng-class="{current: isSelected(pageNumber)}" ng-repeat="pageNumber in pageNumbers" ng-click=selectPage(pageNumber)>{{pageNumber}}</li></ul><div class=more-pages ng-show=hasMorePagesAfter()>...</div><div class="next-page icon" ng-class="{disabled: !canSelectPage(nextPage)}" ng-click=selectPage(nextPage)><div class="last-page icon" ng-class="{disabled: !canSelectPage(lastPage)}" ng-click=selectPage(lastPage)></div>'
    );
  },
]);
angular.module("app/list/templates/guacUserItem.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/list/templates/guacUserItem.html",
      "<div class=user-item ng-class=\"{'anonymous' : isAnonymous() }\"><span class=username>{{displayName}}</span></div>"
    );
  },
]);
angular.module("app/login/templates/login.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/login/templates/login.html",
      "<div class=login-ui ng-class=\"{error: loginError, continuation: isContinuation(), initial: !isContinuation()}\"><p class=login-error translate={{loginError.key}} translate-values={{loginError.variables}}></p><div class=login-dialog-middle><div class=login-dialog><form class=login-form ng-submit=login()><div class=logo></div><div class=version><div class=app-name>{{'APP.NAME' | translate}}</div><div class=version-number>{{'APP.VERSION' | translate}}</div></div><p ng-show=helpText translate={{helpText.key}} translate-values={{helpText.variables}}></p><div class=login-fields><guac-form namespace=\"'LOGIN'\" content=remainingFields model=enteredValues focused=relevantField.name data-disabled=submitted></guac-form></div><div class=buttons><input type=submit name=login class=login ng-disabled=submitted value=\"{{'LOGIN.ACTION_LOGIN' | translate}}\"> <input type=submit name=login class=continue-login ng-disabled=submitted value=\"{{'LOGIN.ACTION_CONTINUE' | translate}}\"></div></form></div></div></div>"
    );
  },
]);
angular.module("app/manage/templates/connectionGroupPermission.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/manage/templates/connectionGroupPermission.html",
      '<div class=choice><div class="icon type"></div><input type=checkbox ng-model=context.getPermissionFlags().connectionGroupPermissions.READ[item.identifier] ng-change=context.connectionGroupPermissionChanged(item.identifier)><span class=name>{{item.name}}</span></div>'
    );
  },
]);
angular.module("app/manage/templates/connectionPermission.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/manage/templates/connectionPermission.html",
      '<div class=choice><div class="icon type" ng-class=item.protocol></div><input type=checkbox ng-model=context.getPermissionFlags().connectionPermissions.READ[item.identifier] ng-change=context.connectionPermissionChanged(item.identifier)><span class=name>{{item.name}}</span></div>'
    );
  },
]);
angular.module("app/manage/templates/connectionPermissionEditor.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/manage/templates/connectionPermissionEditor.html",
      "<div class=connection-permissions><div class=\"header tabbed\"><h2>{{'MANAGE_USER.SECTION_HEADER_CONNECTIONS' | translate}}</h2><guac-group-list-filter connection-groups=getRootGroups() filtered-connection-groups=filteredRootGroups placeholder=\"'MANAGE_USER.FIELD_PLACEHOLDER_FILTER' | translate\" connection-properties=filteredConnectionProperties connection-group-properties=filteredConnectionGroupProperties></guac-group-list-filter></div><guac-section-tabs namespace=MANAGE_USER current=currentTab tabs=tabs></guac-section-tabs><div class=section><guac-group-list context=groupListContext connection-groups=filteredRootGroups templates=\"{'connection': 'app/manage/templates/connectionPermission.html','sharing-profile': 'app/manage/templates/sharingProfilePermission.html','connection-group' : 'app/manage/templates/connectionGroupPermission.html'}\" page-size=20></guac-group-list></div></div>"
    );
  },
]);
angular.module("app/manage/templates/dataSourceTabs.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/manage/templates/dataSourceTabs.html",
      "<div class=page-tabs><guac-page-list pages=pages></guac-page-list></div>"
    );
  },
]);
angular.module("app/manage/templates/identifierSetEditor.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/manage/templates/identifierSetEditor.html",
      '<div class=related-objects ng-hide=isEmpty()><div class=header><h2>{{ header | translate }}</h2><div class=filter><input class=search-string type=text placeholder="{{ \'SETTINGS_USERS.FIELD_PLACEHOLDER_FILTER\' | translate }}" ng-model=filterString></div></div><div class=section><div class=abbreviated-related-objects><img src=images/arrows/right.png alt=Expand class=expand ng-hide=expanded ng-click=expand()> <img src=images/arrows/down.png alt=Collapse class=collapse ng-show=expanded ng-click=collapse()><p ng-hide=identifiers.length class=no-related-objects>{{ emptyPlaceholder | translate }}</p><ul><li ng-repeat="identifier in identifiers | filter: filterString"><label><img src=images/x-red.png alt=Remove class=remove ng-click=removeIdentifier(identifier) ng-show=isEditable[identifier]><span class=identifier>{{ identifier }}</span></label></li></ul></div><div class=all-related-objects ng-show=expanded><p ng-hide=identifiersAvailablePage.length class=no-objects-available>{{ unavailablePlaceholder | translate }}</p><ul><li ng-repeat="identifier in identifiersAvailablePage"><label><input type=checkbox ng-model=identifierFlags[identifier] ng-change=identifierChanged(identifier)><span class=identifier>{{ identifier }}</span></label></li></ul><guac-pager page=identifiersAvailablePage page-size=25 items="identifiersAvailable | orderBy | filter: filterString"></guac-pager></div></div></div>'
    );
  },
]);
angular.module("app/manage/templates/locationChooser.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/manage/templates/locationChooser.html",
      "<div class=location-chooser><div ng-click=toggleMenu() class=location>{{chosenConnectionGroupName}}</div><div ng-show=menuOpen class=dropdown><guac-group-list context=groupListContext show-root-group=true connection-groups=rootGroups templates=\"{'connection-group' : 'app/manage/templates/locationChooserConnectionGroup.html'}\"></div></div>"
    );
  },
]);
angular
  .module("app/manage/templates/locationChooserConnectionGroup.html", [])
  .run([
    "$templateCache",
    function ($templateCache) {
      $templateCache.put(
        "app/manage/templates/locationChooserConnectionGroup.html",
        "<span class=name ng-click=context.chooseGroup(item.wrappedItem)>{{item.name}}</span>"
      );
    },
  ]);
angular.module("app/manage/templates/manageConnection.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/manage/templates/manageConnection.html",
      "<div class=view ng-class=\"{loading: !isLoaded()}\"><div class=header><h2>{{'MANAGE_CONNECTION.SECTION_HEADER_EDIT_CONNECTION' | translate}}</h2><guac-user-menu></guac-user-menu></div><div class=section><table class=properties><tr><th>{{'MANAGE_CONNECTION.FIELD_HEADER_NAME' | translate}}</th><td><input type=text ng-model=connection.name autocorrect=off autocapitalize=off></td></tr><tr><th>{{'MANAGE_CONNECTION.FIELD_HEADER_LOCATION' | translate}}</th><td><location-chooser data-data-source=selectedDataSource root-group=rootGroup value=connection.parentIdentifier></location-chooser></td></tr><tr><th>{{'MANAGE_CONNECTION.FIELD_HEADER_PROTOCOL' | translate}}</th><td><select ng-model=connection.protocol ng-options=\"protocol.value.name as getProtocolName(protocol.value.name) | translate for protocol in protocols | toArray | orderBy: value.name\"></select></td></tr></table></div><div class=attributes><guac-form namespace=\"'CONNECTION_ATTRIBUTES'\" content=attributes model=connection.attributes model-only=!managementPermissions.canChangeAllAttributes></guac-form></div><h2 class=header>{{'MANAGE_CONNECTION.SECTION_HEADER_PARAMETERS' | translate}}</h2><div class=\"section connection-parameters\" ng-class=\"{loading: !parameters}\"><guac-form namespace=getNamespace(connection.protocol) content=protocols[connection.protocol].connectionForms model=parameters></guac-form></div><management-buttons namespace=MANAGE_CONNECTION permissions=managementPermissions save=saveConnection() delete=deleteConnection() clone=cloneConnection() return=returnToConnectionList()></management-buttons><h2 class=header>{{'MANAGE_CONNECTION.SECTION_HEADER_HISTORY' | translate}}</h2><div class=\"history section\" ng-class=\"{loading: !historyEntryWrappers}\"><p ng-hide=historyEntryWrappers.length>{{'MANAGE_CONNECTION.INFO_CONNECTION_NOT_USED' | translate}}</p><table ng-show=historyEntryWrappers.length><thead><tr><th>{{'MANAGE_CONNECTION.TABLE_HEADER_HISTORY_USERNAME' | translate}}</th><th>{{'MANAGE_CONNECTION.TABLE_HEADER_HISTORY_START' | translate}}</th><th>{{'MANAGE_CONNECTION.TABLE_HEADER_HISTORY_DURATION' | translate}}</th><th>{{'MANAGE_CONNECTION.TABLE_HEADER_HISTORY_REMOTEHOST' | translate}}</th></tr></thead><tbody><tr ng-repeat=\"wrapper in wrapperPage\"><td class=username><guac-user-item username=wrapper.entry.username></guac-user-item></td><td class=start>{{wrapper.entry.startDate | date:historyDateFormat}}</td><td class=duration translate={{wrapper.durationText}} translate-values=\"{VALUE: wrapper.duration.value, UNIT: wrapper.duration.unit}\"></td><td class=remoteHost>{{wrapper.entry.remoteHost}}</td></tr></tbody></table><guac-pager page=wrapperPage items=historyEntryWrappers></guac-pager></div></div>"
    );
  },
]);
angular.module("app/manage/templates/manageConnectionGroup.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/manage/templates/manageConnectionGroup.html",
      "<div class=view ng-class=\"{loading: !isLoaded()}\"><div class=header><h2>{{'MANAGE_CONNECTION_GROUP.SECTION_HEADER_EDIT_CONNECTION_GROUP' | translate}}</h2><guac-user-menu></guac-user-menu></div><div class=section><table class=properties><tr><th>{{'MANAGE_CONNECTION_GROUP.FIELD_HEADER_NAME' | translate}}</th><td><input type=text ng-model=connectionGroup.name autocorrect=off autocapitalize=off></td></tr><tr><th>{{'MANAGE_CONNECTION_GROUP.FIELD_HEADER_LOCATION' | translate}}</th><td><location-chooser data-data-source=selectedDataSource root-group=rootGroup value=connectionGroup.parentIdentifier></location-chooser></td></tr><tr><th>{{'MANAGE_CONNECTION_GROUP.FIELD_HEADER_TYPE' | translate}}</th><td><select ng-model=connectionGroup.type ng-options=\"type.value as type.label | translate for type in types | orderBy: name\"></select></td></tr></table></div><div class=attributes><guac-form namespace=\"'CONNECTION_GROUP_ATTRIBUTES'\" content=attributes model=connectionGroup.attributes model-only=!managementPermissions.canChangeAllAttributes></guac-form></div><management-buttons namespace=MANAGE_CONNECTION_GROUP permissions=managementPermissions save=saveConnectionGroup() delete=deleteConnectionGroup() clone=cloneConnectionGroup() return=returnToConnectionList()></management-buttons></div>"
    );
  },
]);
angular.module("app/manage/templates/manageSharingProfile.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/manage/templates/manageSharingProfile.html",
      "<div class=view ng-class=\"{loading: !isLoaded()}\"><div class=header><h2>{{'MANAGE_SHARING_PROFILE.SECTION_HEADER_EDIT_SHARING_PROFILE' | translate}}</h2><guac-user-menu></guac-user-menu></div><div class=section><table class=properties><tr><th>{{'MANAGE_SHARING_PROFILE.FIELD_HEADER_NAME' | translate}}</th><td><input type=text ng-model=sharingProfile.name autocorrect=off autocapitalize=off></td></tr><tr><th>{{'MANAGE_SHARING_PROFILE.FIELD_HEADER_PRIMARY_CONNECTION' | translate}}</th><td>{{primaryConnection.name}}</td></tr></table></div><div class=attributes><guac-form namespace=\"'SHARING_PROFILE_ATTRIBUTES'\" content=attributes model=sharingProfile.attributes model-only=!managementPermissions.canChangeAllAttributes></guac-form></div><h2 class=header>{{'MANAGE_SHARING_PROFILE.SECTION_HEADER_PARAMETERS' | translate}}</h2><div class=\"section connection-parameters\" ng-class=\"{loading: !parameters}\"><guac-form namespace=getNamespace(primaryConnection.protocol) content=protocols[primaryConnection.protocol].sharingProfileForms model=parameters></guac-form></div><management-buttons namespace=MANAGE_SHARING_PROFILE permissions=managementPermissions save=saveSharingProfile() delete=deleteSharingProfile() clone=cloneSharingProfile() return=returnToConnectionList()></management-buttons></div>"
    );
  },
]);
angular.module("app/manage/templates/manageUser.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/manage/templates/manageUser.html",
      "<div class=\"manage-user view\" ng-class=\"{loading: !isLoaded()}\"><div class=\"header tabbed\"><h2>{{'MANAGE_USER.SECTION_HEADER_EDIT_USER' | translate}}</h2><guac-user-menu></guac-user-menu></div><data-data-source-tabs ng-hide=cloneSourceUsername permissions=managementPermissions url=getUserURL(dataSource)></data-data-source-tabs><div class=section ng-hide=managementPermissions[dataSource].canSaveObject><p class=\"notice read-only\">{{'MANAGE_USER.INFO_READ_ONLY' | translate}}</p></div><div ng-show=managementPermissions[dataSource].canSaveObject><div class=section><table class=properties><tr><th>{{'MANAGE_USER.FIELD_HEADER_USERNAME' | translate}}</th><td><input ng-show=canEditUsername() ng-model=user.username type=text><span ng-hide=canEditUsername()>{{user.username}}</span></td></tr><tr><th>{{'MANAGE_USER.FIELD_HEADER_PASSWORD' | translate}}</th><td><input ng-model=user.password type=password></td></tr><tr><th>{{'MANAGE_USER.FIELD_HEADER_PASSWORD_AGAIN' | translate}}</th><td><input ng-model=passwordMatch type=password></td></tr></table></div><div class=attributes ng-show=managementPermissions[dataSource].canChangeAttributes><guac-form namespace=\"'USER_ATTRIBUTES'\" content=attributes model=user.attributes model-only=!managementPermissions[dataSource].canChangeAllAttributes></guac-form></div><system-permission-editor ng-show=managementPermissions[dataSource].canChangePermissions username=selfUsername data-data-source=dataSource permission-flags=permissionFlags permissions-added=permissionsAdded permissions-removed=permissionsRemoved></system-permission-editor><identifier-set-editor header=MANAGE_USER.SECTION_HEADER_USER_GROUPS empty-placeholder=MANAGE_USER.HELP_NO_USER_GROUPS unavailable-placeholder=MANAGE_USER.INFO_NO_USER_GROUPS_AVAILABLE identifiers-available=availableGroups identifiers=parentGroups identifiers-added=parentGroupsAdded identifiers-removed=parentGroupsRemoved></identifier-set-editor><connection-permission-editor ng-show=managementPermissions[dataSource].canChangePermissions data-data-source=dataSource permission-flags=permissionFlags permissions-added=permissionsAdded permissions-removed=permissionsRemoved></connection-permission-editor><management-buttons namespace=MANAGE_USER permissions=managementPermissions[dataSource] save=saveUser() delete=deleteUser() clone=cloneUser() return=returnToUserList()></management-buttons></div></div>"
    );
  },
]);
angular.module("app/manage/templates/manageUserGroup.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/manage/templates/manageUserGroup.html",
      '<div class="manage-user-group view" ng-class="{loading: !isLoaded()}"><div class="header tabbed"><h2>{{\'MANAGE_USER_GROUP.SECTION_HEADER_EDIT_USER_GROUP\' | translate}}</h2><guac-user-menu></guac-user-menu></div><data-data-source-tabs ng-hide=cloneSourceIdentifier permissions=managementPermissions url=getUserGroupURL(dataSource)></data-data-source-tabs><div class=section ng-hide=managementPermissions[dataSource].canSaveObject><p class="notice read-only">{{\'MANAGE_USER_GROUP.INFO_READ_ONLY\' | translate}}</p></div><div ng-show=managementPermissions[dataSource].canSaveObject><div class=section><table class=properties><tr><th>{{\'MANAGE_USER_GROUP.FIELD_HEADER_USER_GROUP_NAME\' | translate}}</th><td><input ng-show=canEditIdentifier() ng-model=userGroup.identifier type=text><span ng-hide=canEditIdentifier()>{{userGroup.identifier}}</span></td></tr></table></div><div class=attributes ng-show=managementPermissions[dataSource].canChangeAttributes><guac-form namespace="\'USER_GROUP_ATTRIBUTES\'" content=attributes model=userGroup.attributes model-only=!managementPermissions[dataSource].canChangeAllAttributes></guac-form></div><system-permission-editor ng-show=managementPermissions[dataSource].canChangePermissions data-data-source=dataSource permission-flags=permissionFlags permissions-added=permissionsAdded permissions-removed=permissionsRemoved></system-permission-editor><identifier-set-editor header=MANAGE_USER_GROUP.SECTION_HEADER_USER_GROUPS empty-placeholder=MANAGE_USER_GROUP.HELP_NO_USER_GROUPS unavailable-placeholder=MANAGE_USER_GROUP.INFO_NO_USER_GROUPS_AVAILABLE identifiers-available=availableGroups identifiers=parentGroups identifiers-added=parentGroupsAdded identifiers-removed=parentGroupsRemoved></identifier-set-editor><identifier-set-editor header=MANAGE_USER_GROUP.SECTION_HEADER_MEMBER_USER_GROUPS empty-placeholder=MANAGE_USER_GROUP.HELP_NO_MEMBER_USER_GROUPS unavailable-placeholder=MANAGE_USER_GROUP.INFO_NO_USER_GROUPS_AVAILABLE identifiers-available=availableGroups identifiers=memberGroups identifiers-added=memberGroupsAdded identifiers-removed=memberGroupsRemoved></identifier-set-editor><identifier-set-editor header=MANAGE_USER_GROUP.SECTION_HEADER_MEMBER_USERS empty-placeholder=MANAGE_USER_GROUP.HELP_NO_MEMBER_USERS unavailable-placeholder=MANAGE_USER_GROUP.INFO_NO_USERS_AVAILABLE identifiers-available=availableUsers identifiers=memberUsers identifiers-added=memberUsersAdded identifiers-removed=memberUsersRemoved></identifier-set-editor><connection-permission-editor ng-show=managementPermissions[dataSource].canChangePermissions data-data-source=dataSource permission-flags=permissionFlags permissions-added=permissionsAdded permissions-removed=permissionsRemoved></connection-permission-editor><management-buttons namespace=MANAGE_USER_GROUP permissions=managementPermissions[dataSource] save=saveUserGroup() delete=deleteUserGroup() clone=cloneUserGroup() return=returnToUserGroupList()></management-buttons></div></div>'
    );
  },
]);
angular.module("app/manage/templates/managementButtons.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/manage/templates/managementButtons.html",
      "<div class=action-buttons><button ng-show=permissions.canSaveObject ng-click=saveObject()>{{namespace + '.ACTION_SAVE' | translate}}</button><button ng-show=permissions.canCloneObject ng-click=cloneObject()>{{namespace + '.ACTION_CLONE' | translate}}</button><button ng-click=cancel()>{{namespace + '.ACTION_CANCEL' | translate}}</button><button ng-show=permissions.canDeleteObject ng-click=deleteObject() class=danger>{{namespace + '.ACTION_DELETE' | translate}}</button></div>"
    );
  },
]);
angular.module("app/manage/templates/sharingProfilePermission.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/manage/templates/sharingProfilePermission.html",
      '<div class=choice><div class="icon type"></div><input type=checkbox ng-model=context.getPermissionFlags().sharingProfilePermissions.READ[item.identifier] ng-change=context.sharingProfilePermissionChanged(item.identifier)><span class=name>{{item.name}}</span></div>'
    );
  },
]);
angular.module("app/manage/templates/systemPermissionEditor.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/manage/templates/systemPermissionEditor.html",
      "<div class=system-permissions><h2 class=header>{{'MANAGE_USER.SECTION_HEADER_PERMISSIONS' | translate}}</h2><div class=section><table class=properties><tr ng-repeat=\"systemPermissionType in systemPermissionTypes\" ng-show=canChangeSystemPermissions()><th>{{systemPermissionType.label | translate}}</th><td><input type=checkbox ng-model=permissionFlags.systemPermissions[systemPermissionType.value] ng-change=systemPermissionChanged(systemPermissionType.value)></td></tr><tr ng-show=username><th>{{'MANAGE_USER.FIELD_HEADER_CHANGE_OWN_PASSWORD' | translate}}</th><td><input type=checkbox ng-model=permissionFlags.userPermissions.UPDATE[username] ng-change=\"userPermissionChanged('UPDATE', username)\"></td></tr></table></div></div>"
    );
  },
]);
angular.module("app/navigation/templates/guacMenu.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/navigation/templates/guacMenu.html",
      '<div class=menu-dropdown ng-class="{open: menuShown}" ng-click=toggleMenu()><div class=menu-title>{{menuTitle}}</div><div class=menu-indicator></div><div class=menu-contents ng-transclude></div></div>'
    );
  },
]);
angular.module("app/navigation/templates/guacPageList.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/navigation/templates/guacPageList.html",
      '<div class=page-list ng-show=levels.length><ul class=page-list-level ng-repeat="level in levels track by $index"><li ng-repeat="page in getPages(level)" class={{page.className}}><a class=home ng-click=navigateToPage(page) ng-class="{current: isCurrentPage(page)}" href=#{{page.url}}>{{page.name | translate}}</a></li></ul></div>'
    );
  },
]);
angular.module("app/navigation/templates/guacSectionTabs.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/navigation/templates/guacSectionTabs.html",
      '<div class=section-tabs ng-show=tabs.length><ul><li ng-repeat="name in tabs"><a ng-click=selectTab(name) ng-class="{ current : isSelected(name) }">{{ getSectionHeader(name) | translate }}</a></li></ul></div>'
    );
  },
]);
angular.module("app/navigation/templates/guacUserMenu.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/navigation/templates/guacUserMenu.html",
      '<div class=user-menu ng-show=!isAnonymous()><guac-menu menu-title=username><div class=profile ng-show=fullName><div class=full-name><a ng-href={{userURL}}>{{ fullName }}</a></div><div class=organizational-role ng-show=role>{{ role }}</div><div class=organization ng-show=organization>{{ organization }}</div></div><ul class=action-list><li ng-repeat="action in localActions"><a ng-class=action.className ng-click=action.callback()>{{action.name | translate}}</a></li></ul><guac-page-list pages=pages></guac-page-list><ul class=action-list><li ng-repeat="action in actions"><a ng-class=action.className ng-click=action.callback()>{{action.name | translate}}</a></li></ul></guac-menu></div>'
    );
  },
]);
angular.module("app/notification/templates/guacNotification.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/notification/templates/guacNotification.html",
      "<form class=notification ng-class=notification.className ng-submit=notification.formSubmitCallback()><div ng-show=notification.title class=title-bar><div class=title>{{notification.title | translate}}</div></div><div class=body><p ng-show=notification.text class=text translate={{notification.text.key}} translate-values={{notification.text.variables}}></p></div></form>"
    );
  },
]);
angular.module("app/osk/templates/guacOsk.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/osk/templates/guacOsk.html",
      "<div class=osk guac-resize=keyboardResized></div>"
    );
  },
]);
angular.module("app/settings/templates/connection.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/settings/templates/connection.html",
      '<a ng-href=#/manage/{{item.dataSource}}/connections/{{item.identifier}} ng-class="{active: item.getActiveConnections()}"><div class="icon type" ng-class=item.protocol></div><span class=name>{{item.name}}</span><span class=activeUserCount ng-show=item.getActiveConnections() translate=SETTINGS_CONNECTIONS.INFO_ACTIVE_USER_COUNT translate-values="{USERS: item.getActiveConnections()}"></span></a>'
    );
  },
]);
angular.module("app/settings/templates/connectionGroup.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/settings/templates/connectionGroup.html",
      '<a ng-href=#/manage/{{item.dataSource}}/connectionGroups/{{item.identifier}}><div class="icon type"></div><span class=name>{{item.name}}</span></a>'
    );
  },
]);
angular.module("app/settings/templates/newConnection.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/settings/templates/newConnection.html",
      "<a ng-href=\"#/manage/{{item.dataSource}}/connections/?parent={{item.wrappedItem.identifier}}\"><span class=name>{{'SETTINGS_CONNECTIONS.ACTION_NEW_CONNECTION' | translate}}</span></a>"
    );
  },
]);
angular.module("app/settings/templates/newConnectionGroup.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/settings/templates/newConnectionGroup.html",
      "<a ng-href=\"#/manage/{{item.dataSource}}/connectionGroups/?parent={{item.wrappedItem.identifier}}\"><span class=name>{{'SETTINGS_CONNECTIONS.ACTION_NEW_CONNECTION_GROUP' | translate}}</span></a>"
    );
  },
]);
angular.module("app/settings/templates/newSharingProfile.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/settings/templates/newSharingProfile.html",
      "<a ng-href=\"#/manage/{{item.dataSource}}/sharingProfiles/?parent={{item.wrappedItem.identifier}}\"><span class=name>{{'SETTINGS_CONNECTIONS.ACTION_NEW_SHARING_PROFILE' | translate}}</span></a>"
    );
  },
]);
angular.module("app/settings/templates/settings.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/settings/templates/settings.html",
      "<div class=view><div class=\"header tabbed\"><h2>{{'SETTINGS.SECTION_HEADER_SETTINGS' | translate}}</h2><guac-user-menu></guac-user-menu></div><div class=page-tabs><guac-page-list pages=settingsPages></guac-page-list></div><guac-settings-users ng-if=\"activeTab === 'users'\"></guac-settings-users><guac-settings-user-groups ng-if=\"activeTab === 'userGroups'\"></guac-settings-user-groups><guac-settings-connections ng-if=\"activeTab === 'connections'\"></guac-settings-connections><guac-settings-connection-history ng-if=\"activeTab === 'history'\"></guac-settings-connection-history><guac-settings-sessions ng-if=\"activeTab === 'sessions'\"></guac-settings-sessions><guac-settings-preferences ng-if=\"activeTab === 'preferences'\"></guac-settings-preferences></div>"
    );
  },
]);
angular
  .module("app/settings/templates/settingsConnectionHistory.html", [])
  .run([
    "$templateCache",
    function ($templateCache) {
      $templateCache.put(
        "app/settings/templates/settingsConnectionHistory.html",
        "<div class=\"settings section connectionHistory\"><p>{{'SETTINGS_CONNECTION_HISTORY.HELP_CONNECTION_HISTORY' | translate}}</p><form class=filter ng-submit=search()><input class=search-string type=text placeholder=\"{{'SETTINGS_CONNECTION_HISTORY.FIELD_PLACEHOLDER_FILTER' | translate}}\" ng-model=searchString> <input class=search-button type=submit value=\"{{'SETTINGS_CONNECTION_HISTORY.ACTION_SEARCH' | translate}}\"><button type=button ng-click=downloadCSV()>{{'SETTINGS_CONNECTION_HISTORY.ACTION_DOWNLOAD' | translate}}</button></form><div class=results><table class=\"sorted history-list\"><thead><tr><th guac-sort-order=order guac-sort-property=\"'username'\">{{'SETTINGS_CONNECTION_HISTORY.TABLE_HEADER_SESSION_USERNAME' | translate}}</th><th guac-sort-order=order guac-sort-property=\"'startDate'\">{{'SETTINGS_CONNECTION_HISTORY.TABLE_HEADER_SESSION_STARTDATE' | translate}}</th><th guac-sort-order=order guac-sort-property=\"'duration'\">{{'SETTINGS_CONNECTION_HISTORY.TABLE_HEADER_SESSION_DURATION' | translate}}</th><th guac-sort-order=order guac-sort-property=\"'connectionName'\">{{'SETTINGS_CONNECTION_HISTORY.TABLE_HEADER_SESSION_CONNECTION_NAME' | translate}}</th><th guac-sort-order=order guac-sort-property=\"'remoteHost'\">{{'SETTINGS_CONNECTION_HISTORY.TABLE_HEADER_SESSION_REMOTEHOST' | translate}}</th></tr></thead><tbody ng-class=\"{loading: !isLoaded()}\"><tr ng-repeat=\"historyEntryWrapper in historyEntryWrapperPage\" class=history><td><guac-user-item username=historyEntryWrapper.username></guac-user-item></td><td>{{historyEntryWrapper.startDate | date : dateFormat}}</td><td translate={{historyEntryWrapper.readableDurationText}} translate-values=\"{VALUE: historyEntryWrapper.readableDuration.value, UNIT: historyEntryWrapper.readableDuration.unit}\"></td><td>{{historyEntryWrapper.connectionName}}</td><td>{{historyEntryWrapper.remoteHost}}</td></tr></tbody></table><p class=placeholder ng-show=isHistoryEmpty()>{{'SETTINGS_CONNECTION_HISTORY.INFO_NO_HISTORY' | translate}}</p><guac-pager page=historyEntryWrapperPage page-size=25 items=\"historyEntryWrappers | orderBy : order.predicate\"></guac-pager></div></div>"
      );
    },
  ]);
angular.module("app/settings/templates/settingsConnections.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/settings/templates/settingsConnections.html",
      "<div class=\"settings section connections\" ng-class=\"{loading: !isLoaded()}\"><p>{{'SETTINGS_CONNECTIONS.HELP_CONNECTIONS' | translate}}</p><div class=toolbar><div class=action-buttons><a class=\"add-connection button\" ng-show=canCreateConnections() href=#/manage/{{dataSource}}/connections/ >{{'SETTINGS_CONNECTIONS.ACTION_NEW_CONNECTION' | translate}}</a><a class=\"add-connection-group button\" ng-show=canCreateConnectionGroups() href=#/manage/{{dataSource}}/connectionGroups/ >{{'SETTINGS_CONNECTIONS.ACTION_NEW_CONNECTION_GROUP' | translate}}</a></div><guac-group-list-filter connection-groups=rootGroups filtered-connection-groups=filteredRootGroups placeholder=\"'SETTINGS_CONNECTIONS.FIELD_PLACEHOLDER_FILTER' | translate\" connection-properties=filteredConnectionProperties connection-group-properties=filteredConnectionGroupProperties></guac-group-list-filter></div><div class=connection-list><guac-group-list page-size=25 connection-groups=filteredRootGroups decorator=rootItemDecorator templates=\"{'connection': 'app/settings/templates/connection.html','sharing-profile': 'app/settings/templates/sharingProfile.html','connection-group' : 'app/settings/templates/connectionGroup.html','new-connection': 'app/settings/templates/newConnection.html','new-sharing-profile': 'app/settings/templates/newSharingProfile.html','new-connection-group' : 'app/settings/templates/newConnectionGroup.html'}\"></div></div>"
    );
  },
]);
angular.module("app/settings/templates/settingsPreferences.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/settings/templates/settingsPreferences.html",
      "<div class=preferences ng-class=\"{loading: !isLoaded()}\"><div class=\"settings section locale\"><p>{{'SETTINGS_PREFERENCES.HELP_LOCALE' | translate}}</p><guac-form content=localeFields model=preferences namespace=\"'SETTINGS_PREFERENCES'\"></guac-form></div><h2 class=header ng-show=canChangePassword>{{'SETTINGS_PREFERENCES.SECTION_HEADER_UPDATE_PASSWORD' | translate}}</h2><div class=\"settings section update-password\" ng-show=canChangePassword><p>{{'SETTINGS_PREFERENCES.HELP_UPDATE_PASSWORD' | translate}}</p><div class=form><table class=fields><tr><th>{{'SETTINGS_PREFERENCES.FIELD_HEADER_PASSWORD_OLD' | translate}}</th><td><input ng-model=oldPassword type=password></td></tr><tr><th>{{'SETTINGS_PREFERENCES.FIELD_HEADER_PASSWORD_NEW' | translate}}</th><td><input ng-model=newPassword type=password></td></tr><tr><th>{{'SETTINGS_PREFERENCES.FIELD_HEADER_PASSWORD_NEW_AGAIN' | translate}}</th><td><input ng-model=newPasswordMatch type=password></td></tr></table></div><div class=action-buttons><button class=change-password ng-click=updatePassword()>{{'SETTINGS_PREFERENCES.ACTION_UPDATE_PASSWORD' | translate}}</button></div></div><h2 class=header>{{'SETTINGS_PREFERENCES.SECTION_HEADER_DEFAULT_INPUT_METHOD' | translate}}</h2><div class=\"settings section input-method\"><p>{{'SETTINGS_PREFERENCES.HELP_DEFAULT_INPUT_METHOD' | translate}}</p><div class=choices><div class=choice><label><input id=ime-none name=input-method ng-model=preferences.inputMethod type=radio value=none> {{'SETTINGS_PREFERENCES.NAME_INPUT_METHOD_NONE' | translate}}</label><p class=caption><label for=ime-none>{{'SETTINGS_PREFERENCES.HELP_INPUT_METHOD_NONE' | translate}}</label></p></div><div class=choice><label><input id=ime-text name=input-method ng-model=preferences.inputMethod type=radio value=text> {{'SETTINGS_PREFERENCES.NAME_INPUT_METHOD_TEXT' | translate}}</label><p class=caption><label for=ime-text>{{'SETTINGS_PREFERENCES.HELP_INPUT_METHOD_TEXT' | translate}}</label></p></div><div class=choice><label><input id=ime-osk name=input-method ng-model=preferences.inputMethod type=radio value=osk> {{'SETTINGS_PREFERENCES.NAME_INPUT_METHOD_OSK' | translate}}</label><p class=caption><label for=ime-osk>{{'SETTINGS_PREFERENCES.HELP_INPUT_METHOD_OSK' | translate}}</label></p></div></div></div><h2 class=header>{{'SETTINGS_PREFERENCES.SECTION_HEADER_DEFAULT_MOUSE_MODE' | translate}}</h2><div class=\"settings section mouse-mode\"><p>{{'SETTINGS_PREFERENCES.HELP_DEFAULT_MOUSE_MODE' | translate}}</p><div class=choices><div class=choice><input name=mouse-mode ng-model=preferences.emulateAbsoluteMouse type=radio ng-value=true checked=checked id=absolute><div class=figure><label for=absolute><img src=images/settings/touchscreen.png alt=\"{{'SETTINGS_PREFERENCES.NAME_MOUSE_MODE_ABSOLUTE' | translate}}\"></label><p class=caption><label for=absolute>{{'SETTINGS_PREFERENCES.HELP_MOUSE_MODE_ABSOLUTE' | translate}}</label></p></div></div><div class=choice><input name=mouse-mode ng-model=preferences.emulateAbsoluteMouse type=radio ng-value=false id=relative><div class=figure><label for=relative><img src=images/settings/touchpad.png alt=\"{{'SETTINGS_PREFERENCES.NAME_MOUSE_MODE_RELATIVE' | translate}}\"></label><p class=caption><label for=relative>{{'SETTINGS_PREFERENCES.HELP_MOUSE_MODE_RELATIVE' | translate}}</label></p></div></div></div></div></div>"
    );
  },
]);
angular.module("app/settings/templates/settingsSessions.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/settings/templates/settingsSessions.html",
      "<div class=\"settings section sessions\" ng-class=\"{loading: !isLoaded()}\"><p>{{'SETTINGS_SESSIONS.HELP_SESSIONS' | translate}}</p><div class=action-buttons><button class=\"delete-sessions danger\" ng-disabled=!canDeleteSessions() ng-click=deleteSessions()>{{'SETTINGS_SESSIONS.ACTION_DELETE' | translate}}</button></div><guac-filter filtered-items=filteredWrappers items=wrappers placeholder=\"'SETTINGS_SESSIONS.FIELD_PLACEHOLDER_FILTER' | translate\" properties=filteredWrapperProperties></guac-filter><table class=\"sorted session-list\"><thead><tr><th class=select-session></th><th guac-sort-order=wrapperOrder guac-sort-property=\"'activeConnection.username'\">{{'SETTINGS_SESSIONS.TABLE_HEADER_SESSION_USERNAME' | translate}}</th><th guac-sort-order=wrapperOrder guac-sort-property=\"'startDate'\">{{'SETTINGS_SESSIONS.TABLE_HEADER_SESSION_STARTDATE' | translate}}</th><th guac-sort-order=wrapperOrder guac-sort-property=\"'activeConnection.remoteHost'\">{{'SETTINGS_SESSIONS.TABLE_HEADER_SESSION_REMOTEHOST' | translate}}</th><th guac-sort-order=wrapperOrder guac-sort-property=\"'name'\">{{'SETTINGS_SESSIONS.TABLE_HEADER_SESSION_CONNECTION_NAME' | translate}}</th></tr></thead><tbody><tr ng-repeat=\"wrapper in wrapperPage\" class=session><td class=select-session><input ng-change=wrapperSelectionChange(wrapper) type=checkbox ng-model=wrapper.checked></td><td><guac-user-item username=wrapper.activeConnection.username></guac-user-item></td><td>{{wrapper.startDate}}</td><td>{{wrapper.activeConnection.remoteHost}}</td><td><a ng-href=\"{{getClientURL(wrapper.dataSource, wrapper.activeConnection)}}\">{{wrapper.name}}</a></td></tr></tbody></table><p class=placeholder ng-hide=wrapperPage.length>{{'SETTINGS_SESSIONS.INFO_NO_SESSIONS' | translate}}</p><guac-pager page=wrapperPage page-size=25 items=\"filteredWrappers | orderBy : wrapperOrder.predicate\"></guac-pager></div>"
    );
  },
]);
angular.module("app/settings/templates/settingsUserGroups.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/settings/templates/settingsUserGroups.html",
      '<div class="settings section user-groups" ng-class="{loading: !isLoaded()}"><p>{{\'SETTINGS_USER_GROUPS.HELP_USER_GROUPS\' | translate}}</p><div class=toolbar><div class=action-buttons><a class="add-user-group button" ng-show=canCreateUserGroups() href=#/manage/{{getDefaultDataSource()}}/userGroups/ >{{\'SETTINGS_USER_GROUPS.ACTION_NEW_USER_GROUP\' | translate}}</a></div><guac-filter filtered-items=filteredManageableUserGroups items=manageableUserGroups placeholder="\'SETTINGS_USER_GROUPS.FIELD_PLACEHOLDER_FILTER\' | translate" properties=filteredUserGroupProperties></guac-filter></div><table class="sorted user-group-list"><thead><tr><th guac-sort-order=order guac-sort-property="\'userGroup.identifier\'" class=user-group-name>{{\'SETTINGS_USER_GROUPS.TABLE_HEADER_USER_GROUP_NAME\' | translate}}</th></tr></thead><tbody ng-class="{loading: !isLoaded()}"><tr ng-repeat="manageableUserGroup in manageableUserGroupPage" class=user-group><td class=user-group-name><a ng-href=#/manage/{{manageableUserGroup.dataSource}}/userGroups/{{manageableUserGroup.userGroup.identifier}}><div class="icon user-group"></div><span class=name>{{manageableUserGroup.userGroup.identifier}}</span></a></td></tr></tbody></table><guac-pager page=manageableUserGroupPage page-size=25 items="filteredManageableUserGroups | orderBy : order.predicate"></guac-pager></div>'
    );
  },
]);
angular.module("app/settings/templates/settingsUsers.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/settings/templates/settingsUsers.html",
      "<div class=\"settings section users\" ng-class=\"{loading: !isLoaded()}\"><p>{{'SETTINGS_USERS.HELP_USERS' | translate}}</p><div class=toolbar><div class=action-buttons><a class=\"add-user button\" ng-show=canCreateUsers() href=#/manage/{{getDefaultDataSource()}}/users/ >{{'SETTINGS_USERS.ACTION_NEW_USER' | translate}}</a></div><guac-filter filtered-items=filteredManageableUsers items=manageableUsers placeholder=\"'SETTINGS_USERS.FIELD_PLACEHOLDER_FILTER' | translate\" properties=filteredUserProperties></guac-filter></div><table class=\"sorted user-list\"><thead><tr><th guac-sort-order=order guac-sort-property=\"'user.username'\" class=username>{{'SETTINGS_USERS.TABLE_HEADER_USERNAME' | translate}}</th><th guac-sort-order=order guac-sort-property=\"'user.attributes[\\'guac-organization\\']'\" class=organization>{{'SETTINGS_USERS.TABLE_HEADER_ORGANIZATION' | translate}}</th><th guac-sort-order=order guac-sort-property=\"'user.attributes[\\'guac-full-name\\']'\" class=full-name>{{'SETTINGS_USERS.TABLE_HEADER_FULL_NAME' | translate}}</th><th guac-sort-order=order guac-sort-property=\"'user.lastActive'\" class=last-active>{{'SETTINGS_USERS.TABLE_HEADER_LAST_ACTIVE' | translate}}</th></tr></thead><tbody ng-class=\"{loading: !isLoaded()}\"><tr ng-repeat=\"manageableUser in manageableUserPage\" class=user><td class=username><a ng-href=#/manage/{{manageableUser.dataSource}}/users/{{manageableUser.user.username}}><div class=\"icon user\"></div><span class=name>{{manageableUser.user.username}}</span></a></td><td class=organization>{{manageableUser.user.attributes['guac-organization']}}</td><td class=full-name>{{manageableUser.user.attributes['guac-full-name']}}</td><td class=last-active>{{manageableUser.user.lastActive | date : dateFormat}}</td></tr></tbody></table><guac-pager page=manageableUserPage page-size=25 items=\"filteredManageableUsers | orderBy : order.predicate\"></guac-pager></div>"
    );
  },
]);
angular.module("app/settings/templates/sharingProfile.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/settings/templates/sharingProfile.html",
      '<a ng-href=#/manage/{{item.dataSource}}/sharingProfiles/{{item.identifier}}><div class="icon type"></div><span class=name>{{item.name}}</span></a>'
    );
  },
]);
angular.module("app/textInput/templates/guacKey.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/textInput/templates/guacKey.html",
      '<button class=key ng-mousedown=updateKey($event) ng-class="{pressed: pressed, sticky: sticky}">{{text | translate}}</button>'
    );
  },
]);
angular.module("app/textInput/templates/guacTextInput.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "app/textInput/templates/guacTextInput.html",
      '<div class=text-input><div class=text-input-field><div class=sent-history><div class=sent-text ng-repeat="text in sentText track by $index">{{text}}</div></div><textarea rows=1 class=target autocorrect=off autocapitalize=off autofocus></textarea></div><div class=text-input-buttons><guac-key keysym=65507 sticky=true text="\'CLIENT.NAME_KEY_CTRL\'" pressed=ctrlPressed></guac-key><guac-key keysym=65513 sticky=true text="\'CLIENT.NAME_KEY_ALT\'" pressed=altPressed></guac-key><guac-key keysym=65307 text="\'CLIENT.NAME_KEY_ESC\'"></guac-key><guac-key keysym=65289 text="\'CLIENT.NAME_KEY_TAB\'"></guac-key></div></div>'
    );
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The module for authentication and management of tokens.
 */
angular.module("auth", ["rest", "storage"]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for authenticating a user against the REST API.
 *
 * This service broadcasts two events on $rootScope depending on the result of
 * authentication operations: 'guacLogin' if authentication was successful and
 * a new token was created, and 'guacLogout' if an existing token is being
 * destroyed or replaced. Both events will be passed the related token as their
 * sole parameter.
 *
 * If a login attempt results in an existing token being replaced, 'guacLogout'
 * will be broadcast first for the token being replaced, followed by
 * 'guacLogin' for the new token.
 *
 * Failed logins may also result in guacInsufficientCredentials or
 * guacInvalidCredentials events, if the provided credentials were rejected for
 * being insufficient or invalid respectively. Both events will be provided
 * the set of parameters originally given to authenticate() and the error that
 * rejected the credentials. The Error object provided will contain set of
 * expected credentials returned by the REST endpoint. This set of credentials
 * will be in the form of a Field array.
 */
angular.module("auth").factory("authenticationService", [
  "$injector",
  function authenticationService($injector) {
    // Required types
    var AuthenticationResult = $injector.get("AuthenticationResult");
    var Error = $injector.get("Error");

    // Required services
    var $rootScope = $injector.get("$rootScope");
    var localStorageService = $injector.get("localStorageService");
    var requestService = $injector.get("requestService");

    var service = {};

    /**
     * The most recent authentication result, or null if no authentication
     * result is cached.
     *
     * @type AuthenticationResult
     */
    var cachedResult = null;

    /**
     * The unique identifier of the local storage key which stores the result
     * of the last authentication attempt.
     *
     * @type String
     */
    var AUTH_STORAGE_KEY = "GUAC_AUTH";

    /**
     * Retrieves the last successful authentication result. If the user has not
     * yet authenticated, the user has logged out, or the last authentication
     * attempt failed, null is returned.
     *
     * @returns {AuthenticationResult}
     *     The last successful authentication result, or null if the user is not
     *     currently authenticated.
     */
    var getAuthenticationResult = function getAuthenticationResult() {
      return null;
      // return new AuthenticationResult({"authToken":"GUACTK","username":"root","dataSource":"default","availableDataSources":["default"]});
      // Use cached result, if any
      if (cachedResult) return cachedResult;

      // Return explicit null if no auth data is currently stored
      var data = localStorageService.getItem(AUTH_STORAGE_KEY);
      if (!data) return null;

      // Update cache and return retrieved auth result
      return (cachedResult = new AuthenticationResult(data));
    };

    /**
     * Stores the given authentication result for future retrieval. The given
     * result MUST be the result of the most recent authentication attempt.
     *
     * @param {AuthenticationResult} data
     *     The last successful authentication result, or null if the last
     *     authentication attempt failed.
     */
    var setAuthenticationResult = function setAuthenticationResult(data) {
      return;
      // Clear the currently-stored result if the last attempt failed
      if (!data) {
        cachedResult = null;
        localStorageService.removeItem(AUTH_STORAGE_KEY);
      }

      // Otherwise store the authentication attempt directly
      else {
        // Always store in cache
        cachedResult = data;

        // Persist result past tab/window closure ONLY if not anonymous
        if (data.username !== AuthenticationResult.ANONYMOUS_USERNAME)
          localStorageService.setItem(AUTH_STORAGE_KEY, data);
      }
    };

    /**
     * Clears the stored authentication result, if any. If no authentication
     * result is currently stored, this function has no effect.
     */
    var clearAuthenticationResult = function clearAuthenticationResult() {
      setAuthenticationResult(null);
    };

    /**
     * Makes a request to authenticate a user using the token REST API endpoint
     * and given arbitrary parameters, returning a promise that succeeds only
     * if the authentication operation was successful. The resulting
     * authentication data can be retrieved later via getCurrentToken() or
     * getCurrentUsername().
     *
     * The provided parameters can be virtually any object, as each property
     * will be sent as an HTTP parameter in the authentication request.
     * Standard parameters include "username" for the user's username,
     * "password" for the user's associated password, and "token" for the
     * auth token to check/update.
     *
     * If a token is provided, it will be reused if possible.
     *
     * @param {Object} parameters
     *     Arbitrary parameters to authenticate with.
     *
     * @returns {Promise}
     *     A promise which succeeds only if the login operation was successful.
     */
    service.authenticate = function authenticate(parameters) {
      // Attempt authentication
      /*
        return requestService({
            method: 'POST',
            url: 'api/tokens',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            data: $.param(parameters)
        })
        */

      // If authentication succeeds, handle received auth data
      // PATCHED BY IAAS
      return Promise.resolve({
        authToken: "GUACTK",
        username: "user",
        dataSource: "default",
        availableDataSources: ["default"],
      })
        .then(function authenticationSuccessful(data) {
          var currentToken = service.getCurrentToken();

          // If a new token was received, ensure the old token is invalidated,
          // if any, and notify listeners of the new token
          if (data.authToken !== currentToken) {
            // If an old token existed, request that the token be revoked
            if (currentToken) {
              service.logout().catch(angular.noop);
            }

            // Notify of login and new token
            setAuthenticationResult(new AuthenticationResult(data));
            $rootScope.$broadcast("guacLogin", data.authToken);
          }

          // Update cached authentication result, even if the token remains
          // the same
          else setAuthenticationResult(new AuthenticationResult(data));

          // Authentication was successful
          return data;
        })

        [
          // If authentication fails, propogate failure to returned promise
          "catch"
        ](
          requestService.createErrorCallback(function authenticationFailed(
            error
          ) {
            // Request credentials if provided credentials were invalid
            if (error.type === Error.Type.INVALID_CREDENTIALS)
              $rootScope.$broadcast(
                "guacInvalidCredentials",
                parameters,
                error
              );
            // Request more credentials if provided credentials were not enough
            else if (error.type === Error.Type.INSUFFICIENT_CREDENTIALS)
              $rootScope.$broadcast(
                "guacInsufficientCredentials",
                parameters,
                error
              );
            // Abort rendering of page if an internal error occurs
            else if (error.type === Error.Type.INTERNAL_ERROR)
              $rootScope.$broadcast("guacFatalPageError", error);

            // Authentication failed
            throw error;
          })
        );
    };

    /**
     * Makes a request to update the current auth token, if any, using the
     * token REST API endpoint. If the optional parameters object is provided,
     * its properties will be included as parameters in the update request.
     * This function returns a promise that succeeds only if the authentication
     * operation was successful. The resulting authentication data can be
     * retrieved later via getCurrentToken() or getCurrentUsername().
     *
     * If there is no current auth token, this function behaves identically to
     * authenticate(), and makes a general authentication request.
     *
     * @param {Object} [parameters]
     *     Arbitrary parameters to authenticate with, if any.
     *
     * @returns {Promise}
     *     A promise which succeeds only if the login operation was successful.
     */
    service.updateCurrentToken = function updateCurrentToken(parameters) {
      // HTTP parameters for the authentication request
      var httpParameters = {};

      // Add token parameter if current token is known
      var token = service.getCurrentToken();
      if (token) httpParameters.token = service.getCurrentToken();

      // Add any additional parameters
      if (parameters) angular.extend(httpParameters, parameters);

      // Make the request
      return service.authenticate(httpParameters);
    };

    /**
     * Makes a request to authenticate a user using the token REST API endpoint
     * with a username and password, ignoring any currently-stored token,
     * returning a promise that succeeds only if the login operation was
     * successful. The resulting authentication data can be retrieved later
     * via getCurrentToken() or getCurrentUsername().
     *
     * @param {String} username
     *     The username to log in with.
     *
     * @param {String} password
     *     The password to log in with.
     *
     * @returns {Promise}
     *     A promise which succeeds only if the login operation was successful.
     */
    service.login = function login(username, password) {
      return service.authenticate({
        username: username,
        password: password,
      });
    };

    /**
     * Makes a request to logout a user using the login REST API endpoint,
     * returning a promise succeeds only if the logout operation was
     * successful.
     *
     * @returns {Promise}
     *     A promise which succeeds only if the logout operation was
     *     successful.
     */
    service.logout = function logout() {
      // Clear authentication data
      var token = service.getCurrentToken();
      clearAuthenticationResult();

      // Notify listeners that a token is being destroyed
      $rootScope.$broadcast("guacLogout", token);

      // Delete old token
      return requestService({
        method: "DELETE",
        url: "api/tokens/" + token,
      });
    };

    /**
     * Returns whether the current user has authenticated anonymously. An
     * anonymous user is denoted by the identifier reserved by the Guacamole
     * extension API for anonymous users (the empty string).
     *
     * @returns {Boolean}
     *     true if the current user has authenticated anonymously, false
     *     otherwise.
     */
    service.isAnonymous = function isAnonymous() {
      return service.getCurrentUsername() === "";
    };

    /**
     * Returns the username of the current user. If the current user is not
     * logged in, this value may not be valid.
     *
     * @returns {String}
     *     The username of the current user, or null if no authentication data
     *     is present.
     */
    service.getCurrentUsername = function getCurrentUsername() {
      // Return username, if available
      var authData = getAuthenticationResult();
      if (authData) return authData.username;

      // No auth data present
      return null;
    };

    /**
     * Returns the auth token associated with the current user. If the current
     * user is not logged in, this token may not be valid.
     *
     * @returns {String}
     *     The auth token associated with the current user, or null if no
     *     authentication data is present.
     */
    service.getCurrentToken = function getCurrentToken() {
      // Return auth token, if available
      var authData = getAuthenticationResult();
      if (authData) return authData.authToken;

      // No auth data present
      return null;
    };

    /**
     * Returns the identifier of the data source that authenticated the current
     * user. If the current user is not logged in, this value may not be valid.
     *
     * @returns {String}
     *     The identifier of the data source that authenticated the current
     *     user, or null if no authentication data is present.
     */
    service.getDataSource = function getDataSource() {
      // Return data source, if available
      var authData = getAuthenticationResult();
      if (authData) return authData.dataSource;

      // No auth data present
      return null;
    };

    /**
     * Returns the identifiers of all data sources available to the current
     * user. If the current user is not logged in, this value may not be valid.
     *
     * @returns {String[]}
     *     The identifiers of all data sources availble to the current user,
     *     or an empty array if no authentication data is present.
     */
    service.getAvailableDataSources = function getAvailableDataSources() {
      // Return data sources, if available
      var authData = getAuthenticationResult();
      if (authData) return authData.availableDataSources;

      // No auth data present
      return [];
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the AuthenticationResult class.
 */
angular.module("auth").factory("AuthenticationResult", [
  function defineAuthenticationResult() {
    /**
     * The object returned by REST API calls when representing the successful
     * result of an authentication attempt.
     *
     * @constructor
     * @param {AuthenticationResult|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     AuthenticationResult.
     */
    var AuthenticationResult = function AuthenticationResult(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The unique token generated for the user that authenticated.
       *
       * @type String
       */
      this.authToken = template.authToken;

      /**
       * The name which uniquely identifies the user that authenticated.
       *
       * @type String
       */
      this.username = template.username;

      /**
       * The unique identifier of the data source which authenticated the
       * user.
       *
       * @type String
       */
      this.dataSource = template.dataSource;

      /**
       * The identifiers of all data sources available to the user that
       * authenticated.
       *
       * @type String[]
       */
      this.availableDataSources = template.availableDataSources;
    };

    /**
     * The username reserved by the Guacamole extension API for users which have
     * authenticated anonymously.
     *
     * @type String
     */
    AuthenticationResult.ANONYMOUS_USERNAME = "";

    return AuthenticationResult;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The module for code used to connect to a connection or balancing group.
 */
angular.module("client", [
  "auth",
  "clipboard",
  "element",
  "history",
  "navigation",
  "notification",
  "osk",
  "rest",
  "textInput",
  "touch",
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The controller for the page used to connect to a connection or balancing group.
 */
angular.module("client").controller("clientController", [
  "$scope",
  "$injector",
  function clientController($scope, $injector) {
    var $routeParams = window.IAAS_PARAMETERS;
    // Required types
    var ConnectionGroup = $injector.get("ConnectionGroup");
    var ManagedClient = $injector.get("ManagedClient");
    var ManagedClientState = $injector.get("ManagedClientState");
    var ManagedFilesystem = $injector.get("ManagedFilesystem");
    var Protocol = $injector.get("Protocol");
    var ScrollState = $injector.get("ScrollState");

    // Required services
    var $location = $injector.get("$location");
    var authenticationService = $injector.get("authenticationService");
    var connectionGroupService = $injector.get("connectionGroupService");
    var clipboardService = $injector.get("clipboardService");
    var dataSourceService = $injector.get("dataSourceService");
    var guacClientManager = $injector.get("guacClientManager");
    var guacNotification = $injector.get("guacNotification");
    var iconService = $injector.get("iconService");
    var preferenceService = $injector.get("preferenceService");
    var requestService = $injector.get("requestService");
    var tunnelService = $injector.get("tunnelService");
    var userPageService = $injector.get("userPageService");

    /**
     * The minimum number of pixels a drag gesture must move to result in the
     * menu being shown or hidden.
     *
     * @type Number
     */
    var MENU_DRAG_DELTA = 64;

    /**
     * The maximum X location of the start of a drag gesture for that gesture
     * to potentially show the menu.
     *
     * @type Number
     */
    var MENU_DRAG_MARGIN = 64;

    /**
     * When showing or hiding the menu via a drag gesture, the maximum number
     * of pixels the touch can move vertically and still affect the menu.
     *
     * @type Number
     */
    var MENU_DRAG_VERTICAL_TOLERANCE = 10;

    /**
     * In order to open the guacamole menu, we need to hit ctrl-alt-shift. There are
     * several possible keysysms for each key.
     */
    var SHIFT_KEYS = { 0xffe1: true, 0xffe2: true },
      ALT_KEYS = {
        0xffe9: true,
        0xffea: true,
        0xfe03: true,
        0xffe7: true,
        0xffe8: true,
      },
      CTRL_KEYS = { 0xffe3: true, 0xffe4: true },
      MENU_KEYS = angular.extend({}, SHIFT_KEYS, ALT_KEYS, CTRL_KEYS);

    /**
     * Keysym for detecting any END key presses, for the purpose of passing through
     * the Ctrl-Alt-Del sequence to a remote system.
     */
    var END_KEYS = { 0xff57: true, 0xffb1: true };

    /**
     * Keysym for sending the DELETE key when the Ctrl-Alt-End hotkey
     * combo is pressed.
     *
     * @type Number
     */
    var DEL_KEY = 0xffff;

    /**
     * All client error codes handled and passed off for translation. Any error
     * code not present in this list will be represented by the "DEFAULT"
     * translation.
     */
    var CLIENT_ERRORS = {
      0x0201: true,
      0x0202: true,
      0x0203: true,
      0x0207: true,
      0x0208: true,
      0x0209: true,
      0x020a: true,
      0x020b: true,
      0x0301: true,
      0x0303: true,
      0x0308: true,
      0x031d: true,
    };

    /**
     * All error codes for which automatic reconnection is appropriate when a
     * client error occurs.
     */
    var CLIENT_AUTO_RECONNECT = {
      0x0200: true,
      0x0202: true,
      0x0203: true,
      0x0207: true,
      0x0208: true,
      0x0301: true,
      0x0308: true,
    };

    /**
     * All tunnel error codes handled and passed off for translation. Any error
     * code not present in this list will be represented by the "DEFAULT"
     * translation.
     */
    var TUNNEL_ERRORS = {
      0x0201: true,
      0x0202: true,
      0x0203: true,
      0x0204: true,
      0x0205: true,
      0x0207: true,
      0x0208: true,
      0x0301: true,
      0x0303: true,
      0x0308: true,
      0x031d: true,
    };

    /**
     * All error codes for which automatic reconnection is appropriate when a
     * tunnel error occurs.
     */
    var TUNNEL_AUTO_RECONNECT = {
      0x0200: true,
      0x0202: true,
      0x0203: true,
      0x0207: true,
      0x0208: true,
      0x0308: true,
    };

    /**
     * Action which logs out from Guacamole entirely.
     */
    var LOGOUT_ACTION = {
      name: "CLIENT.ACTION_LOGOUT",
      className: "logout button",
      callback: function logoutCallback() {
        authenticationService
          .logout()
          ["catch"](requestService.IGNORE)
          ["finally"](function logoutComplete() {
            // $location.url('/');
          });
      },
    };

    /**
     * Action which returns the user to the home screen. If the home page has
     * not yet been determined, this will be null.
     */
    var NAVIGATE_HOME_ACTION = null;

    // Assign home page action once user's home page has been determined
    userPageService.getHomePage().then(function homePageRetrieved(homePage) {
      // Define home action only if different from current location
      if ($location.path() !== homePage.url) {
        NAVIGATE_HOME_ACTION = {
          name: "CLIENT.ACTION_NAVIGATE_HOME",
          className: "home button",
          callback: function navigateHomeCallback() {
            // $location.url(homePage.url);
          },
        };
      }
    }, requestService.WARN);

    /**
     * Action which replaces the current client with a newly-connected client.
     */
    var RECONNECT_ACTION = {
      name: "CLIENT.ACTION_RECONNECT",
      className: "reconnect button",
      callback: function reconnectCallback() {
        $scope.client = guacClientManager.replaceManagedClient(
          $routeParams.id,
          $routeParams.params
        );
        guacNotification.showStatus(false);
      },
    };

    /**
     * The reconnect countdown to display if an error or status warrants an
     * automatic, timed reconnect.
     */
    var RECONNECT_COUNTDOWN = {
      text: "CLIENT.TEXT_RECONNECT_COUNTDOWN",
      callback: RECONNECT_ACTION.callback,
      remaining: 15,
    };

    /**
     * Menu-specific properties.
     */
    $scope.menu = {
      /**
       * Whether the menu is currently shown.
       *
       * @type Boolean
       */
      shown: false,

      /**
       * Whether the Guacamole display should be scaled to fit the browser
       * window.
       *
       * @type Boolean
       */
      autoFit: true,

      /**
       * The currently selected input method. This may be any of the values
       * defined within preferenceService.inputMethods.
       *
       * @type String
       */
      inputMethod: preferenceService.preferences.inputMethod,

      /**
       * The current scroll state of the menu.
       *
       * @type ScrollState
       */
      scrollState: new ScrollState(),

      /**
       * The current desired values of all editable connection parameters as
       * a set of name/value pairs, including any changes made by the user.
       *
       * @type {Object.<String, String>}
       */
      connectionParameters: {},
    };

    // Convenience method for closing the menu
    $scope.closeMenu = function closeMenu() {
      $scope.menu.shown = false;
    };

    /**
     * Applies any changes to connection parameters made by the user within the
     * Guacamole menu.
     */
    $scope.applyParameterChanges = function applyParameterChanges() {
      angular.forEach(
        $scope.menu.connectionParameters,
        function sendArgv(value, name) {
          ManagedClient.setArgument($scope.client, name, value);
        }
      );
    };

    /**
     * The client which should be attached to the client UI.
     *
     * @type ManagedClient
     */
    $scope.client = guacClientManager.getManagedClient($routeParams.id, {
      iaasParams: {
        ConsoleURL: $routeParams.ConsoleURL,
        onSocketOpen(socket) {
          socket.send(
            JSON.stringify({
              AuthType: "password",
              InstanceId: $routeParams.InstanceId,
              Ip: $routeParams.Ip,
              NetworkType: "vpc",
              Password: $routeParams.Password,
              Protocol: "rdp",
              UserName: $routeParams.UserName,
              Port: $routeParams.Port || 3389,
              ...$routeParams.wsParams,
            })
          );
        },
      },
    });

    /**
     * All active clients which are not the current client ($scope.client).
     * Each key is the ID of the connection used by that client.
     *
     * @type Object.<String, ManagedClient>
     */
    $scope.otherClients = (function getOtherClients(clients) {
      var otherClients = angular.extend({}, clients);
      delete otherClients[$scope.client.id];
      return otherClients;
    })(guacClientManager.getManagedClients());

    /**
     * The root connection groups of the connection hierarchy that should be
     * presented to the user for selecting a different connection, as a map of
     * data source identifier to the root connection group of that data
     * source. This will be null if the connection group hierarchy has not yet
     * been loaded or if the hierarchy is inapplicable due to only one
     * connection or balancing group being available.
     *
     * @type Object.<String, ConnectionGroup>
     */
    $scope.rootConnectionGroups = null;

    /**
     * Array of all connection properties that are filterable.
     *
     * @type String[]
     */
    $scope.filteredConnectionProperties = ["name"];

    /**
     * Array of all connection group properties that are filterable.
     *
     * @type String[]
     */
    $scope.filteredConnectionGroupProperties = ["name"];

    // Retrieve root groups and all descendants
    dataSourceService
      .apply(
        connectionGroupService.getConnectionGroupTree,
        authenticationService.getAvailableDataSources(),
        ConnectionGroup.ROOT_IDENTIFIER
      )
      .then(function rootGroupsRetrieved(rootConnectionGroups) {
        // Store retrieved groups only if there are multiple connections or
        // balancing groups available
        var clientPages = userPageService.getClientPages(rootConnectionGroups);
        if (clientPages.length > 1)
          $scope.rootConnectionGroups = rootConnectionGroups;
      }, requestService.WARN);

    /**
     * Map of all available sharing profiles for the current connection by
     * their identifiers. If this information is not yet available, or no such
     * sharing profiles exist, this will be an empty object.
     *
     * @type Object.<String, SharingProfile>
     */
    $scope.sharingProfiles = {};

    /**
     * Map of all currently pressed keys by keysym. If a particular key is
     * currently pressed, the value stored under that key's keysym within this
     * map will be true. All keys not currently pressed will not have entries
     * within this map.
     *
     * @type Object.<Number, Boolean>
     */
    var keysCurrentlyPressed = {};

    /**
     * Map of all substituted key presses.  If one key is pressed in place of another
     * the value of the substituted key is stored in an object with the keysym of
     * the original key.
     *
     * @type Object.<Number, Number>
     */
    var substituteKeysPressed = {};

    /**
     * Map of all currently pressed keys (by keysym) to the clipboard contents
     * received from the remote desktop while those keys were pressed. All keys
     * not currently pressed will not have entries within this map.
     *
     * @type Object.<Number, ClipboardData>
     */
    var clipboardDataFromKey = {};

    /*
     * Check to see if all currently pressed keys are in the set of menu keys.
     */
    function checkMenuModeActive() {
      for (var keysym in keysCurrentlyPressed) {
        if (!MENU_KEYS[keysym]) {
          return false;
        }
      }

      return true;
    }

    // Hide menu when the user swipes from the right
    $scope.menuDrag = function menuDrag(
      inProgress,
      startX,
      startY,
      currentX,
      currentY,
      deltaX,
      deltaY
    ) {
      // Hide menu if swipe gesture is detected
      if (
        Math.abs(currentY - startY) < MENU_DRAG_VERTICAL_TOLERANCE &&
        startX - currentX >= MENU_DRAG_DELTA
      )
        $scope.menu.shown = false;
      // Scroll menu by default
      else {
        $scope.menu.scrollState.left -= deltaX;
        $scope.menu.scrollState.top -= deltaY;
      }

      return false;
    };

    // Update menu or client based on dragging gestures
    $scope.clientDrag = function clientDrag(
      inProgress,
      startX,
      startY,
      currentX,
      currentY,
      deltaX,
      deltaY
    ) {
      // Show menu if the user swipes from the left
      if (startX <= MENU_DRAG_MARGIN) {
        if (
          Math.abs(currentY - startY) < MENU_DRAG_VERTICAL_TOLERANCE &&
          currentX - startX >= MENU_DRAG_DELTA
        )
          $scope.menu.shown = true;
      }

      // Scroll display if absolute mouse is in use
      else if ($scope.client.clientProperties.emulateAbsoluteMouse) {
        $scope.client.clientProperties.scrollLeft -= deltaX;
        $scope.client.clientProperties.scrollTop -= deltaY;
      }

      return false;
    };

    /**
     * If a pinch gesture is in progress, the scale of the client display when
     * the pinch gesture began.
     *
     * @type Number
     */
    var initialScale = null;

    /**
     * If a pinch gesture is in progress, the X coordinate of the point on the
     * client display that was centered within the pinch at the time the
     * gesture began.
     *
     * @type Number
     */
    var initialCenterX = 0;

    /**
     * If a pinch gesture is in progress, the Y coordinate of the point on the
     * client display that was centered within the pinch at the time the
     * gesture began.
     *
     * @type Number
     */
    var initialCenterY = 0;

    // Zoom and pan client via pinch gestures
    $scope.clientPinch = function clientPinch(
      inProgress,
      startLength,
      currentLength,
      centerX,
      centerY
    ) {
      // Do not handle pinch gestures while relative mouse is in use
      if (!$scope.client.clientProperties.emulateAbsoluteMouse) return false;

      // Stop gesture if not in progress
      if (!inProgress) {
        initialScale = null;
        return false;
      }

      // Set initial scale if gesture has just started
      if (!initialScale) {
        initialScale = $scope.client.clientProperties.scale;
        initialCenterX =
          (centerX + $scope.client.clientProperties.scrollLeft) / initialScale;
        initialCenterY =
          (centerY + $scope.client.clientProperties.scrollTop) / initialScale;
      }

      // Determine new scale absolutely
      var currentScale = (initialScale * currentLength) / startLength;

      // Fix scale within limits - scroll will be miscalculated otherwise
      currentScale = Math.max(
        currentScale,
        $scope.client.clientProperties.minScale
      );
      currentScale = Math.min(
        currentScale,
        $scope.client.clientProperties.maxScale
      );

      // Update scale based on pinch distance
      $scope.menu.autoFit = false;
      $scope.client.clientProperties.autoFit = false;
      $scope.client.clientProperties.scale = currentScale;

      // Scroll display to keep original pinch location centered within current pinch
      $scope.client.clientProperties.scrollLeft =
        initialCenterX * currentScale - centerX;
      $scope.client.clientProperties.scrollTop =
        initialCenterY * currentScale - centerY;

      return false;
    };

    // Show/hide UI elements depending on input method
    $scope.$watch("menu.inputMethod", function setInputMethod(inputMethod) {
      // Show input methods only if selected
      $scope.showOSK = inputMethod === "osk";
      $scope.showTextInput = inputMethod === "text";
    });

    // Update client state/behavior as visibility of the Guacamole menu changes
    $scope.$watch(
      "menu.shown",
      function menuVisibilityChanged(menuShown, menuShownPreviousState) {
        // Send clipboard and argument value data once menu is hidden
        if (!menuShown && menuShownPreviousState) {
          $scope.$broadcast("guacClipboard", $scope.client.clipboardData);
          $scope.applyParameterChanges();
        }

        // Obtain snapshot of current editable connection parameters when menu
        // is opened
        else if (menuShown)
          $scope.menu.connectionParameters = ManagedClient.getArgumentModel(
            $scope.client
          );

        // Disable client keyboard if the menu is shown
        $scope.client.clientProperties.keyboardEnabled = !menuShown;
      }
    );

    // Update last used timestamp when the active client changes
    $scope.$watch("client", function clientChanged(client) {
      if (client) client.lastUsed = new Date().getTime();
    });

    // Update page icon when thumbnail changes
    $scope.$watch("client.thumbnail.canvas", function thumbnailChanged(canvas) {
      iconService.setIcons(canvas);
    });

    // Watch clipboard for new data, associating it with any pressed keys
    $scope.$watch("client.clipboardData", function clipboardChanged(data) {
      // Sync local clipboard as long as the menu is not open
      if (!$scope.menu.shown)
        clipboardService.setLocalClipboard(data)["catch"](angular.noop);

      // Associate new clipboard data with any currently-pressed key
      for (var keysym in keysCurrentlyPressed)
        clipboardDataFromKey[keysym] = data;
    });

    // Pull sharing profiles once the tunnel UUID is known
    $scope.$watch("client.tunnel.uuid", function retrieveSharingProfiles(uuid) {
      // Only pull sharing profiles if tunnel UUID is actually available
      if (!uuid) return;

      // Pull sharing profiles for the current connection
      tunnelService
        .getSharingProfiles(uuid)
        .then(function sharingProfilesRetrieved(sharingProfiles) {
          $scope.sharingProfiles = sharingProfiles;
        }, requestService.WARN);
    });

    /**
     * Produces a sharing link for the current connection using the given
     * sharing profile. The resulting sharing link, and any required login
     * information, will be displayed to the user within the Guacamole menu.
     *
     * @param {SharingProfile} sharingProfile
     *     The sharing profile to use to generate the sharing link.
     */
    $scope.share = function share(sharingProfile) {
      ManagedClient.createShareLink($scope.client, sharingProfile);
    };

    /**
     * Returns whether the current connection has any associated share links.
     *
     * @returns {Boolean}
     *     true if the current connection has at least one associated share
     *     link, false otherwise.
     */
    $scope.isShared = function isShared() {
      return ManagedClient.isShared($scope.client);
    };

    /**
     * Returns the total number of share links associated with the current
     * connection.
     *
     * @returns {Number}
     *     The total number of share links associated with the current
     *     connection.
     */
    $scope.getShareLinkCount = function getShareLinkCount() {
      // Count total number of links within the ManagedClient's share link map
      var linkCount = 0;
      for (var dummy in $scope.client.shareLinks) linkCount++;

      return linkCount;
    };

    // Track pressed keys, opening the Guacamole menu after Ctrl+Alt+Shift, or
    // send Ctrl-Alt-Delete when Ctrl-Alt-End is pressed.
    $scope.$on(
      "guacKeydown",
      function keydownListener(event, keysym, keyboard) {
        // Record key as pressed
        keysCurrentlyPressed[keysym] = true;

        var currentKeysPressedKeys = Object.keys(keysCurrentlyPressed);

        // If only menu keys are pressed, and we have one keysym from each group,
        // and one of the keys is being released, show the menu.
        if (checkMenuModeActive()) {
          // Check that there is a key pressed for each of the required key classes
          if (
            !_.isEmpty(_.pick(SHIFT_KEYS, currentKeysPressedKeys)) &&
            !_.isEmpty(_.pick(ALT_KEYS, currentKeysPressedKeys)) &&
            !_.isEmpty(_.pick(CTRL_KEYS, currentKeysPressedKeys))
          ) {
            // Don't send this key event through to the client
            event.preventDefault();

            // Reset the keys pressed
            keysCurrentlyPressed = {};
            keyboard.reset();

            // Toggle the menu
            $scope.$apply(function () {
              $scope.menu.shown = !$scope.menu.shown;
            });
          }
        }

        // If one of the End keys is pressed, and we have a one keysym from each
        // of Ctrl and Alt groups, send Ctrl-Alt-Delete.
        if (
          END_KEYS[keysym] &&
          !_.isEmpty(_.pick(ALT_KEYS, currentKeysPressedKeys)) &&
          !_.isEmpty(_.pick(CTRL_KEYS, currentKeysPressedKeys))
        ) {
          // Don't send this event through to the client.
          event.preventDefault();

          // Remove the original key press
          delete keysCurrentlyPressed[keysym];

          // Record the substituted key press so that it can be
          // properly dealt with later.
          substituteKeysPressed[keysym] = DEL_KEY;

          // Send through the delete key.
          $scope.$broadcast("guacSyntheticKeydown", DEL_KEY);
        }
      }
    );

    // Update pressed keys as they are released, synchronizing the clipboard
    // with any data that appears to have come from those key presses
    $scope.$on("guacKeyup", function keyupListener(event, keysym, keyboard) {
      // Sync local clipboard with any clipboard data received while this
      // key was pressed (if any) as long as the menu is not open
      var clipboardData = clipboardDataFromKey[keysym];
      if (clipboardData && !$scope.menu.shown)
        clipboardService
          .setLocalClipboard(clipboardData)
          ["catch"](angular.noop);

      // Deal with substitute key presses
      if (substituteKeysPressed[keysym]) {
        event.preventDefault();
        $scope.$broadcast("guacSyntheticKeyup", substituteKeysPressed[keysym]);
        delete substituteKeysPressed[keysym];
      }

      // Mark key as released
      else {
        delete clipboardDataFromKey[keysym];
        delete keysCurrentlyPressed[keysym];
      }
    });

    // Update page title when client title changes
    $scope.$watch("client.title", function clientTitleChanged(title) {
      $scope.page.title = title;
    });

    /**
     * Displays a notification at the end of a Guacamole connection, whether
     * that connection is ending normally or due to an error. As the end of
     * a Guacamole connection may be due to changes in authentication status,
     * this will also implicitly peform a re-authentication attempt to check
     * for such changes, possibly resulting in auth-related events like
     * guacInvalidCredentials.
     *
     * @param {Notification|Boolean|Object} status
     *     The status notification to show, as would be accepted by
     *     guacNotification.showStatus().
     */
    var notifyConnectionClosed = function notifyConnectionClosed(status) {
      // Re-authenticate to verify auth status at end of connection
      authenticationService
        .updateCurrentToken($location.search())
        ["catch"](requestService.IGNORE)

        [
          // Show the requested status once the authentication check has finished
          "finally"
        ](function authenticationCheckComplete() {
          guacNotification.showStatus(status);
        });
    };

    /**
     * Returns whether the current connection has been flagged as unstable due
     * to an apparent network disruption.
     *
     * @returns {Boolean}
     *     true if the current connection has been flagged as unstable, false
     *     otherwise.
     */
    $scope.isConnectionUnstable = function isConnectionUnstable() {
      return $scope.client && $scope.client.clientState.tunnelUnstable;
    };

    /**
     * Notifies the user that the connection state has changed.
     *
     * @param {String} connectionState
     *     The current connection state, as defined by
     *     ManagedClientState.ConnectionState.
     */
    var notifyConnectionState = function notifyConnectionState(
      connectionState
    ) {
      // Hide any existing status
      // guacNotification.showStatus(false);

      // Do not display status if status not known
      if (!connectionState) return;

      // Build array of available actions
      var actions;
      if (NAVIGATE_HOME_ACTION)
        actions = [NAVIGATE_HOME_ACTION, RECONNECT_ACTION, LOGOUT_ACTION];
      else actions = [RECONNECT_ACTION, LOGOUT_ACTION];

      // Get any associated status code
      var status = $scope.client.clientState.statusCode;

      // Connecting
      if (
        connectionState === ManagedClientState.ConnectionState.CONNECTING ||
        connectionState === ManagedClientState.ConnectionState.WAITING
      ) {
        // guacNotification.showStatus({
        //     title: "CLIENT.DIALOG_HEADER_CONNECTING",
        //     text: {
        //         key : "CLIENT.TEXT_CLIENT_STATUS_" + connectionState.toUpperCase()
        //     }
        // });
        $routeParams.onMessage("CONNECTING");
      }

      // Client error
      else if (
        connectionState === ManagedClientState.ConnectionState.CLIENT_ERROR
      ) {
        // Determine translation name of error
        var errorName =
          status in CLIENT_ERRORS
            ? status.toString(16).toUpperCase()
            : "DEFAULT";
        $routeParams.onMessage("CLIENT_ERROR", errorName);
        // Determine whether the reconnect countdown applies
        // var countdown = (status in CLIENT_AUTO_RECONNECT) ? RECONNECT_COUNTDOWN : null;

        // Show error status
        // notifyConnectionClosed({
        //     className : "error",
        //     title     : "CLIENT.DIALOG_HEADER_CONNECTION_ERROR",
        //     text      : {
        //         key : "CLIENT.ERROR_CLIENT_" + errorName
        //     },
        //     countdown : countdown,
        //     actions   : actions
        // });
      }

      // Tunnel error
      else if (
        connectionState === ManagedClientState.ConnectionState.TUNNEL_ERROR
      ) {
        // Determine translation name of error
        var errorName =
          status in TUNNEL_ERRORS
            ? status.toString(16).toUpperCase()
            : "DEFAULT";
        $routeParams.onMessage("TUNNEL_ERROR", errorName);
        // Determine whether the reconnect countdown applies
        // var countdown = (status in TUNNEL_AUTO_RECONNECT) ? RECONNECT_COUNTDOWN : null;

        // // Show error status
        // notifyConnectionClosed({
        //     className : "error",
        //     title     : "CLIENT.DIALOG_HEADER_CONNECTION_ERROR",
        //     text      : {
        //         key : "CLIENT.ERROR_TUNNEL_" + errorName
        //     },
        //     countdown : countdown,
        //     actions   : actions
        // });
      }

      // Disconnected
      else if (
        connectionState === ManagedClientState.ConnectionState.DISCONNECTED
      ) {
        $routeParams.onMessage("DISCONNECTED");
        // notifyConnectionClosed({
        //     title   : "CLIENT.DIALOG_HEADER_DISCONNECTED",
        //     text    : {
        //         key : "CLIENT.TEXT_CLIENT_STATUS_" + connectionState.toUpperCase()
        //     },
        //     actions : actions
        // });
      }

      // Hide status and sync local clipboard once connected
      else if (
        connectionState === ManagedClientState.ConnectionState.CONNECTED
      ) {
        // Sync with local clipboard
        clipboardService.getLocalClipboard().then(function clipboardRead(data) {
          $scope.$broadcast("guacClipboard", data);
        }, angular.noop);

        // Hide status notification
        // guacNotification.showStatus(false);
        $routeParams.onMessage("CONNECTED");
      }

      // Hide status for all other states
      // else
      // guacNotification.showStatus(false);
    };

    /**
     * Prompts the user to enter additional connection parameters. If the
     * protocol and associated parameters of the underlying connection are not
     * yet known, this function has no effect and should be re-invoked once
     * the parameters are known.
     *
     * @param {Object.<String, String>} requiredParameters
     *     The set of all parameters requested by the server via "required"
     *     instructions, where each object key is the name of a requested
     *     parameter and each value is the current value entered by the user.
     */
    var notifyParametersRequired = function notifyParametersRequired(
      requiredParameters
    ) {
      /**
       * Action which submits the current set of parameter values, requesting
       * that the connection continue.
       */
      var SUBMIT_PARAMETERS = {
        name: "CLIENT.ACTION_CONTINUE",
        className: "button",
        callback: function submitParameters() {
          if ($scope.client) {
            var params = $scope.client.requiredParameters;
            $scope.client.requiredParameters = null;
            ManagedClient.sendArguments($scope.client, params);
          }
        },
      };

      /**
       * Action which cancels submission of additional parameters and
       * disconnects from the current connection.
       */
      var CANCEL_PARAMETER_SUBMISSION = {
        name: "CLIENT.ACTION_CANCEL",
        className: "button",
        callback: function cancelSubmission() {
          $scope.client.requiredParameters = null;
          $scope.disconnect();
        },
      };

      // Attempt to prompt for parameters only if the parameters that apply
      // to the underlying connection are known
      if (!$scope.client.protocol || !$scope.client.forms) return;

      // Hide any existing status
      guacNotification.showStatus(false);

      // Prompt for parameters
      guacNotification.showStatus({
        formNamespace: Protocol.getNamespace($scope.client.protocol),
        forms: $scope.client.forms,
        formModel: requiredParameters,
        formSubmitCallback: SUBMIT_PARAMETERS.callback,
        actions: [SUBMIT_PARAMETERS, CANCEL_PARAMETER_SUBMISSION],
      });
    };

    /**
     * Returns whether the given connection state allows for submission of
     * connection parameters via "argv" instructions.
     *
     * @param {String} connectionState
     *     The connection state to test, as defined by
     *     ManagedClientState.ConnectionState.
     *
     * @returns {boolean}
     *     true if the given connection state allows submission of connection
     *     parameters via "argv" instructions, false otherwise.
     */
    var canSubmitParameters = function canSubmitParameters(connectionState) {
      return (
        connectionState === ManagedClientState.ConnectionState.WAITING ||
        connectionState === ManagedClientState.ConnectionState.CONNECTED
      );
    };

    // Show status dialog when connection status changes
    $scope.$watchGroup(
      [
        "client.clientState.connectionState",
        "client.requiredParameters",
        "client.protocol",
        "client.forms",
      ],
      function clientStateChanged(newValues) {
        var connectionState = newValues[0];
        var requiredParameters = newValues[1];

        // Prompt for parameters only if parameters can actually be submitted
        if (requiredParameters && canSubmitParameters(connectionState))
          notifyParametersRequired(requiredParameters);
        // Otherwise, just show general connection state
        else notifyConnectionState(connectionState);
      }
    );

    $scope.zoomIn = function zoomIn() {
      $scope.menu.autoFit = false;
      $scope.client.clientProperties.autoFit = false;
      $scope.client.clientProperties.scale += 0.1;
    };

    $scope.zoomOut = function zoomOut() {
      $scope.client.clientProperties.autoFit = false;
      $scope.client.clientProperties.scale -= 0.1;
    };

    /**
     * When zoom is manually set by entering a value
     * into the controller, this method turns off autoFit,
     * both in the menu and the clientProperties.
     */
    $scope.zoomSet = function zoomSet() {
      $scope.menu.autoFit = false;
      $scope.client.clientProperties.autoFit = false;
    };

    $scope.changeAutoFit = function changeAutoFit() {
      if ($scope.menu.autoFit && $scope.client.clientProperties.minScale) {
        $scope.client.clientProperties.autoFit = true;
      } else {
        $scope.client.clientProperties.autoFit = false;
        $scope.client.clientProperties.scale = 1;
      }
    };

    $scope.autoFitDisabled = function () {
      return $scope.client.clientProperties.minZoom >= 1;
    };

    /**
     * Immediately disconnects the currently-connected client, if any.
     */
    $scope.disconnect = function disconnect() {
      // Disconnect if client is available
      if ($scope.client) $scope.client.client.disconnect();

      // Hide menu
      $scope.menu.shown = false;
    };

    /**
     * Action which immediately disconnects the currently-connected client, if
     * any.
     */
    var DISCONNECT_MENU_ACTION = {
      name: "CLIENT.ACTION_DISCONNECT",
      className: "danger disconnect",
      callback: $scope.disconnect,
    };

    // Set client-specific menu actions
    $scope.clientMenuActions = [DISCONNECT_MENU_ACTION];

    /**
     * @borrows Protocol.getNamespace
     */
    $scope.getProtocolNamespace = Protocol.getNamespace;

    /**
     * The currently-visible filesystem within the filesystem menu, if the
     * filesystem menu is open. If no filesystem is currently visible, this
     * will be null.
     *
     * @type ManagedFilesystem
     */
    $scope.filesystemMenuContents = null;

    /**
     * Hides the filesystem menu.
     */
    $scope.hideFilesystemMenu = function hideFilesystemMenu() {
      $scope.filesystemMenuContents = null;
    };

    /**
     * Shows the filesystem menu, displaying the contents of the given
     * filesystem within it.
     *
     * @param {ManagedFilesystem} filesystem
     *     The filesystem to show within the filesystem menu.
     */
    $scope.showFilesystemMenu = function showFilesystemMenu(filesystem) {
      $scope.filesystemMenuContents = filesystem;
    };

    /**
     * Returns whether the filesystem menu should be visible.
     *
     * @returns {Boolean}
     *     true if the filesystem menu is shown, false otherwise.
     */
    $scope.isFilesystemMenuShown = function isFilesystemMenuShown() {
      return !!$scope.filesystemMenuContents && $scope.menu.shown;
    };

    // Automatically refresh display when filesystem menu is shown
    $scope.$watch("isFilesystemMenuShown()", function refreshFilesystem() {
      // Refresh filesystem, if defined
      var filesystem = $scope.filesystemMenuContents;
      if (filesystem)
        ManagedFilesystem.refresh(filesystem, filesystem.currentDirectory);
    });

    /**
     * Returns the full path to the given file as an ordered array of parent
     * directories.
     *
     * @param {ManagedFilesystem.File} file
     *     The file whose full path should be retrieved.
     *
     * @returns {ManagedFilesystem.File[]}
     *     An array of directories which make up the hierarchy containing the
     *     given file, in order of increasing depth.
     */
    $scope.getPath = function getPath(file) {
      var path = [];

      // Add all files to path in ascending order of depth
      while (file && file.parent) {
        path.unshift(file);
        file = file.parent;
      }

      return path;
    };

    /**
     * Changes the current directory of the given filesystem to the given
     * directory.
     *
     * @param {ManagedFilesystem} filesystem
     *     The filesystem whose current directory should be changed.
     *
     * @param {ManagedFilesystem.File} file
     *     The directory to change to.
     */
    $scope.changeDirectory = function changeDirectory(filesystem, file) {
      ManagedFilesystem.changeDirectory(filesystem, file);
    };

    /**
     * Begins a file upload through the attached Guacamole client for
     * each file in the given FileList.
     *
     * @param {FileList} files
     *     The files to upload.
     */
    $scope.uploadFiles = function uploadFiles(files) {
      // Ignore file uploads if no attached client
      if (!$scope.client) return;

      // Upload each file
      for (var i = 0; i < files.length; i++)
        ManagedClient.uploadFile(
          $scope.client,
          files[i],
          $scope.filesystemMenuContents
        );
    };

    /**
     * Determines whether the attached client has associated file transfers,
     * regardless of those file transfers' state.
     *
     * @returns {Boolean}
     *     true if there are any file transfers associated with the
     *     attached client, false otherise.
     */
    $scope.hasTransfers = function hasTransfers() {
      // There are no file transfers if there is no client
      if (!$scope.client) return false;

      return !!$scope.client.uploads.length;
    };

    /**
     * Returns whether the current user can share the current connection with
     * other users. A connection can be shared if and only if there is at least
     * one associated sharing profile.
     *
     * @returns {Boolean}
     *     true if the current user can share the current connection with other
     *     users, false otherwise.
     */
    $scope.canShareConnection = function canShareConnection() {
      // If there is at least one sharing profile, the connection can be shared
      for (var dummy in $scope.sharingProfiles) return true;

      // Otherwise, sharing is not possible
      return false;
    };

    // Clean up when view destroyed
    $scope.$on("$destroy", function clientViewDestroyed() {
      // Remove client from client manager if no longer connected
      var managedClient = $scope.client;
      if (managedClient) {
        // Get current connection state
        var connectionState = managedClient.clientState.connectionState;

        // If disconnected, remove from management
        if (
          connectionState === ManagedClientState.ConnectionState.DISCONNECTED ||
          connectionState === ManagedClientState.ConnectionState.TUNNEL_ERROR ||
          connectionState === ManagedClientState.ConnectionState.CLIENT_ERROR
        )
          guacClientManager.removeManagedClient(managedClient.id);
      }
    });
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive for the guacamole client.
 */
angular.module("client").directive("guacClient", [
  function guacClient() {
    return {
      // Element only
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The client to display within this guacClient directive.
         *
         * @type ManagedClient
         */
        client: "=",
      },
      templateUrl: "app/client/templates/guacClient.html",
      controller: [
        "$scope",
        "$injector",
        "$element",
        function guacClientController($scope, $injector, $element) {
          // Required types
          var ManagedClient = $injector.get("ManagedClient");

          // Required services
          var $window = $injector.get("$window");

          /**
           * Whether the local, hardware mouse cursor is in use.
           *
           * @type Boolean
           */
          var localCursor = false;

          /**
           * The current Guacamole client instance.
           *
           * @type Guacamole.Client
           */
          var client = null;

          /**
           * The display of the current Guacamole client instance.
           *
           * @type Guacamole.Display
           */
          var display = null;

          /**
           * The element associated with the display of the current
           * Guacamole client instance.
           *
           * @type Element
           */
          var displayElement = null;

          /**
           * The element which must contain the Guacamole display element.
           *
           * @type Element
           */
          var displayContainer = $element.find(".display")[0];

          /**
           * The main containing element for the entire directive.
           *
           * @type Element
           */
          var main = $element[0];

          /**
           * The element which functions as a detector for size changes.
           *
           * @type Element
           */
          var resizeSensor = $element.find(".resize-sensor")[0];

          /**
           * Guacamole mouse event object, wrapped around the main client
           * display.
           *
           * @type Guacamole.Mouse
           */
          var mouse = new Guacamole.Mouse(displayContainer);

          /**
           * Guacamole absolute mouse emulation object, wrapped around the
           * main client display.
           *
           * @type Guacamole.Mouse.Touchscreen
           */
          var touchScreen = new Guacamole.Mouse.Touchscreen(displayContainer);

          /**
           * Guacamole relative mouse emulation object, wrapped around the
           * main client display.
           *
           * @type Guacamole.Mouse.Touchpad
           */
          var touchPad = new Guacamole.Mouse.Touchpad(displayContainer);

          /**
           * Updates the scale of the attached Guacamole.Client based on current window
           * size and "auto-fit" setting.
           */
          var updateDisplayScale = function updateDisplayScale() {
            if (!display) return;

            // Calculate scale to fit screen
            $scope.client.clientProperties.minScale = Math.min(
              main.offsetWidth / Math.max(display.getWidth(), 1),
              main.offsetHeight / Math.max(display.getHeight(), 1)
            );

            // Calculate appropriate maximum zoom level
            $scope.client.clientProperties.maxScale = Math.max(
              $scope.client.clientProperties.minScale,
              3
            );

            // Clamp zoom level, maintain auto-fit
            if (
              display.getScale() < $scope.client.clientProperties.minScale ||
              $scope.client.clientProperties.autoFit
            )
              $scope.client.clientProperties.scale =
                $scope.client.clientProperties.minScale;
            else if (
              display.getScale() > $scope.client.clientProperties.maxScale
            )
              $scope.client.clientProperties.scale =
                $scope.client.clientProperties.maxScale;
          };

          /**
           * Scrolls the client view such that the mouse cursor is visible.
           *
           * @param {Guacamole.Mouse.State} mouseState The current mouse
           *                                           state.
           */
          var scrollToMouse = function scrollToMouse(mouseState) {
            // Determine mouse position within view
            var mouse_view_x =
              mouseState.x + displayContainer.offsetLeft - main.scrollLeft;
            var mouse_view_y =
              mouseState.y + displayContainer.offsetTop - main.scrollTop;

            // Determine viewport dimensions
            var view_width = main.offsetWidth;
            var view_height = main.offsetHeight;

            // Determine scroll amounts based on mouse position relative to document

            var scroll_amount_x;
            if (mouse_view_x > view_width)
              scroll_amount_x = mouse_view_x - view_width;
            else if (mouse_view_x < 0) scroll_amount_x = mouse_view_x;
            else scroll_amount_x = 0;

            var scroll_amount_y;
            if (mouse_view_y > view_height)
              scroll_amount_y = mouse_view_y - view_height;
            else if (mouse_view_y < 0) scroll_amount_y = mouse_view_y;
            else scroll_amount_y = 0;

            // Scroll (if necessary) to keep mouse on screen.
            main.scrollLeft += scroll_amount_x;
            main.scrollTop += scroll_amount_y;
          };

          /**
           * Sends the given mouse state to the current client.
           *
           * @param {Guacamole.Mouse.State} mouseState The mouse state to
           *                                           send.
           */
          var sendScaledMouseState = function sendScaledMouseState(mouseState) {
            // Scale event by current scale
            var scaledState = new Guacamole.Mouse.State(
              mouseState.x / display.getScale(),
              mouseState.y / display.getScale(),
              mouseState.left,
              mouseState.middle,
              mouseState.right,
              mouseState.up,
              mouseState.down
            );

            // Send mouse event
            client.sendMouseState(scaledState);
          };

          /**
           * Handles a mouse event originating from the user's actual mouse.
           * This differs from handleEmulatedMouseState() in that the
           * software mouse cursor must be shown only if the user's browser
           * does not support explicitly setting the hardware mouse cursor.
           *
           * @param {Guacamole.Mouse.State} mouseState
           *     The current state of the user's hardware mouse.
           */
          var handleMouseState = function handleMouseState(mouseState) {
            // Do not attempt to handle mouse state changes if the client
            // or display are not yet available
            if (!client || !display) return;

            // Send mouse state, show cursor if necessary
            display.showCursor(!localCursor);
            sendScaledMouseState(mouseState);
          };

          /**
           * Handles a mouse event originating from one of Guacamole's mouse
           * emulation objects. This differs from handleMouseState() in that
           * the software mouse cursor must always be shown (as the emulated
           * mouse device will not have its own cursor).
           *
           * @param {Guacamole.Mouse.State} mouseState
           *     The current state of the user's emulated (touch) mouse.
           */
          var handleEmulatedMouseState = function handleEmulatedMouseState(
            mouseState
          ) {
            // Do not attempt to handle mouse state changes if the client
            // or display are not yet available
            if (!client || !display) return;

            // Ensure software cursor is shown
            display.showCursor(true);

            // Send mouse state, ensure cursor is visible
            scrollToMouse(mouseState);
            sendScaledMouseState(mouseState);
          };

          // Attach any given managed client
          $scope.$watch("client", function attachManagedClient(managedClient) {
            // Remove any existing display
            displayContainer.innerHTML = "";

            // Only proceed if a client is given
            if (!managedClient) return;

            // Get Guacamole client instance
            client = managedClient.client;

            // Attach possibly new display
            display = client.getDisplay();
            display.scale($scope.client.clientProperties.scale);

            // Add display element
            displayElement = display.getElement();
            displayContainer.appendChild(displayElement);

            // Do nothing when the display element is clicked on
            display.getElement().onclick = function (e) {
              e.preventDefault();
              return false;
            };

            // Size of newly-attached client may be different
            $scope.mainElementResized();
          });

          // Update actual view scrollLeft when scroll properties change
          $scope.$watch(
            "client.clientProperties.scrollLeft",
            function scrollLeftChanged(scrollLeft) {
              main.scrollLeft = scrollLeft;
              $scope.client.clientProperties.scrollLeft = main.scrollLeft;
            }
          );

          // Update actual view scrollTop when scroll properties change
          $scope.$watch(
            "client.clientProperties.scrollTop",
            function scrollTopChanged(scrollTop) {
              main.scrollTop = scrollTop;
              $scope.client.clientProperties.scrollTop = main.scrollTop;
            }
          );

          // Update scale when display is resized
          $scope.$watch(
            "client.managedDisplay.size",
            function setDisplaySize() {
              $scope.$evalAsync(updateDisplayScale);
            }
          );

          // Keep local cursor up-to-date
          $scope.$watch(
            "client.managedDisplay.cursor",
            function setCursor(cursor) {
              if (cursor)
                localCursor = mouse.setCursor(
                  cursor.canvas,
                  cursor.x,
                  cursor.y
                );
            }
          );

          // Swap mouse emulation modes depending on absolute mode flag
          $scope.$watch(
            "client.clientProperties.emulateAbsoluteMouse",
            function mouseEmulationModeChanged(emulateAbsoluteMouse) {
              var newMode, oldMode;

              // Switch to touchscreen if absolute
              if (emulateAbsoluteMouse) {
                newMode = touchScreen;
                oldMode = touchPad;
              }

              // Switch to touchpad if not absolute (relative)
              else {
                newMode = touchPad;
                oldMode = touchScreen;
              }

              // Set applicable mouse emulation object, unset the old one
              if (newMode) {
                // Clear old handlers and copy state to new emulation mode
                if (oldMode) {
                  oldMode.onmousedown =
                    oldMode.onmouseup =
                    oldMode.onmousemove =
                      null;
                  newMode.currentState.x = oldMode.currentState.x;
                  newMode.currentState.y = oldMode.currentState.y;
                }

                // Handle emulated events only from the new emulation mode
                newMode.onmousedown =
                  newMode.onmouseup =
                  newMode.onmousemove =
                    handleEmulatedMouseState;
              }
            }
          );

          // Adjust scale if modified externally
          $scope.$watch(
            "client.clientProperties.scale",
            function changeScale(scale) {
              // Fix scale within limits
              scale = Math.max(scale, $scope.client.clientProperties.minScale);
              scale = Math.min(scale, $scope.client.clientProperties.maxScale);

              // If at minimum zoom level, hide scroll bars
              if (scale === $scope.client.clientProperties.minScale)
                main.style.overflow = "hidden";
              // If not at minimum zoom level, show scroll bars
              else main.style.overflow = "auto";

              // Apply scale if client attached
              if (display) display.scale(scale);

              if (scale !== $scope.client.clientProperties.scale)
                $scope.client.clientProperties.scale = scale;
            }
          );

          // If autofit is set, the scale should be set to the minimum scale, filling the screen
          $scope.$watch(
            "client.clientProperties.autoFit",
            function changeAutoFit(autoFit) {
              if (autoFit)
                $scope.client.clientProperties.scale =
                  $scope.client.clientProperties.minScale;
            }
          );

          // If the element is resized, attempt to resize client
          $scope.mainElementResized = function mainElementResized() {
            // Send new display size, if changed
            if (client && display) {
              var pixelDensity = $window.devicePixelRatio || 1;
              var width = main.offsetWidth * pixelDensity;
              var height = main.offsetHeight * pixelDensity;

              if (
                display.getWidth() !== width ||
                display.getHeight() !== height
              )
                client.sendSize(width, height);
            }

            $scope.$evalAsync(updateDisplayScale);
          };

          // Ensure focus is regained via mousedown before forwarding event
          mouse.onmousedown = function (mouseState) {
            document.body.focus();
            handleMouseState(mouseState);
          };

          // Forward mouseup / mousemove events untouched
          mouse.onmouseup = mouse.onmousemove = handleMouseState;

          // Hide software cursor when mouse leaves display
          mouse.onmouseout = function () {
            if (!display) return;
            display.showCursor(false);
          };

          // Update remote clipboard if local clipboard changes
          $scope.$on("guacClipboard", function onClipboard(event, data) {
            if (client) {
              ManagedClient.setClipboard($scope.client, data);
              $scope.client.clipboardData = data;
            }
          });

          // Translate local keydown events to remote keydown events if keyboard is enabled
          $scope.$on(
            "guacKeydown",
            function keydownListener(event, keysym, keyboard) {
              if (
                $scope.client.clientProperties.keyboardEnabled &&
                !event.defaultPrevented
              ) {
                client.sendKeyEvent(1, keysym);
                event.preventDefault();
              }
            }
          );

          // Translate local keyup events to remote keyup events if keyboard is enabled
          $scope.$on(
            "guacKeyup",
            function keyupListener(event, keysym, keyboard) {
              if (
                $scope.client.clientProperties.keyboardEnabled &&
                !event.defaultPrevented
              ) {
                client.sendKeyEvent(0, keysym);
                event.preventDefault();
              }
            }
          );

          // Universally handle all synthetic keydown events
          $scope.$on(
            "guacSyntheticKeydown",
            function syntheticKeydownListener(event, keysym) {
              client.sendKeyEvent(1, keysym);
            }
          );

          // Universally handle all synthetic keyup events
          $scope.$on(
            "guacSyntheticKeyup",
            function syntheticKeyupListener(event, keysym) {
              client.sendKeyEvent(0, keysym);
            }
          );

          /**
           * Ignores the given event.
           *
           * @param {Event} e The event to ignore.
           */
          function ignoreEvent(e) {
            e.preventDefault();
            e.stopPropagation();
          }

          // Handle and ignore dragenter/dragover
          displayContainer.addEventListener("dragenter", ignoreEvent, false);
          displayContainer.addEventListener("dragover", ignoreEvent, false);

          // File drop event handler
          displayContainer.addEventListener(
            "drop",
            function (e) {
              e.preventDefault();
              e.stopPropagation();

              // Ignore file drops if no attached client
              if (!$scope.client) return;

              // Upload each file
              var files = e.dataTransfer.files;
              for (var i = 0; i < files.length; i++)
                ManagedClient.uploadFile($scope.client, files[i]);
            },
            false
          );

          /*
           * END CLIENT DIRECTIVE
           */
        },
      ],
    };
  },
]);

/**
 * A directive for the guacamole client page.
 */
angular.module("client").directive("guacClientPage", [
  function guacClient() {
    return {
      // Element only
      restrict: "E",
      replace: false,
      templateUrl: "app/client/templates/client.html",
      controller: "clientController",
    };
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A toolbar/panel which displays a list of active Guacamole connections. The
 * panel is fixed to the bottom-right corner of its container and can be
 * manually hidden/exposed by the user.
 */
angular.module("client").directive("guacClientPanel", [
  "$injector",
  function guacClientPanel($injector) {
    // Required services
    var guacClientManager = $injector.get("guacClientManager");
    var sessionStorageFactory = $injector.get("sessionStorageFactory");

    // Required types
    var ManagedClientState = $injector.get("ManagedClientState");

    /**
     * Getter/setter for the boolean flag controlling whether the client panel
     * is currently hidden. This flag is maintained in session-local storage to
     * allow the state of the panel to persist despite navigation within the
     * same tab. When hidden, the panel will be collapsed against the right
     * side of the container. By default, the panel is visible.
     *
     * @type Function
     */
    var panelHidden = sessionStorageFactory.create(false);

    return {
      // Element only
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The ManagedClient instances associated with the active
         * connections to be displayed within this panel.
         *
         * @type ManagedClient[]|Object.<String, ManagedClient>
         */
        clients: "=",
      },
      templateUrl: "app/client/templates/guacClientPanel.html",
      controller: [
        "$scope",
        "$element",
        function guacClientPanelController($scope, $element) {
          /**
           * The DOM element containing the scrollable portion of the client
           * panel.
           *
           * @type Element
           */
          var scrollableArea = $element.find(
            ".client-panel-connection-list"
          )[0];

          /**
           * On-scope reference to session-local storage of the flag
           * controlling whether then panel is hidden.
           */
          $scope.panelHidden = panelHidden;

          /**
           * Returns whether this panel currently has any clients associated
           * with it.
           *
           * @return {Boolean}
           *     true if at least one client is associated with this panel,
           *     false otherwise.
           */
          $scope.hasClients = function hasClients() {
            return !!_.find($scope.clients, $scope.isManaged);
          };

          /**
           * Returns whether the status of the given client has changed in a
           * way that requires the user's attention. This may be due to an
           * error, or due to a server-initiated disconnect.
           *
           * @param {ManagedClient} client
           *     The client to test.
           *
           * @returns {Boolean}
           *     true if the given client requires the user's attention,
           *     false otherwise.
           */
          $scope.hasStatusUpdate = function hasStatusUpdate(client) {
            // Test whether the client has encountered an error
            switch (client.clientState.connectionState) {
              case ManagedClientState.ConnectionState.CONNECTION_ERROR:
              case ManagedClientState.ConnectionState.TUNNEL_ERROR:
              case ManagedClientState.ConnectionState.DISCONNECTED:
                return true;
            }

            return false;
          };

          /**
           * Returns whether the given client is currently being managed by
           * the guacClientManager service.
           *
           * @param {ManagedClient} client
           *     The client to test.
           *
           * @returns {Boolean}
           *     true if the given client is being managed by the
           *     guacClientManager service, false otherwise.
           */
          $scope.isManaged = function isManaged(client) {
            return !!guacClientManager.getManagedClients()[client.id];
          };

          /**
           * Initiates an orderly disconnect of the given client. The client
           * is removed from management such that attempting to connect to
           * the same connection will result in a new connection being
           * established, rather than displaying a notification that the
           * connection has ended.
           *
           * @param {type} client
           * @returns {undefined}
           */
          $scope.disconnect = function disconnect(client) {
            client.client.disconnect();
            guacClientManager.removeManagedClient(client.id);
          };

          /**
           * Toggles whether the client panel is currently hidden.
           */
          $scope.togglePanel = function togglePanel() {
            panelHidden(!panelHidden());
          };

          // Override vertical scrolling, scrolling horizontally instead
          scrollableArea.addEventListener(
            "wheel",
            function reorientVerticalScroll(e) {
              var deltaMultiplier = {
                /* DOM_DELTA_PIXEL */ 0x00: 1,
                /* DOM_DELTA_LINE  */ 0x01: 15,
                /* DOM_DELTA_PAGE  */ 0x02: scrollableArea.offsetWidth,
              };

              if (e.deltaY) {
                this.scrollLeft +=
                  e.deltaY *
                  (deltaMultiplier[e.deltaMode] || deltaMultiplier(0x01));
                e.preventDefault();
              }
            }
          );
        },
      ],
    };
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which displays the contents of a filesystem received through the
 * Guacamole client.
 */
angular.module("client").directive("guacFileBrowser", [
  function guacFileBrowser() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The client whose file transfers should be managed by this
         * directive.
         *
         * @type ManagedClient
         */
        client: "=",

        /**
         * @type ManagedFilesystem
         */
        filesystem: "=",
      },

      templateUrl: "app/client/templates/guacFileBrowser.html",
      controller: [
        "$scope",
        "$element",
        "$injector",
        function guacFileBrowserController($scope, $element, $injector) {
          // Required types
          var ManagedFilesystem = $injector.get("ManagedFilesystem");

          // Required services
          var $interpolate = $injector.get("$interpolate");
          var $templateRequest = $injector.get("$templateRequest");

          /**
           * The jQuery-wrapped element representing the contents of the
           * current directory within the file browser.
           *
           * @type Element[]
           */
          var currentDirectoryContents = $element.find(
            ".current-directory-contents"
          );

          /**
           * Statically-cached template HTML used to render each file within
           * a directory. Once available, this will be used through
           * createFileElement() to generate the DOM elements which make up
           * a directory listing.
           *
           * @type String
           */
          var fileTemplate = null;

          /**
           * Returns whether the given file is a normal file.
           *
           * @param {ManagedFilesystem.File} file
           *     The file to test.
           *
           * @returns {Boolean}
           *     true if the given file is a normal file, false otherwise.
           */
          $scope.isNormalFile = function isNormalFile(file) {
            return file.type === ManagedFilesystem.File.Type.NORMAL;
          };

          /**
           * Returns whether the given file is a directory.
           *
           * @param {ManagedFilesystem.File} file
           *     The file to test.
           *
           * @returns {Boolean}
           *     true if the given file is a directory, false otherwise.
           */
          $scope.isDirectory = function isDirectory(file) {
            return file.type === ManagedFilesystem.File.Type.DIRECTORY;
          };

          /**
           * Changes the currently-displayed directory to the given
           * directory.
           *
           * @param {ManagedFilesystem.File} file
           *     The directory to change to.
           */
          $scope.changeDirectory = function changeDirectory(file) {
            ManagedFilesystem.changeDirectory($scope.filesystem, file);
          };

          /**
           * Initiates a download of the given file. The progress of the
           * download can be observed through guacFileTransferManager.
           *
           * @param {ManagedFilesystem.File} file
           *     The file to download.
           */
          $scope.downloadFile = function downloadFile(file) {
            ManagedFilesystem.downloadFile(
              $scope.client,
              $scope.filesystem,
              file.streamName
            );
          };

          /**
           * Recursively interpolates all text nodes within the DOM tree of
           * the given element. All other node types, attributes, etc. will
           * be left uninterpolated.
           *
           * @param {Element} element
           *     The element at the root of the DOM tree to be interpolated.
           *
           * @param {Object} context
           *     The evaluation context to use when evaluating expressions
           *     embedded in text nodes within the provided element.
           */
          var interpolateElement = function interpolateElement(
            element,
            context
          ) {
            // Interpolate the contents of text nodes directly
            if (element.nodeType === Node.TEXT_NODE)
              element.nodeValue = $interpolate(element.nodeValue)(context);

            // Recursively interpolate the contents of all descendant text
            // nodes
            if (element.hasChildNodes()) {
              var children = element.childNodes;
              for (var i = 0; i < children.length; i++)
                interpolateElement(children[i], context);
            }
          };

          /**
           * Creates a new element representing the given file and properly
           * handling user events, bypassing the overhead incurred through
           * use of ngRepeat and related techniques.
           *
           * Note that this function depends on the availability of the
           * statically-cached fileTemplate.
           *
           * @param {ManagedFilesystem.File} file
           *     The file to generate an element for.
           *
           * @returns {Element[]}
           *     A jQuery-wrapped array containing a single DOM element
           *     representing the given file.
           */
          var createFileElement = function createFileElement(file) {
            // Create from internal template
            var element = angular.element(fileTemplate);
            interpolateElement(element[0], file);

            // Double-clicking on unknown file types will do nothing
            var fileAction = function doNothing() {};

            // Change current directory when directories are clicked
            if ($scope.isDirectory(file)) {
              element.addClass("directory");
              fileAction = function changeDirectory() {
                $scope.changeDirectory(file);
              };
            }

            // Initiate downloads when normal files are clicked
            else if ($scope.isNormalFile(file)) {
              element.addClass("normal-file");
              fileAction = function downloadFile() {
                $scope.downloadFile(file);
              };
            }

            // Mark file as focused upon click
            element.on("click", function handleFileClick() {
              // Fire file-specific action if already focused
              if (element.hasClass("focused")) {
                fileAction();
                element.removeClass("focused");
              }

              // Otherwise mark as focused
              else {
                element.parent().children().removeClass("focused");
                element.addClass("focused");
              }
            });

            // Prevent text selection during navigation
            element.on("selectstart", function avoidSelect(e) {
              e.preventDefault();
              e.stopPropagation();
            });

            return element;
          };

          /**
           * Sorts the given map of files, returning an array of those files
           * grouped by file type (directories first, followed by non-
           * directories) and sorted lexicographically.
           *
           * @param {Object.<String, ManagedFilesystem.File>} files
           *     The map of files to sort.
           *
           * @returns {ManagedFilesystem.File[]}
           *     An array of all files in the given map, sorted
           *     lexicographically with directories first, followed by non-
           *     directories.
           */
          var sortFiles = function sortFiles(files) {
            // Get all given files as an array
            var unsortedFiles = [];
            for (var name in files) unsortedFiles.push(files[name]);

            // Sort files - directories first, followed by all other files
            // sorted by name
            return unsortedFiles.sort(function fileComparator(a, b) {
              // Directories come before non-directories
              if ($scope.isDirectory(a) && !$scope.isDirectory(b)) return -1;

              // Non-directories come after directories
              if (!$scope.isDirectory(a) && $scope.isDirectory(b)) return 1;

              // All other combinations are sorted by name
              return a.name.localeCompare(b.name);
            });
          };

          // Watch directory contents once file template is available
          $templateRequest("app/client/templates/file.html").then(
            function fileTemplateRetrieved(html) {
              // Store file template statically
              fileTemplate = html;

              // Update the contents of the file browser whenever the current directory (or its contents) changes
              $scope.$watch(
                "filesystem.currentDirectory.files",
                function currentDirectoryChanged(files) {
                  // Clear current content
                  currentDirectoryContents.html("");

                  // Display all files within current directory, sorted
                  angular.forEach(sortFiles(files), function displayFile(file) {
                    currentDirectoryContents.append(createFileElement(file));
                  });
                }
              );
            },
            angular.noop
          ); // end retrieve file template

          // Refresh file browser when any upload completes
          $scope.$on(
            "guacUploadComplete",
            function uploadComplete(event, filename) {
              // Refresh filesystem, if it exists
              if ($scope.filesystem)
                ManagedFilesystem.refresh(
                  $scope.filesystem,
                  $scope.filesystem.currentDirectory
                );
            }
          );
        },
      ],
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Directive which displays an active file transfer, providing links for
 * downloads, if applicable.
 */
angular.module("client").directive("guacFileTransfer", [
  function guacFileTransfer() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The file transfer to display.
         *
         * @type ManagedFileUpload|ManagedFileDownload
         */
        transfer: "=",
      },

      templateUrl: "app/client/templates/guacFileTransfer.html",
      controller: [
        "$scope",
        "$injector",
        function guacFileTransferController($scope, $injector) {
          // Required types
          var ManagedFileTransferState = $injector.get(
            "ManagedFileTransferState"
          );

          /**
           * All upload error codes handled and passed off for translation.
           * Any error code not present in this list will be represented by
           * the "DEFAULT" translation.
           */
          var UPLOAD_ERRORS = {
            0x0100: true,
            0x0201: true,
            0x0202: true,
            0x0203: true,
            0x0204: true,
            0x0205: true,
            0x0301: true,
            0x0303: true,
            0x0308: true,
            0x031d: true,
          };

          /**
           * Returns the unit string that is most appropriate for the
           * number of bytes transferred thus far - either 'gb', 'mb', 'kb',
           * or 'b'.
           *
           * @returns {String}
           *     The unit string that is most appropriate for the number of
           *     bytes transferred thus far.
           */
          $scope.getProgressUnit = function getProgressUnit() {
            var bytes = $scope.transfer.progress;

            // Gigabytes
            if (bytes > 1000000000) return "gb";

            // Megabytes
            if (bytes > 1000000) return "mb";

            // Kilobytes
            if (bytes > 1000) return "kb";

            // Bytes
            return "b";
          };

          /**
           * Returns the amount of data transferred thus far, in the units
           * returned by getProgressUnit().
           *
           * @returns {Number}
           *     The amount of data transferred thus far, in the units
           *     returned by getProgressUnit().
           */
          $scope.getProgressValue = function getProgressValue() {
            var bytes = $scope.transfer.progress;
            if (!bytes) return bytes;

            // Convert bytes to necessary units
            switch ($scope.getProgressUnit()) {
              // Gigabytes
              case "gb":
                return (bytes / 1000000000).toFixed(1);

              // Megabytes
              case "mb":
                return (bytes / 1000000).toFixed(1);

              // Kilobytes
              case "kb":
                return (bytes / 1000).toFixed(1);

              // Bytes
              case "b":
              default:
                return bytes;
            }
          };

          /**
           * Returns the percentage of bytes transferred thus far, if the
           * overall length of the file is known.
           *
           * @returns {Number}
           *     The percentage of bytes transferred thus far, if the
           *     overall length of the file is known.
           */
          $scope.getPercentDone = function getPercentDone() {
            return ($scope.transfer.progress / $scope.transfer.length) * 100;
          };

          /**
           * Determines whether the associated file transfer is in progress.
           *
           * @returns {Boolean}
           *     true if the file transfer is in progress, false othherwise.
           */
          $scope.isInProgress = function isInProgress() {
            // Not in progress if there is no transfer
            if (!$scope.transfer) return false;

            // Determine in-progress status based on stream state
            switch ($scope.transfer.transferState.streamState) {
              // IDLE or OPEN file transfers are active
              case ManagedFileTransferState.StreamState.IDLE:
              case ManagedFileTransferState.StreamState.OPEN:
                return true;

              // All others are not active
              default:
                return false;
            }
          };

          /**
           * Returns whether the file associated with this file transfer can
           * be saved locally via a call to save().
           *
           * @returns {Boolean}
           *     true if a call to save() will result in the file being
           *     saved, false otherwise.
           */
          $scope.isSavable = function isSavable() {
            return !!$scope.transfer.blob;
          };

          /**
           * Saves the downloaded file, if any. If this transfer is an upload
           * or the download is not yet complete, this function has no
           * effect.
           */
          $scope.save = function save() {
            // Ignore if no blob exists
            if (!$scope.transfer.blob) return;

            // Save file
            saveAs($scope.transfer.blob, $scope.transfer.filename);
          };

          /**
           * Returns whether an error has occurred. If an error has occurred,
           * the transfer is no longer active, and the text of the error can
           * be read from getErrorText().
           *
           * @returns {Boolean}
           *     true if an error has occurred during transfer, false
           *     otherwise.
           */
          $scope.hasError = function hasError() {
            return (
              $scope.transfer.transferState.streamState ===
              ManagedFileTransferState.StreamState.ERROR
            );
          };

          /**
           * Returns the text of the current error as a translation string.
           *
           * @returns {String}
           *     The name of the translation string containing the text
           *     associated with the current error.
           */
          $scope.getErrorText = function getErrorText() {
            // Determine translation name of error
            var status = $scope.transfer.transferState.statusCode;
            var errorName =
              status in UPLOAD_ERRORS
                ? status.toString(16).toUpperCase()
                : "DEFAULT";

            // Return translation string
            return "CLIENT.ERROR_UPLOAD_" + errorName;
          };
        },
      ], // end file transfer controller
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Directive which displays all active file transfers.
 */
angular.module("client").directive("guacFileTransferManager", [
  function guacFileTransferManager() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The client whose file transfers should be managed by this
         * directive.
         *
         * @type ManagerClient
         */
        client: "=",
      },

      templateUrl: "app/client/templates/guacFileTransferManager.html",
      controller: [
        "$scope",
        "$injector",
        function guacFileTransferManagerController($scope, $injector) {
          // Required types
          var ManagedFileTransferState = $injector.get(
            "ManagedFileTransferState"
          );

          /**
           * Determines whether the given file transfer state indicates an
           * in-progress transfer.
           *
           * @param {ManagedFileTransferState} transferState
           *     The file transfer state to check.
           *
           * @returns {Boolean}
           *     true if the given file transfer state indicates an in-
           *     progress transfer, false otherwise.
           */
          var isInProgress = function isInProgress(transferState) {
            switch (transferState.streamState) {
              // IDLE or OPEN file transfers are active
              case ManagedFileTransferState.StreamState.IDLE:
              case ManagedFileTransferState.StreamState.OPEN:
                return true;

              // All others are not active
              default:
                return false;
            }
          };

          /**
           * Removes all file transfers which are not currently in-progress.
           */
          $scope.clearCompletedTransfers = function clearCompletedTransfers() {
            // Nothing to clear if no client attached
            if (!$scope.client) return;

            // Remove completed uploads
            $scope.client.uploads = $scope.client.uploads.filter(
              function isUploadInProgress(upload) {
                return isInProgress(upload.transferState);
              }
            );
          };
        },
      ],
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive for displaying a Guacamole client as a non-interactive
 * thumbnail.
 */
angular.module("client").directive("guacThumbnail", [
  function guacThumbnail() {
    return {
      // Element only
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The client to display within this guacThumbnail directive.
         *
         * @type ManagedClient
         */
        client: "=",
      },
      templateUrl: "app/client/templates/guacThumbnail.html",
      controller: [
        "$scope",
        "$injector",
        "$element",
        function guacThumbnailController($scope, $injector, $element) {
          // Required services
          var $window = $injector.get("$window");

          /**
           * The optimal thumbnail width, in pixels.
           *
           * @type Number
           */
          var THUMBNAIL_WIDTH = 320;

          /**
           * The optimal thumbnail height, in pixels.
           *
           * @type Number
           */
          var THUMBNAIL_HEIGHT = 240;

          /**
           * The display of the current Guacamole client instance.
           *
           * @type Guacamole.Display
           */
          var display = null;

          /**
           * The element associated with the display of the current
           * Guacamole client instance.
           *
           * @type Element
           */
          var displayElement = null;

          /**
           * The element which must contain the Guacamole display element.
           *
           * @type Element
           */
          var displayContainer = $element.find(".display")[0];

          /**
           * The main containing element for the entire directive.
           *
           * @type Element
           */
          var main = $element[0];

          /**
           * Updates the scale of the attached Guacamole.Client based on current window
           * size and "auto-fit" setting.
           */
          $scope.updateDisplayScale = function updateDisplayScale() {
            if (!display) return;

            // Fit within available area
            display.scale(
              Math.min(
                main.offsetWidth / Math.max(display.getWidth(), 1),
                main.offsetHeight / Math.max(display.getHeight(), 1)
              )
            );
          };

          // Attach any given managed client
          $scope.$watch("client", function attachManagedClient(managedClient) {
            // Remove any existing display
            displayContainer.innerHTML = "";

            // Only proceed if a client is given
            if (!managedClient) return;

            // Get Guacamole client instance
            var client = managedClient.client;

            // Attach possibly new display
            display = client.getDisplay();

            // Add display element
            displayElement = display.getElement();
            displayContainer.appendChild(displayElement);
          });

          // Update scale when display is resized
          $scope.$watch(
            "client.managedDisplay.size",
            function setDisplaySize(size) {
              var width;
              var height;

              // If no display size yet, assume optimal thumbnail size
              if (!size || size.width === 0 || size.height === 0) {
                width = THUMBNAIL_WIDTH;
                height = THUMBNAIL_HEIGHT;
              }

              // Otherwise, generate size that fits within thumbnail bounds
              else {
                var scale = Math.min(
                  THUMBNAIL_WIDTH / size.width,
                  THUMBNAIL_HEIGHT / size.height,
                  1
                );
                width = size.width * scale;
                height = size.height * scale;
              }

              // Generate dummy background image
              var thumbnail = document.createElement("canvas");
              thumbnail.width = width;
              thumbnail.height = height;
              $scope.thumbnail = thumbnail.toDataURL("image/png");

              // Init display scale
              $scope.$evalAsync($scope.updateDisplayScale);
            }
          );
        },
      ],
    };
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which provides a fullscreen environment for its content.
 */
angular.module("client").directive("guacViewport", [
  function guacViewport() {
    return {
      // Element only
      restrict: "E",
      scope: {},
      transclude: true,
      templateUrl: "app/client/templates/guacViewport.html",
      controller: [
        "$scope",
        "$injector",
        "$element",
        function guacViewportController($scope, $injector, $element) {
          // Required services
          var $window = $injector.get("$window");

          /**
           * The fullscreen container element.
           *
           * @type Element
           */
          var element = $element.find(".viewport")[0];

          /**
           * The width of the browser viewport when fitVisibleArea() was last
           * invoked, in pixels, or null if fitVisibleArea() has not yet been
           * called.
           *
           * @type Number
           */
          var lastViewportWidth = null;

          /**
           * The height of the browser viewport when fitVisibleArea() was
           * last invoked, in pixels, or null if fitVisibleArea() has not yet
           * been called.
           *
           * @type Number
           */
          var lastViewportHeight = null;

          /**
           * Resizes the container element inside the guacViewport such that
           * it exactly fits within the visible area, even if the browser has
           * been scrolled.
           */
          var fitVisibleArea = function fitVisibleArea() {
            // Calculate viewport dimensions (this is NOT necessarily the
            // same as 100vw and 100vh, 100%, etc., particularly when the
            // on-screen keyboard of a mobile device pops open)
            var viewportWidth = $window.innerWidth;
            var viewportHeight = $window.innerHeight;

            // Adjust element width to fit exactly within visible area
            if (viewportWidth !== lastViewportWidth) {
              element.style.width = viewportWidth + "px";
              lastViewportWidth = viewportWidth;
            }

            // Adjust element height to fit exactly within visible area
            if (viewportHeight !== lastViewportHeight) {
              element.style.height = viewportHeight + "px";
              lastViewportHeight = viewportHeight;
            }

            // Scroll element such that its upper-left corner is exactly
            // within the viewport upper-left corner, if not already there
            if (element.scrollLeft || element.scrollTop) {
              $window.scrollTo(
                $window.pageXOffset + element.scrollLeft,
                $window.pageYOffset + element.scrollTop
              );
            }
          };

          // Fit container within visible region when window scrolls
          $window.addEventListener("scroll", fitVisibleArea);

          // Poll every 10ms, in case scroll event does not fire
          var pollArea = $window.setInterval(fitVisibleArea, 10);

          // Clean up on destruction
          $scope.$on("$destroy", function destroyViewport() {
            $window.removeEventListener("scroll", fitVisibleArea);
            $window.clearInterval(pollArea);
          });
        },
      ],
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which converts between human-readable zoom
 * percentage and display scale.
 */
angular.module("client").directive("guacZoomCtrl", function guacZoomCtrl() {
  return {
    restrict: "A",
    require: "ngModel",
    priority: 101,
    link: function (scope, element, attrs, ngModel) {
      // Evaluate the ngChange attribute when the model
      // changes.
      ngModel.$viewChangeListeners.push(function () {
        scope.$eval(attrs.ngChange);
      });

      // When pushing to the menu, mutiply by 100.
      ngModel.$formatters.push(function (value) {
        return Math.round(value * 100);
      });

      // When parsing value from menu, divide by 100.
      ngModel.$parsers.push(function (value) {
        return Math.round(value) / 100;
      });
    },
  };
});

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for checking browser audio support.
 */
angular.module("client").factory("guacAudio", [
  function guacAudio() {
    /**
     * Object describing the UI's level of audio support.
     */
    return new (function () {
      /**
       * Array of all supported audio mimetypes.
       *
       * @type String[]
       */
      this.supported = Guacamole.AudioPlayer.getSupportedTypes();
    })();
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for managing several active Guacamole clients.
 */
angular.module("client").factory("guacClientManager", [
  "$injector",
  function guacClientManager($injector) {
    // Required types
    var ManagedClient = $injector.get("ManagedClient");

    // Required services
    var $window = $injector.get("$window");
    var sessionStorageFactory = $injector.get("sessionStorageFactory");

    var service = {};

    /**
     * Getter/setter which retrieves or sets the map of all active managed
     * clients. Each key is the ID of the connection used by that client.
     *
     * @type Function
     */
    var storedManagedClients = sessionStorageFactory.create(
      {},
      function destroyClientStorage() {
        // Disconnect all clients when storage is destroyed
        service.clear();
      }
    );

    /**
     * Returns a map of all active managed clients. Each key is the ID of the
     * connection used by that client.
     *
     * @returns {Object.<String, ManagedClient>}
     *     A map of all active managed clients.
     */
    service.getManagedClients = function getManagedClients() {
      return storedManagedClients();
    };

    /**
     * Removes the existing ManagedClient associated with the connection having
     * the given ID, if any. If no such a ManagedClient already exists, this
     * function has no effect.
     *
     * @param {String} id
     *     The ID of the connection whose ManagedClient should be removed.
     *
     * @returns {Boolean}
     *     true if an existing client was removed, false otherwise.
     */
    service.removeManagedClient = function replaceManagedClient(id) {
      var managedClients = storedManagedClients();

      // Remove client if it exists
      if (id in managedClients) {
        // Disconnect and remove
        managedClients[id].client.disconnect();
        delete managedClients[id];

        // A client was removed
        return true;
      }

      // No client was removed
      return false;
    };

    /**
     * Creates a new ManagedClient associated with the connection having the
     * given ID. If such a ManagedClient already exists, it is disconnected and
     * replaced.
     *
     * @param {String} id
     *     The ID of the connection whose ManagedClient should be retrieved.
     *
     * @param {String} [connectionParameters]
     *     Any additional HTTP parameters to pass while connecting. This
     *     parameter only has an effect if a new connection is established as
     *     a result of this function call.
     *
     * @returns {ManagedClient}
     *     The ManagedClient associated with the connection having the given
     *     ID.
     */
    service.replaceManagedClient = function replaceManagedClient(
      id,
      connectionParameters
    ) {
      // Disconnect any existing client
      service.removeManagedClient(id);

      // Set new client
      return (storedManagedClients()[id] = ManagedClient.getInstance(
        id,
        connectionParameters
      ));
    };

    /**
     * Returns the ManagedClient associated with the connection having the
     * given ID. If no such ManagedClient exists, a new ManagedClient is
     * created.
     *
     * @param {String} id
     *     The ID of the connection whose ManagedClient should be retrieved.
     *
     * @param {String} [connectionParameters]
     *     Any additional HTTP parameters to pass while connecting. This
     *     parameter only has an effect if a new connection is established as
     *     a result of this function call.
     *
     * @returns {ManagedClient}
     *     The ManagedClient associated with the connection having the given
     *     ID.
     */
    service.getManagedClient = function getManagedClient(
      id,
      connectionParameters
    ) {
      var managedClients = storedManagedClients();

      // Create new managed client if it doesn't already exist
      if (!(id in managedClients))
        managedClients[id] = ManagedClient.getInstance(
          id,
          connectionParameters
        );

      // Return existing client
      return managedClients[id];
    };

    /**
     * Disconnects and removes all currently-connected clients.
     */
    service.clear = function clear() {
      var managedClients = storedManagedClients();

      // Disconnect each managed client
      for (var id in managedClients) managedClients[id].client.disconnect();

      // Clear managed clients
      storedManagedClients({});
    };

    // Disconnect all clients when window is unloaded
    $window.addEventListener("unload", service.clear);

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for checking browser image support.
 */
angular.module("client").factory("guacImage", [
  "$injector",
  function guacImage($injector) {
    // Required services
    var $q = $injector.get("$q");

    var service = {};

    /**
     * Map of possibly-supported image mimetypes to corresponding test images
     * encoded with base64. If the image is correctly decoded, it will be a
     * single pixel (1x1) image.
     *
     * @type Object.<String, String>
     */
    var testImages = {
      /**
       * Test JPEG image, encoded as base64.
       */
      "image/jpeg":
        "/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoH" +
        "BwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQME" +
        "BAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU" +
        "FBQUFBQUFBQUFBQUFBT/wAARCAABAAEDAREAAhEBAxEB/8QAFAABAAAAAAAAAAA" +
        "AAAAAAAAACf/EABQQAQAAAAAAAAAAAAAAAAAAAAD/xAAUAQEAAAAAAAAAAAAAAA" +
        "AAAAAA/8QAFBEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AVMH/2Q==",

      /**
       * Test PNG image, encoded as base64.
       */
      "image/png":
        "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEX///+nxBvI" +
        "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==",

      /**
       * Test WebP image, encoded as base64.
       */
      "image/webp": "UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==",
    };

    /**
     * Deferred which tracks the progress and ultimate result of all pending
     * image format tests.
     *
     * @type Deferred
     */
    var deferredSupportedMimetypes = $q.defer();

    /**
     * Array of all promises associated with pending image tests. Each image
     * test promise MUST be guaranteed to resolve and MUST NOT be rejected.
     *
     * @type Promise[]
     */
    var pendingTests = [];

    /**
     * The array of supported image formats. This will be gradually populated
     * by the various image tests that occur in the background, and will not be
     * fully populated until all promises within pendingTests are resolved.
     *
     * @type String[]
     */
    var supported = [];

    /**
     * Return a promise which resolves with to an array of image mimetypes
     * supported by the browser, once those mimetypes are known. The returned
     * promise is guaranteed to resolve successfully.
     *
     * @returns {Promise.<String[]>}
     *     A promise which resolves with an array of image mimetypes supported
     *     by the browser.
     */
    service.getSupportedMimetypes = function getSupportedMimetypes() {
      return deferredSupportedMimetypes.promise;
    };

    // Test each possibly-supported image
    angular.forEach(testImages, function testImageSupport(data, mimetype) {
      // Add promise for current image test
      var imageTest = $q.defer();
      pendingTests.push(imageTest.promise);

      // Attempt to load image
      var image = new Image();
      image.src = "data:" + mimetype + ";base64," + data;

      // Store as supported depending on whether load was successful
      image.onload = image.onerror = function imageTestComplete() {
        // Image format is supported if successfully decoded
        if (image.width === 1 && image.height === 1) supported.push(mimetype);

        // Test is complete
        imageTest.resolve();
      };
    });

    // When all image tests are complete, resolve promise with list of
    // supported formats
    $q.all(pendingTests).then(function imageTestsCompleted() {
      deferredSupportedMimetypes.resolve(supported);
    });

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for checking browser video support.
 */
angular.module("client").factory("guacVideo", [
  function guacVideo() {
    /**
     * Object describing the UI's level of video support.
     */
    return new (function () {
      /**
       * Array of all supported video mimetypes.
       */
      this.supported = Guacamole.VideoPlayer.getSupportedTypes();
    })();
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for generating new guacClient properties objects.
 */
angular.module("client").factory("ClientProperties", [
  "$injector",
  function defineClientProperties($injector) {
    // Required services
    var preferenceService = $injector.get("preferenceService");

    /**
     * Object used for interacting with a guacClient directive.
     *
     * @constructor
     * @param {ClientProperties|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ClientProperties.
     */
    var ClientProperties = function ClientProperties(template) {
      // Use empty object by default
      template = template || {};

      /**
       * Whether the display should be scaled automatically to fit within the
       * available space.
       *
       * @type Boolean
       */
      this.autoFit = template.autoFit || true;

      /**
       * The current scale. If autoFit is true, the effect of setting this
       * value is undefined.
       *
       * @type Number
       */
      this.scale = template.scale || 1;

      /**
       * The minimum scale value.
       *
       * @type Number
       */
      this.minScale = template.minScale || 1;

      /**
       * The maximum scale value.
       *
       * @type Number
       */
      this.maxScale = template.maxScale || 3;

      /**
       * Whether or not the client should listen to keyboard events.
       *
       * @type Boolean
       */
      this.keyboardEnabled = template.keyboardEnabled || true;

      /**
       * Whether translation of touch to mouse events should emulate an
       * absolute pointer device, or a relative pointer device.
       *
       * @type Boolean
       */
      this.emulateAbsoluteMouse =
        template.emulateAbsoluteMouse ||
        preferenceService.preferences.emulateAbsoluteMouse;

      /**
       * The relative Y coordinate of the scroll offset of the display within
       * the client element.
       *
       * @type Number
       */
      this.scrollTop = template.scrollTop || 0;

      /**
       * The relative X coordinate of the scroll offset of the display within
       * the client element.
       *
       * @type Number
       */
      this.scrollLeft = template.scrollLeft || 0;
    };

    return ClientProperties;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the ManagedArgument class used by ManagedClient.
 */
angular.module("client").factory("ManagedArgument", [
  "$q",
  function defineManagedArgument($q) {
    /**
     * Object which represents an argument (connection parameter) which may be
     * changed by the user while the connection is open.
     *
     * @constructor
     * @param {ManagedArgument|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ManagedArgument.
     */
    var ManagedArgument = function ManagedArgument(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The name of the connection parameter.
       *
       * @type {String}
       */
      this.name = template.name;

      /**
       * The current value of the connection parameter.
       *
       * @type {String}
       */
      this.value = template.value;

      /**
       * A valid, open output stream which may be used to apply a new value
       * to the connection parameter.
       *
       * @type {Guacamole.OutputStream}
       */
      this.stream = template.stream;
    };

    /**
     * Requests editable access to a given connection parameter, returning a
     * promise which is resolved with a ManagedArgument instance that provides
     * such access if the parameter is indeed editable.
     *
     * @param {ManagedClient} managedClient
     *     The ManagedClient instance associated with the connection for which
     *     an editable version of the connection parameter is being retrieved.
     *
     * @param {String} name
     *     The name of the connection parameter.
     *
     * @param {String} value
     *     The current value of the connection parameter, as received from a
     *     prior, inbound "argv" stream.
     *
     * @returns {Promise.<ManagedArgument>}
     *     A promise which is resolved with the new ManagedArgument instance
     *     once the requested parameter has been verified as editable.
     */
    ManagedArgument.getInstance = function getInstance(
      managedClient,
      name,
      value
    ) {
      var deferred = $q.defer();

      // Create internal, fully-populated instance of ManagedArgument, to be
      // returned only once mutability of the associated connection parameter
      // has been verified
      var managedArgument = new ManagedArgument({
        name: name,
        value: value,
        stream: managedClient.client.createArgumentValueStream(
          "text/plain",
          name
        ),
      });

      // The connection parameter is editable only if a successful "ack" is
      // received
      managedArgument.stream.onack = function ackReceived(status) {
        if (status.isError()) deferred.reject(status);
        else deferred.resolve(managedArgument);
      };

      return deferred.promise;
    };

    /**
     * Sets the given editable argument (connection parameter) to the given
     * value, updating the behavior of the associated connection in real-time.
     * If successful, the ManagedArgument provided cannot be used for future
     * calls to setValue() and must be replaced with a new instance. This
     * function only has an effect if the new parameter value is different from
     * the current value.
     *
     * @param {ManagedArgument} managedArgument
     *     The ManagedArgument instance associated with the connection
     *     parameter being modified.
     *
     * @param {String} value
     *     The new value to assign to the connection parameter.
     *
     * @returns {Boolean}
     *     true if the connection parameter was sent and the provided
     *     ManagedArgument instance may no longer be used for future setValue()
     *     calls, false if the connection parameter was NOT sent as it has not
     *     changed.
     */
    ManagedArgument.setValue = function setValue(managedArgument, value) {
      // Stream new value only if value has changed
      if (value !== managedArgument.value) {
        var writer = new Guacamole.StringWriter(managedArgument.stream);
        writer.sendText(value);
        writer.sendEnd();

        // ManagedArgument instance is no longer usable
        return true;
      }

      // No parameter value change was attempted and the ManagedArgument
      // instance may be reused
      return false;
    };

    return ManagedArgument;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the ManagedClient class used by the guacClientManager service.
 */
angular.module("client").factory("ManagedClient", [
  "$rootScope",
  "$injector",
  function defineManagedClient($rootScope, $injector) {
    // Required types
    var ClientProperties = $injector.get("ClientProperties");
    var ClientIdentifier = $injector.get("ClientIdentifier");
    var ClipboardData = $injector.get("ClipboardData");
    var ManagedArgument = $injector.get("ManagedArgument");
    var ManagedClientState = $injector.get("ManagedClientState");
    var ManagedClientThumbnail = $injector.get("ManagedClientThumbnail");
    var ManagedDisplay = $injector.get("ManagedDisplay");
    var ManagedFilesystem = $injector.get("ManagedFilesystem");
    var ManagedFileUpload = $injector.get("ManagedFileUpload");
    var ManagedShareLink = $injector.get("ManagedShareLink");

    // Required services
    var $document = $injector.get("$document");
    var $q = $injector.get("$q");
    var $rootScope = $injector.get("$rootScope");
    var $window = $injector.get("$window");
    var activeConnectionService = $injector.get("activeConnectionService");
    var authenticationService = $injector.get("authenticationService");
    var connectionGroupService = $injector.get("connectionGroupService");
    var connectionService = $injector.get("connectionService");
    var preferenceService = $injector.get("preferenceService");
    var requestService = $injector.get("requestService");
    var schemaService = $injector.get("schemaService");
    var tunnelService = $injector.get("tunnelService");
    var guacAudio = $injector.get("guacAudio");
    var guacHistory = $injector.get("guacHistory");
    var guacImage = $injector.get("guacImage");
    var guacVideo = $injector.get("guacVideo");

    /**
     * The minimum amount of time to wait between updates to the client
     * thumbnail, in milliseconds.
     *
     * @type Number
     */
    var THUMBNAIL_UPDATE_FREQUENCY = 5000;

    /**
     * Object which serves as a surrogate interface, encapsulating a Guacamole
     * client while it is active, allowing it to be detached and reattached
     * from different client views.
     *
     * @constructor
     * @param {ManagedClient|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ManagedClient.
     */
    var ManagedClient = function ManagedClient(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The ID of the connection associated with this client.
       *
       * @type String
       */
      this.id = template.id;

      /**
       * The time that the connection was last brought to the foreground of
       * the current tab, as the number of milliseconds elapsed since
       * midnight of January 1, 1970 UTC. If the connection has not yet been
       * viewed, this will be 0.
       *
       * @type Number
       */
      this.lastUsed = template.lastUsed || 0;

      /**
       * The actual underlying Guacamole client.
       *
       * @type Guacamole.Client
       */
      this.client = template.client;

      /**
       * The tunnel being used by the underlying Guacamole client.
       *
       * @type Guacamole.Tunnel
       */
      this.tunnel = template.tunnel;

      /**
       * The display associated with the underlying Guacamole client.
       *
       * @type ManagedDisplay
       */
      this.managedDisplay = template.managedDisplay;

      /**
       * The name returned associated with the connection or connection
       * group in use.
       *
       * @type String
       */
      this.name = template.name;

      /**
       * The title which should be displayed as the page title for this
       * client.
       *
       * @type String
       */
      this.title = template.title;

      /**
       * The name which uniquely identifies the protocol of the connection in
       * use. If the protocol cannot be determined, such as when a connection
       * group is in use, this will be null.
       *
       * @type {String}
       */
      this.protocol = template.protocol || null;

      /**
       * An array of forms describing all known parameters for the connection
       * in use, including those which may not be editable.
       *
       * @type {Form[]}
       */
      this.forms = template.forms || [];

      /**
       * The most recently-generated thumbnail for this connection, as
       * stored within the local connection history. If no thumbnail is
       * stored, this will be null.
       *
       * @type ManagedClientThumbnail
       */
      this.thumbnail = template.thumbnail;

      /**
       * The current clipboard contents.
       *
       * @type ClipboardData
       */
      this.clipboardData =
        template.clipboardData ||
        new ClipboardData({
          type: "text/plain",
          data: "",
        });

      /**
       * The current state of all parameters requested by the server via
       * "required" instructions, where each object key is the name of a
       * requested parameter and each value is the current value entered by
       * the user or null if no parameters are currently being requested.
       *
       * @type Object.<String, String>
       */
      this.requiredParameters = null;

      /**
       * All uploaded files. As files are uploaded, their progress can be
       * observed through the elements of this array. It is intended that
       * this array be manipulated externally as needed.
       *
       * @type ManagedFileUpload[]
       */
      this.uploads = template.uploads || [];

      /**
       * All currently-exposed filesystems. When the Guacamole server exposes
       * a filesystem object, that object will be made available as a
       * ManagedFilesystem within this array.
       *
       * @type ManagedFilesystem[]
       */
      this.filesystems = template.filesystems || [];

      /**
       * All available share links generated for the this ManagedClient via
       * ManagedClient.createShareLink(). Each resulting share link is stored
       * under the identifier of its corresponding SharingProfile.
       *
       * @type Object.<String, ManagedShareLink>
       */
      this.shareLinks = template.shareLinks || {};

      /**
       * The current state of the Guacamole client (idle, connecting,
       * connected, terminated with error, etc.).
       *
       * @type ManagedClientState
       */
      this.clientState = template.clientState || new ManagedClientState();

      /**
       * Properties associated with the display and behavior of the Guacamole
       * client.
       *
       * @type ClientProperties
       */
      this.clientProperties =
        template.clientProperties || new ClientProperties();

      /**
       * All editable arguments (connection parameters), stored by their
       * names. Arguments will only be present within this set if their
       * current values have been exposed by the server via an inbound "argv"
       * stream and the server has confirmed that the value may be changed
       * through a successful "ack" to an outbound "argv" stream.
       *
       * @type {Object.<String, ManagedArgument>}
       */
      this.arguments = template.arguments || {};
    };

    /**
     * The mimetype of audio data to be sent along the Guacamole connection if
     * audio input is supported.
     *
     * @constant
     * @type String
     */
    ManagedClient.AUDIO_INPUT_MIMETYPE = "audio/L16;rate=44100,channels=2";

    /**
     * Returns a promise which resolves with the string of connection
     * parameters to be passed to the Guacamole client during connection. This
     * string generally contains the desired connection ID, display resolution,
     * and supported audio/video/image formats. The returned promise is
     * guaranteed to resolve successfully.
     *
     * @param {ClientIdentifier} identifier
     *     The identifier representing the connection or group to connect to.
     *
     * @param {String} [connectionParameters]
     *     Any additional HTTP parameters to pass while connecting.
     *
     * @returns {Promise.<String>}
     *     A promise which resolves with the string of connection parameters to
     *     be passed to the Guacamole client, once the string is ready.
     */
    var getConnectString = function getConnectString(
      identifier,
      connectionParameters
    ) {
      var deferred = $q.defer();

      // Calculate optimal width/height for display
      var pixel_density = $window.devicePixelRatio || 1;
      var optimal_dpi = pixel_density * 96;
      var optimal_width = $window.innerWidth * pixel_density;
      var optimal_height = $window.innerHeight * pixel_density;

      // Build base connect string
      var connectString =
        //   "token="             + encodeURIComponent(authenticationService.getCurrentToken())
        // + "&GUAC_DATA_SOURCE=" + encodeURIComponent(identifier.dataSource)
        // + "&GUAC_ID="          + encodeURIComponent(identifier.id)
        // + "&GUAC_TYPE="        + encodeURIComponent(identifier.type)
        "GUAC_WIDTH=" +
        Math.floor(optimal_width) +
        "&GUAC_HEIGHT=" +
        Math.floor(optimal_height) +
        "&GUAC_DPI=" +
        Math.floor(optimal_dpi) +
        // + "&GUAC_TIMEZONE="    + encodeURIComponent(preferenceService.preferences.timezone)
        (connectionParameters ? "&" + connectionParameters : "");

      // Add audio mimetypes to connect string
      guacAudio.supported.forEach(function (mimetype) {
        connectString += "&GUAC_AUDIO=" + encodeURIComponent(mimetype);
      });

      // Add video mimetypes to connect string
      guacVideo.supported.forEach(function (mimetype) {
        connectString += "&GUAC_VIDEO=" + encodeURIComponent(mimetype);
      });

      // Add image mimetypes to connect string
      guacImage
        .getSupportedMimetypes()
        .then(function supportedMimetypesKnown(mimetypes) {
          // Add each image mimetype
          angular.forEach(mimetypes, function addImageMimetype(mimetype) {
            connectString += "&GUAC_IMAGE=" + encodeURIComponent(mimetype);
          });

          // Connect string is now ready - nothing else is deferred
          deferred.resolve(connectString);
        });

      return deferred.promise;
    };

    /**
     * Requests the creation of a new audio stream, recorded from the user's
     * local audio input device. If audio input is supported by the connection,
     * an audio stream will be created which will remain open until the remote
     * desktop requests that it be closed. If the audio stream is successfully
     * created but is later closed, a new audio stream will automatically be
     * established to take its place. The mimetype used for all audio streams
     * produced by this function is defined by
     * ManagedClient.AUDIO_INPUT_MIMETYPE.
     *
     * @param {Guacamole.Client} client
     *     The Guacamole.Client for which the audio stream is being requested.
     */
    var requestAudioStream = function requestAudioStream(client) {
      // Create new audio stream, associating it with an AudioRecorder
      var stream = client.createAudioStream(ManagedClient.AUDIO_INPUT_MIMETYPE);
      var recorder = Guacamole.AudioRecorder.getInstance(
        stream,
        ManagedClient.AUDIO_INPUT_MIMETYPE
      );

      // If creation of the AudioRecorder failed, simply end the stream
      if (!recorder) stream.sendEnd();
      // Otherwise, ensure that another audio stream is created after this
      // audio stream is closed
      else recorder.onclose = requestAudioStream.bind(this, client);
    };

    /**
     * Creates a new ManagedClient, connecting it to the specified connection
     * or group.
     *
     * @param {String} id
     *     The ID of the connection or group to connect to. This String must be
     *     a valid ClientIdentifier string, as would be generated by
     *     ClientIdentifier.toString().
     *
     * @param {String} [connectionParameters]
     *     Any additional HTTP parameters to pass while connecting.
     *
     * @returns {ManagedClient}
     *     A new ManagedClient instance which is connected to the connection or
     *     connection group having the given ID.
     */
    ManagedClient.getInstance = function getInstance(id, connectionParameters) {
      var tunnel;
      if (!$window.WebSocket) {
        alert(
          new URLSearchParams(location.search).get("lang") === "zh"
            ? ""
            : "Your browser is too old. Please upgrade your browser and try again."
        );
        throw new Error("browser do not support WebSocket");
      }
      var iaasParams = {};
      if (typeof connectionParameters === "object") {
        iaasParams = connectionParameters.iaasParams || {};
        delete connectionParameters.iaasParams;
        connectionParameters = Object.keys(connectionParameters)
          .map(
            (k) =>
              `${encodeURIComponent(k)}=${encodeURIComponent(
                connectionParameters[k]
              )}`
          )
          .join("&");
      }
      var tunnelURL = iaasParams.ConsoleURL || "websocket-tunnel";
      tunnel = new Guacamole.WebSocketTunnel(tunnelURL);

      // If WebSocket available, try to use it.
      // if ($window.WebSocket)
      //     tunnel = new Guacamole.ChainedTunnel(
      //         new Guacamole.WebSocketTunnel('websocket-tunnel'),
      //         new Guacamole.HTTPTunnel('tunnel')
      //     );

      // // If no WebSocket, then use HTTP.
      // else
      //     tunnel = new Guacamole.HTTPTunnel('tunnel');

      // Get new client instance
      var client = new Guacamole.Client(tunnel);

      // Associate new managed client with new client and tunnel
      var managedClient = new ManagedClient({
        id: id,
        client: client,
        tunnel: tunnel,
      });

      // Fire events for tunnel errors
      tunnel.onerror = function tunnelError(status) {
        $rootScope.$apply(function handleTunnelError() {
          ManagedClientState.setConnectionState(
            managedClient.clientState,
            ManagedClientState.ConnectionState.TUNNEL_ERROR,
            status.code
          );
        });
      };

      // Pull protocol-specific information from tunnel once tunnel UUID is
      // known
      tunnel.onuuid = function tunnelAssignedUUID(uuid) {
        tunnelService
          .getProtocol(uuid)
          .then(function protocolRetrieved(protocol) {
            managedClient.protocol = protocol.name;
            managedClient.forms = protocol.connectionForms;
          }, requestService.WARN);
      };

      // Update connection state as tunnel state changes
      tunnel.onstatechange = function tunnelStateChanged(state) {
        $rootScope.$evalAsync(function updateTunnelState() {
          switch (state) {
            // Connection is being established
            case Guacamole.Tunnel.State.CONNECTING:
              ManagedClientState.setConnectionState(
                managedClient.clientState,
                ManagedClientState.ConnectionState.CONNECTING
              );
              break;

            // Connection is established / no longer unstable
            case Guacamole.Tunnel.State.OPEN:
              ManagedClientState.setTunnelUnstable(
                managedClient.clientState,
                false
              );
              break;

            // Connection is established but misbehaving
            case Guacamole.Tunnel.State.UNSTABLE:
              ManagedClientState.setTunnelUnstable(
                managedClient.clientState,
                true
              );
              break;

            // Connection has closed
            case Guacamole.Tunnel.State.CLOSED:
              ManagedClientState.setConnectionState(
                managedClient.clientState,
                ManagedClientState.ConnectionState.DISCONNECTED
              );
              break;
          }
        });
      };

      // Update connection state as client state changes
      client.onstatechange = function clientStateChanged(clientState) {
        $rootScope.$evalAsync(function updateClientState() {
          switch (clientState) {
            // Idle
            case 0:
              ManagedClientState.setConnectionState(
                managedClient.clientState,
                ManagedClientState.ConnectionState.IDLE
              );
              break;

            // Ignore "connecting" state
            case 1: // Connecting
              break;

            // Connected + waiting
            case 2:
              ManagedClientState.setConnectionState(
                managedClient.clientState,
                ManagedClientState.ConnectionState.WAITING
              );
              break;

            // Connected
            case 3:
              ManagedClientState.setConnectionState(
                managedClient.clientState,
                ManagedClientState.ConnectionState.CONNECTED
              );

              // Send any clipboard data already provided
              if (managedClient.clipboardData)
                ManagedClient.setClipboard(
                  managedClient,
                  managedClient.clipboardData
                );

              // Begin streaming audio input if possible
              requestAudioStream(client);

              // Update thumbnail with initial display contents
              ManagedClient.updateThumbnail(managedClient);
              break;

            // Update history when disconnecting
            case 4: // Disconnecting
            case 5: // Disconnected
              ManagedClient.updateThumbnail(managedClient);
              break;
          }
        });
      };

      // Disconnect and update status when the client receives an error
      client.onerror = function clientError(status) {
        $rootScope.$apply(function handleClientError() {
          // Disconnect, if connected
          client.disconnect();

          // Update state
          ManagedClientState.setConnectionState(
            managedClient.clientState,
            ManagedClientState.ConnectionState.CLIENT_ERROR,
            status.code
          );
        });
        setTimeout(() => {
          $rootScope.$digest();
        }, 200);
      };

      // Automatically update the client thumbnail
      client.onsync = function syncReceived() {
        var thumbnail = managedClient.thumbnail;
        var timestamp = new Date().getTime();

        // Update thumbnail if it doesn't exist or is old
        if (
          !thumbnail ||
          timestamp - thumbnail.timestamp >= THUMBNAIL_UPDATE_FREQUENCY
        ) {
          $rootScope.$apply(function updateClientThumbnail() {
            ManagedClient.updateThumbnail(managedClient);
          });
        }
      };

      // Test for argument mutability whenever an argument value is
      // received
      client.onargv = function clientArgumentValueReceived(
        stream,
        mimetype,
        name
      ) {
        // Ignore arguments which do not use a mimetype currently supported
        // by the web application
        if (mimetype !== "text/plain") return;

        var reader = new Guacamole.StringReader(stream);

        // Assemble received data into a single string
        var value = "";
        reader.ontext = function textReceived(text) {
          value += text;
        };

        // Test mutability once stream is finished, storing the current
        // value for the argument only if it is mutable
        reader.onend = function textComplete() {
          ManagedArgument.getInstance(managedClient, name, value).then(
            function argumentIsMutable(argument) {
              managedClient.arguments[name] = argument;
            },
            function ignoreImmutableArguments() {}
          );
        };
      };

      // Handle any received clipboard data
      client.onclipboard = function clientClipboardReceived(stream, mimetype) {
        var reader;

        // If the received data is text, read it as a simple string
        if (/^text\//.exec(mimetype)) {
          reader = new Guacamole.StringReader(stream);

          // Assemble received data into a single string
          var data = "";
          reader.ontext = function textReceived(text) {
            data += text;
          };

          // Set clipboard contents once stream is finished
          reader.onend = function textComplete() {
            $rootScope.$apply(function updateClipboard() {
              managedClient.clipboardData = new ClipboardData({
                type: mimetype,
                data: data,
              });
            });
          };
        }

        // Otherwise read the clipboard data as a Blob
        else {
          reader = new Guacamole.BlobReader(stream, mimetype);
          reader.onend = function blobComplete() {
            $rootScope.$apply(function updateClipboard() {
              managedClient.clipboardData = new ClipboardData({
                type: mimetype,
                data: reader.getBlob(),
              });
            });
          };
        }
      };

      // Update title when a "name" instruction is received
      client.onname = function clientNameReceived(name) {
        $rootScope.$apply(function updateClientTitle() {
          managedClient.title = name;
        });
      };

      // Handle any received files
      client.onfile = function clientFileReceived(stream, mimetype, filename) {
        tunnelService.downloadStream(tunnel.uuid, stream, mimetype, filename);
      };

      // Handle any received filesystem objects
      client.onfilesystem = function fileSystemReceived(object, name) {
        $rootScope.$apply(function exposeFilesystem() {
          managedClient.filesystems.push(
            ManagedFilesystem.getInstance(object, name)
          );
        });
      };

      // Handle any received prompts
      client.onrequired = function onrequired(parameters) {
        $rootScope.$apply(function promptUser() {
          managedClient.requiredParameters = {};
          angular.forEach(parameters, function populateParameter(name) {
            managedClient.requiredParameters[name] = "";
          });
        });
      };
      // Manage the client display
      managedClient.managedDisplay = ManagedDisplay.getInstance(
        client.getDisplay()
      );

      // Parse connection details from ID
      var clientIdentifier = ClientIdentifier.fromString(id);

      // Connect the Guacamole client
      getConnectString(clientIdentifier, connectionParameters).then(
        function connectClient(connectString) {
          client.connect("", (socket) => {
            iaasParams.onSocketOpen && iaasParams.onSocketOpen(socket);
          });
        }
      );

      // If using a connection, pull connection name and protocol information
      if (clientIdentifier.type === ClientIdentifier.Types.CONNECTION) {
        connectionService
          .getConnection(clientIdentifier.dataSource, clientIdentifier.id)
          .then(function connectionRetrieved(connection) {
            managedClient.name = managedClient.title = connection.name;
          }, requestService.WARN);
      }

      // If using a connection group, pull connection name
      else if (
        clientIdentifier.type === ClientIdentifier.Types.CONNECTION_GROUP
      ) {
        connectionGroupService
          .getConnectionGroup(clientIdentifier.dataSource, clientIdentifier.id)
          .then(function connectionGroupRetrieved(group) {
            managedClient.name = managedClient.title = group.name;
          }, requestService.WARN);
      }

      // If using an active connection, pull corresponding connection, then
      // pull connection name and protocol information from that
      else if (
        clientIdentifier.type === ClientIdentifier.Types.ACTIVE_CONNECTION
      ) {
        activeConnectionService
          .getActiveConnection(clientIdentifier.dataSource, clientIdentifier.id)
          .then(function activeConnectionRetrieved(activeConnection) {
            // Attempt to retrieve connection details only if the
            // underlying connection is known
            if (activeConnection.connectionIdentifier) {
              connectionService
                .getConnection(
                  clientIdentifier.dataSource,
                  activeConnection.connectionIdentifier
                )
                .then(function connectionRetrieved(connection) {
                  managedClient.name = managedClient.title = connection.name;
                }, requestService.WARN);
            }
          }, requestService.WARN);
      }

      return managedClient;
    };

    /**
     * Uploads the given file to the server through the given Guacamole client.
     * The file transfer can be monitored through the corresponding entry in
     * the uploads array of the given managedClient.
     *
     * @param {ManagedClient} managedClient
     *     The ManagedClient through which the file is to be uploaded.
     *
     * @param {File} file
     *     The file to upload.
     *
     * @param {ManagedFilesystem} [filesystem]
     *     The filesystem to upload the file to, if any. If not specified, the
     *     file will be sent as a generic Guacamole file stream.
     *
     * @param {ManagedFilesystem.File} [directory=filesystem.currentDirectory]
     *     The directory within the given filesystem to upload the file to. If
     *     not specified, but a filesystem is given, the current directory of
     *     that filesystem will be used.
     */
    ManagedClient.uploadFile = function uploadFile(
      managedClient,
      file,
      filesystem,
      directory
    ) {
      // Use generic Guacamole file streams by default
      var object = null;
      var streamName = null;

      // If a filesystem is given, determine the destination object and stream
      if (filesystem) {
        object = filesystem.object;
        streamName =
          (directory || filesystem.currentDirectory).streamName +
          "/" +
          file.name;
      }

      // Start and manage file upload
      managedClient.uploads.push(
        ManagedFileUpload.getInstance(managedClient, file, object, streamName)
      );
    };

    /**
     * Sends the given clipboard data over the given Guacamole client, setting
     * the contents of the remote clipboard to the data provided.
     *
     * @param {ManagedClient} managedClient
     *     The ManagedClient over which the given clipboard data is to be sent.
     *
     * @param {ClipboardData} data
     *     The clipboard data to send.
     */
    ManagedClient.setClipboard = function setClipboard(managedClient, data) {
      var writer;

      // Create stream with proper mimetype
      var stream = managedClient.client.createClipboardStream(data.type);

      // Send data as a string if it is stored as a string
      if (typeof data.data === "string") {
        writer = new Guacamole.StringWriter(stream);
        writer.sendText(data.data);
        writer.sendEnd();
      }

      // Otherwise, assume the data is a File/Blob
      else {
        // Write File/Blob asynchronously
        writer = new Guacamole.BlobWriter(stream);
        writer.oncomplete = function clipboardSent() {
          writer.sendEnd();
        };

        // Begin sending data
        writer.sendBlob(data.data);
      }
    };

    /**
     * Assigns the given value to the connection parameter having the given
     * name, updating the behavior of the connection in real-time. If the
     * connection parameter is not editable, this function has no effect.
     *
     * @param {ManagedClient} managedClient
     *     The ManagedClient instance associated with the active connection
     *     being modified.
     *
     * @param {String} name
     *     The name of the connection parameter to modify.
     *
     * @param {String} value
     *     The value to attempt to assign to the given connection parameter.
     */
    ManagedClient.setArgument = function setArgument(
      managedClient,
      name,
      value
    ) {
      var managedArgument = managedClient.arguments[name];
      if (managedArgument && ManagedArgument.setValue(managedArgument, value))
        delete managedClient.arguments[name];
    };

    /**
     * Sends the given connection parameter values using "argv" streams,
     * updating the behavior of the connection in real-time if the server is
     * expecting or requiring these parameters.
     *
     * @param {ManagedClient} managedClient
     *     The ManagedClient instance associated with the active connection
     *     being modified.
     *
     * @param {Object.<String, String>} values
     *     The set of values to attempt to assign to corresponding connection
     *     parameters, where each object key is the connection parameter being
     *     set.
     */
    ManagedClient.sendArguments = function sendArguments(
      managedClient,
      values
    ) {
      angular.forEach(values, function sendArgument(value, name) {
        var stream = managedClient.client.createArgumentValueStream(
          "text/plain",
          name
        );
        var writer = new Guacamole.StringWriter(stream);
        writer.sendText(value);
        writer.sendEnd();
      });
    };

    /**
     * Retrieves the current values of all editable connection parameters as a
     * set of name/value pairs suitable for use as the model of a form which
     * edits those parameters.
     *
     * @param {ManagedClient} client
     *     The ManagedClient instance associated with the active connection
     *     whose parameter values are being retrieved.
     *
     * @returns {Object.<String, String>}
     *     A new set of name/value pairs containing the current values of all
     *     editable parameters.
     */
    ManagedClient.getArgumentModel = function getArgumentModel(client) {
      var model = {};

      angular.forEach(
        client.arguments,
        function addModelEntry(managedArgument) {
          model[managedArgument.name] = managedArgument.value;
        }
      );

      return model;
    };

    /**
     * Produces a sharing link for the given ManagedClient using the given
     * sharing profile. The resulting sharing link, and any required login
     * information, can be retrieved from the <code>shareLinks</code> property
     * of the given ManagedClient once the various underlying service calls
     * succeed.
     *
     * @param {ManagedClient} client
     *     The ManagedClient which will be shared via the generated sharing
     *     link.
     *
     * @param {SharingProfile} sharingProfile
     *     The sharing profile to use to generate the sharing link.
     *
     * @returns {Promise}
     *     A Promise which is resolved once the sharing link has been
     *     successfully generated, and rejected if generating the link fails.
     */
    ManagedClient.createShareLink = function createShareLink(
      client,
      sharingProfile
    ) {
      // Retrieve sharing credentials for the sake of generating a share link
      var credentialRequest = tunnelService.getSharingCredentials(
        client.tunnel.uuid,
        sharingProfile.identifier
      );

      // Add a new share link once the credentials are ready
      credentialRequest.then(function sharingCredentialsReceived(
        sharingCredentials
      ) {
        client.shareLinks[sharingProfile.identifier] =
          ManagedShareLink.getInstance(sharingProfile, sharingCredentials);
      },
      requestService.WARN);

      return credentialRequest;
    };

    /**
     * Returns whether the given ManagedClient is being shared. A ManagedClient
     * is shared if it has any associated share links.
     *
     * @param {ManagedClient} client
     *     The ManagedClient to check.
     *
     * @returns {Boolean}
     *     true if the ManagedClient has at least one associated share link,
     *     false otherwise.
     */
    ManagedClient.isShared = function isShared(client) {
      // The connection is shared if at least one share link exists
      for (var dummy in client.shareLinks) return true;

      // No share links currently exist
      return false;
    };

    /**
     * Store the thumbnail of the given managed client within the connection
     * history under its associated ID. If the client is not connected, this
     * function has no effect.
     *
     * @param {ManagedClient} managedClient
     *     The client whose history entry should be updated.
     */
    ManagedClient.updateThumbnail = function updateThumbnail(managedClient) {
      var display = managedClient.client.getDisplay();

      // Update stored thumbnail of previous connection
      if (display && display.getWidth() > 0 && display.getHeight() > 0) {
        // Get screenshot
        var canvas = display.flatten();

        // Calculate scale of thumbnail (max 320x240, max zoom 100%)
        var scale = Math.min(320 / canvas.width, 240 / canvas.height, 1);

        // Create thumbnail canvas
        var thumbnail = $document[0].createElement("canvas");
        thumbnail.width = canvas.width * scale;
        thumbnail.height = canvas.height * scale;

        // Scale screenshot to thumbnail
        var context = thumbnail.getContext("2d");
        context.drawImage(
          canvas,
          0,
          0,
          canvas.width,
          canvas.height,
          0,
          0,
          thumbnail.width,
          thumbnail.height
        );

        // Store updated thumbnail within client
        managedClient.thumbnail = new ManagedClientThumbnail({
          timestamp: new Date().getTime(),
          canvas: thumbnail,
        });

        // Update historical thumbnail
        guacHistory.updateThumbnail(
          managedClient.id,
          thumbnail.toDataURL("image/png")
        );
      }
    };

    return ManagedClient;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the ManagedClient class used by the guacClientManager service.
 */
angular.module("client").factory("ManagedClientState", [
  function defineManagedClientState() {
    /**
     * Object which represents the state of a Guacamole client and its tunnel,
     * including any error conditions.
     *
     * @constructor
     * @param {ManagedClientState|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ManagedClientState.
     */
    var ManagedClientState = function ManagedClientState(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The current connection state. Valid values are described by
       * ManagedClientState.ConnectionState.
       *
       * @type String
       * @default ManagedClientState.ConnectionState.IDLE
       */
      this.connectionState =
        template.connectionState || ManagedClientState.ConnectionState.IDLE;

      /**
       * Whether the network connection used by the tunnel seems unstable. If
       * the network connection is unstable, the remote desktop connection
       * may perform poorly or disconnect.
       *
       * @type Boolean
       * @default false
       */
      this.tunnelUnstable = template.tunnelUnstable || false;

      /**
       * The status code of the current error condition, if connectionState
       * is CLIENT_ERROR or TUNNEL_ERROR. For all other connectionState
       * values, this will be @link{Guacamole.Status.Code.SUCCESS}.
       *
       * @type Number
       * @default Guacamole.Status.Code.SUCCESS
       */
      this.statusCode = template.statusCode || Guacamole.Status.Code.SUCCESS;
    };

    /**
     * Valid connection state strings. Each state string is associated with a
     * specific state of a Guacamole connection.
     */
    ManagedClientState.ConnectionState = {
      /**
       * The Guacamole connection has not yet been attempted.
       *
       * @type String
       */
      IDLE: "IDLE",

      /**
       * The Guacamole connection is being established.
       *
       * @type String
       */
      CONNECTING: "CONNECTING",

      /**
       * The Guacamole connection has been successfully established, and the
       * client is now waiting for receipt of initial graphical data.
       *
       * @type String
       */
      WAITING: "WAITING",

      /**
       * The Guacamole connection has been successfully established, and
       * initial graphical data has been received.
       *
       * @type String
       */
      CONNECTED: "CONNECTED",

      /**
       * The Guacamole connection has terminated successfully. No errors are
       * indicated.
       *
       * @type String
       */
      DISCONNECTED: "DISCONNECTED",

      /**
       * The Guacamole connection has terminated due to an error reported by
       * the client. The associated error code is stored in statusCode.
       *
       * @type String
       */
      CLIENT_ERROR: "CLIENT_ERROR",

      /**
       * The Guacamole connection has terminated due to an error reported by
       * the tunnel. The associated error code is stored in statusCode.
       *
       * @type String
       */
      TUNNEL_ERROR: "TUNNEL_ERROR",
    };

    /**
     * Sets the current client state and, if given, the associated status code.
     * If an error is already represented, this function has no effect. If the
     * client state was previously marked as unstable, that flag is implicitly
     * cleared.
     *
     * @param {ManagedClientState} clientState
     *     The ManagedClientState to update.
     *
     * @param {String} connectionState
     *     The connection state to assign to the given ManagedClientState, as
     *     listed within ManagedClientState.ConnectionState.
     *
     * @param {Number} [statusCode]
     *     The status code to assign to the given ManagedClientState, if any,
     *     as listed within Guacamole.Status.Code. If no status code is
     *     specified, the status code of the ManagedClientState is not touched.
     */
    ManagedClientState.setConnectionState = function (
      clientState,
      connectionState,
      statusCode
    ) {
      // Do not set state after an error is registered
      if (
        clientState.connectionState ===
          ManagedClientState.ConnectionState.TUNNEL_ERROR ||
        clientState.connectionState ===
          ManagedClientState.ConnectionState.CLIENT_ERROR
      )
        return;

      // Update connection state
      clientState.connectionState = connectionState;
      clientState.tunnelUnstable = false;

      // Set status code, if given
      if (statusCode) clientState.statusCode = statusCode;
    };

    /**
     * Updates the given client state, setting whether the underlying tunnel
     * is currently unstable. An unstable tunnel is not necessarily
     * disconnected, but appears to be misbehaving and may be disconnected.
     *
     * @param {ManagedClientState} clientState
     *     The ManagedClientState to update.
     *
     * @param {Boolean} unstable
     *     Whether the underlying tunnel of the connection currently appears
     *     unstable.
     */
    ManagedClientState.setTunnelUnstable = function setTunnelUnstable(
      clientState,
      unstable
    ) {
      clientState.tunnelUnstable = unstable;
    };

    return ManagedClientState;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the ManagedClientThumbnail class used by ManagedClient.
 */
angular.module("client").factory("ManagedClientThumbnail", [
  function defineManagedClientThumbnail() {
    /**
     * Object which represents a thumbnail of the Guacamole client display,
     * along with the time that the thumbnail was generated.
     *
     * @constructor
     * @param {ManagedClientThumbnail|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ManagedClientThumbnail.
     */
    var ManagedClientThumbnail = function ManagedClientThumbnail(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The time that this thumbnail was generated, as the number of
       * milliseconds elapsed since midnight of January 1, 1970 UTC.
       *
       * @type Number
       */
      this.timestamp = template.timestamp;

      /**
       * The thumbnail of the Guacamole client display.
       *
       * @type HTMLCanvasElement
       */
      this.canvas = template.canvas;
    };

    return ManagedClientThumbnail;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the ManagedDisplay class used by the guacClientManager service.
 */
angular.module("client").factory("ManagedDisplay", [
  "$rootScope",
  function defineManagedDisplay($rootScope) {
    /**
     * Object which serves as a surrogate interface, encapsulating a Guacamole
     * display while it is active, allowing it to be detached and reattached
     * from different client views.
     *
     * @constructor
     * @param {ManagedDisplay|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ManagedDisplay.
     */
    var ManagedDisplay = function ManagedDisplay(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The underlying Guacamole display.
       *
       * @type Guacamole.Display
       */
      this.display = template.display;

      /**
       * The current size of the Guacamole display.
       *
       * @type ManagedDisplay.Dimensions
       */
      this.size = new ManagedDisplay.Dimensions(template.size);

      /**
       * The current mouse cursor, if any.
       *
       * @type ManagedDisplay.Cursor
       */
      this.cursor = template.cursor;
    };

    /**
     * Object which represents the size of the Guacamole display.
     *
     * @constructor
     * @param {ManagedDisplay.Dimensions|Object} template
     *     The object whose properties should be copied within the new
     *     ManagedDisplay.Dimensions.
     */
    ManagedDisplay.Dimensions = function Dimensions(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The current width of the Guacamole display, in pixels.
       *
       * @type Number
       */
      this.width = template.width || 0;

      /**
       * The current width of the Guacamole display, in pixels.
       *
       * @type Number
       */
      this.height = template.height || 0;
    };

    /**
     * Object which represents a mouse cursor used by the Guacamole display.
     *
     * @constructor
     * @param {ManagedDisplay.Cursor|Object} template
     *     The object whose properties should be copied within the new
     *     ManagedDisplay.Cursor.
     */
    ManagedDisplay.Cursor = function Cursor(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The actual mouse cursor image.
       *
       * @type HTMLCanvasElement
       */
      this.canvas = template.canvas;

      /**
       * The X coordinate of the cursor hotspot.
       *
       * @type Number
       */
      this.x = template.x;

      /**
       * The Y coordinate of the cursor hotspot.
       *
       * @type Number
       */
      this.y = template.y;
    };

    /**
     * Creates a new ManagedDisplay which represents the current state of the
     * given Guacamole display.
     *
     * @param {Guacamole.Display} display
     *     The Guacamole display to represent. Changes to this display will
     *     affect this ManagedDisplay.
     *
     * @returns {ManagedDisplay}
     *     A new ManagedDisplay which represents the current state of the
     *     given Guacamole display.
     */
    ManagedDisplay.getInstance = function getInstance(display) {
      var managedDisplay = new ManagedDisplay({
        display: display,
      });

      // Store changes to display size
      display.onresize = function setClientSize() {
        $rootScope.$apply(function updateClientSize() {
          managedDisplay.size = new ManagedDisplay.Dimensions({
            width: display.getWidth(),
            height: display.getHeight(),
          });
        });
      };

      // Store changes to display cursor
      display.oncursor = function setClientCursor(canvas, x, y) {
        $rootScope.$apply(function updateClientCursor() {
          managedDisplay.cursor = new ManagedDisplay.Cursor({
            canvas: canvas,
            x: x,
            y: y,
          });
        });
      };

      return managedDisplay;
    };

    return ManagedDisplay;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the ManagedFileTransferState class used by the guacClientManager
 * service.
 */
angular.module("client").factory("ManagedFileTransferState", [
  function defineManagedFileTransferState() {
    /**
     * Object which represents the state of a Guacamole stream, including any
     * error conditions.
     *
     * @constructor
     * @param {ManagedFileTransferState|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ManagedFileTransferState.
     */
    var ManagedFileTransferState = function ManagedFileTransferState(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The current stream state. Valid values are described by
       * ManagedFileTransferState.StreamState.
       *
       * @type String
       * @default ManagedFileTransferState.StreamState.IDLE
       */
      this.streamState =
        template.streamState || ManagedFileTransferState.StreamState.IDLE;

      /**
       * The status code of the current error condition, if streamState
       * is ERROR. For all other streamState values, this will be
       * @link{Guacamole.Status.Code.SUCCESS}.
       *
       * @type Number
       * @default Guacamole.Status.Code.SUCCESS
       */
      this.statusCode = template.statusCode || Guacamole.Status.Code.SUCCESS;
    };

    /**
     * Valid stream state strings. Each state string is associated with a
     * specific state of a Guacamole stream.
     */
    ManagedFileTransferState.StreamState = {
      /**
       * The stream has not yet been opened.
       *
       * @type String
       */
      IDLE: "IDLE",

      /**
       * The stream has been successfully established. Data can be sent or
       * received.
       *
       * @type String
       */
      OPEN: "OPEN",

      /**
       * The stream has terminated successfully. No errors are indicated.
       *
       * @type String
       */
      CLOSED: "CLOSED",

      /**
       * The stream has terminated due to an error. The associated error code
       * is stored in statusCode.
       *
       * @type String
       */
      ERROR: "ERROR",
    };

    /**
     * Sets the current transfer state and, if given, the associated status
     * code. If an error is already represented, this function has no effect.
     *
     * @param {ManagedFileTransferState} transferState
     *     The ManagedFileTransferState to update.
     *
     * @param {String} streamState
     *     The stream state to assign to the given ManagedFileTransferState, as
     *     listed within ManagedFileTransferState.StreamState.
     *
     * @param {Number} [statusCode]
     *     The status code to assign to the given ManagedFileTransferState, if
     *     any, as listed within Guacamole.Status.Code. If no status code is
     *     specified, the status code of the ManagedFileTransferState is not
     *     touched.
     */
    ManagedFileTransferState.setStreamState = function setStreamState(
      transferState,
      streamState,
      statusCode
    ) {
      // Do not set state after an error is registered
      if (
        transferState.streamState === ManagedFileTransferState.StreamState.ERROR
      )
        return;

      // Update stream state
      transferState.streamState = streamState;

      // Set status code, if given
      if (statusCode) transferState.statusCode = statusCode;
    };

    return ManagedFileTransferState;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the ManagedFileUpload class used by the guacClientManager service.
 */
angular.module("client").factory("ManagedFileUpload", [
  "$rootScope",
  "$injector",
  function defineManagedFileUpload($rootScope, $injector) {
    // Required types
    var Error = $injector.get("Error");
    var ManagedFileTransferState = $injector.get("ManagedFileTransferState");

    // Required services
    var requestService = $injector.get("requestService");
    var tunnelService = $injector.get("tunnelService");

    /**
     * Object which serves as a surrogate interface, encapsulating a Guacamole
     * file upload while it is active, allowing it to be detached and
     * reattached from different client views.
     *
     * @constructor
     * @param {ManagedFileUpload|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ManagedFileUpload.
     */
    var ManagedFileUpload = function ManagedFileUpload(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The current state of the file transfer stream.
       *
       * @type ManagedFileTransferState
       */
      this.transferState =
        template.transferState || new ManagedFileTransferState();

      /**
       * The mimetype of the file being transferred.
       *
       * @type String
       */
      this.mimetype = template.mimetype;

      /**
       * The filename of the file being transferred.
       *
       * @type String
       */
      this.filename = template.filename;

      /**
       * The number of bytes transferred so far.
       *
       * @type Number
       */
      this.progress = template.progress;

      /**
       * The total number of bytes in the file.
       *
       * @type Number
       */
      this.length = template.length;
    };

    /**
     * Creates a new ManagedFileUpload which uploads the given file to the
     * server through the given Guacamole client.
     *
     * @param {ManagedClient} managedClient
     *     The ManagedClient through which the file is to be uploaded.
     *
     * @param {File} file
     *     The file to upload.
     *
     * @param {Object} [object]
     *     The object to upload the file to, if any, such as a filesystem
     *     object.
     *
     * @param {String} [streamName]
     *     The name of the stream to upload the file to. If an object is given,
     *     this must be specified.
     *
     * @return {ManagedFileUpload}
     *     A new ManagedFileUpload object which can be used to track the
     *     progress of the upload.
     */
    ManagedFileUpload.getInstance = function getInstance(
      managedClient,
      file,
      object,
      streamName
    ) {
      var managedFileUpload = new ManagedFileUpload();

      // Pull Guacamole.Tunnel and Guacamole.Client from given ManagedClient
      var client = managedClient.client;
      var tunnel = managedClient.tunnel;

      // Open file for writing
      var stream;
      if (!object) stream = client.createFileStream(file.type, file.name);
      // If object/streamName specified, upload to that instead of a file
      // stream
      else stream = object.createOutputStream(file.type, streamName);

      // Notify that the file transfer is pending
      $rootScope.$evalAsync(function uploadStreamOpen() {
        // Init managed upload
        managedFileUpload.filename = file.name;
        managedFileUpload.mimetype = file.type;
        managedFileUpload.progress = 0;
        managedFileUpload.length = file.size;

        // Notify that stream is open
        ManagedFileTransferState.setStreamState(
          managedFileUpload.transferState,
          ManagedFileTransferState.StreamState.OPEN
        );
      });

      // Upload file once stream is acknowledged
      stream.onack = function beginUpload(status) {
        // Notify of any errors from the Guacamole server
        if (status.isError()) {
          $rootScope.$apply(function uploadStreamError() {
            ManagedFileTransferState.setStreamState(
              managedFileUpload.transferState,
              ManagedFileTransferState.StreamState.ERROR,
              status.code
            );
          });
          return;
        }

        // Begin upload
        tunnelService
          .uploadToStream(
            tunnel.uuid,
            stream,
            file,
            function uploadContinuing(length) {
              $rootScope.$apply(function uploadStreamProgress() {
                managedFileUpload.progress = length;
              });
            }
          )

          // Notify if upload succeeds
          .then(
            function uploadSuccessful() {
              // Upload complete
              managedFileUpload.progress = file.size;
              ManagedFileTransferState.setStreamState(
                managedFileUpload.transferState,
                ManagedFileTransferState.StreamState.CLOSED
              );

              // Notify of upload completion
              $rootScope.$broadcast("guacUploadComplete", file.name);
            },

            // Notify if upload fails
            requestService.createErrorCallback(function uploadFailed(error) {
              // Use provide status code if the error is coming from the stream
              if (error.type === Error.Type.STREAM_ERROR)
                ManagedFileTransferState.setStreamState(
                  managedFileUpload.transferState,
                  ManagedFileTransferState.StreamState.ERROR,
                  error.statusCode
                );
              // Fail with internal error for all other causes
              else
                ManagedFileTransferState.setStreamState(
                  managedFileUpload.transferState,
                  ManagedFileTransferState.StreamState.ERROR,
                  Guacamole.Status.Code.INTERNAL_ERROR
                );
            })
          );

        // Ignore all further acks
        stream.onack = null;
      };

      return managedFileUpload;
    };

    return ManagedFileUpload;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the ManagedFilesystem class used by ManagedClient to represent
 * available remote filesystems.
 */
angular.module("client").factory("ManagedFilesystem", [
  "$rootScope",
  "$injector",
  function defineManagedFilesystem($rootScope, $injector) {
    // Required types
    var tunnelService = $injector.get("tunnelService");

    /**
     * Object which serves as a surrogate interface, encapsulating a Guacamole
     * filesystem object while it is active, allowing it to be detached and
     * reattached from different client views.
     *
     * @constructor
     * @param {ManagedFilesystem|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ManagedFilesystem.
     */
    var ManagedFilesystem = function ManagedFilesystem(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The Guacamole filesystem object, as received via a "filesystem"
       * instruction.
       *
       * @type Guacamole.Object
       */
      this.object = template.object;

      /**
       * The declared, human-readable name of the filesystem
       *
       * @type String
       */
      this.name = template.name;

      /**
       * The root directory of the filesystem.
       *
       * @type ManagedFilesystem.File
       */
      this.root = template.root;

      /**
       * The current directory being viewed or manipulated within the
       * filesystem.
       *
       * @type ManagedFilesystem.File
       */
      this.currentDirectory = template.currentDirectory || template.root;
    };

    /**
     * Refreshes the contents of the given file, if that file is a directory.
     * Only the immediate children of the file are refreshed. Files further
     * down the directory tree are not refreshed.
     *
     * @param {ManagedFilesystem} filesystem
     *     The filesystem associated with the file being refreshed.
     *
     * @param {ManagedFilesystem.File} file
     *     The file being refreshed.
     */
    ManagedFilesystem.refresh = function updateDirectory(filesystem, file) {
      // Do not attempt to refresh the contents of directories
      if (file.mimetype !== Guacamole.Object.STREAM_INDEX_MIMETYPE) return;

      // Request contents of given file
      filesystem.object.requestInputStream(
        file.streamName,
        function handleStream(stream, mimetype) {
          // Ignore stream if mimetype is wrong
          if (mimetype !== Guacamole.Object.STREAM_INDEX_MIMETYPE) {
            stream.sendAck(
              "Unexpected mimetype",
              Guacamole.Status.Code.UNSUPPORTED
            );
            return;
          }

          // Signal server that data is ready to be received
          stream.sendAck("Ready", Guacamole.Status.Code.SUCCESS);

          // Read stream as JSON
          var reader = new Guacamole.JSONReader(stream);

          // Acknowledge received JSON blobs
          reader.onprogress = function onprogress() {
            stream.sendAck("Received", Guacamole.Status.Code.SUCCESS);
          };

          // Reset contents of directory
          reader.onend = function jsonReady() {
            $rootScope.$evalAsync(function updateFileContents() {
              // Empty contents
              file.files = {};

              // Determine the expected filename prefix of each stream
              var expectedPrefix = file.streamName;
              if (expectedPrefix.charAt(expectedPrefix.length - 1) !== "/")
                expectedPrefix += "/";

              // For each received stream name
              var mimetypes = reader.getJSON();
              for (var name in mimetypes) {
                // Assert prefix is correct
                if (name.substring(0, expectedPrefix.length) !== expectedPrefix)
                  continue;

                // Extract filename from stream name
                var filename = name.substring(expectedPrefix.length);

                // Deduce type from mimetype
                var type = ManagedFilesystem.File.Type.NORMAL;
                if (mimetypes[name] === Guacamole.Object.STREAM_INDEX_MIMETYPE)
                  type = ManagedFilesystem.File.Type.DIRECTORY;

                // Add file entry
                file.files[filename] = new ManagedFilesystem.File({
                  mimetype: mimetypes[name],
                  streamName: name,
                  type: type,
                  parent: file,
                  name: filename,
                });
              }
            });
          };
        }
      );
    };

    /**
     * Creates a new ManagedFilesystem instance from the given Guacamole.Object
     * and human-readable name. Upon creation, a request to populate the
     * contents of the root directory will be automatically dispatched.
     *
     * @param {Guacamole.Object} object
     *     The Guacamole.Object defining the filesystem.
     *
     * @param {String} name
     *     A human-readable name for the filesystem.
     *
     * @returns {ManagedFilesystem}
     *     The newly-created ManagedFilesystem.
     */
    ManagedFilesystem.getInstance = function getInstance(object, name) {
      // Init new filesystem object
      var managedFilesystem = new ManagedFilesystem({
        object: object,
        name: name,
        root: new ManagedFilesystem.File({
          mimetype: Guacamole.Object.STREAM_INDEX_MIMETYPE,
          streamName: Guacamole.Object.ROOT_STREAM,
          type: ManagedFilesystem.File.Type.DIRECTORY,
        }),
      });

      // Retrieve contents of root
      ManagedFilesystem.refresh(managedFilesystem, managedFilesystem.root);

      return managedFilesystem;
    };

    /**
     * Downloads the given file from the server using the given Guacamole
     * client and filesystem. The browser will automatically start the
     * download upon completion of this function.
     *
     * @param {ManagedClient} managedClient
     *     The ManagedClient from which the file is to be downloaded.
     *
     * @param {ManagedFilesystem} managedFilesystem
     *     The ManagedFilesystem from which the file is to be downloaded. Any
     *     path information provided must be relative to this filesystem.
     *
     * @param {String} path
     *     The full, absolute path of the file to download.
     */
    ManagedFilesystem.downloadFile = function downloadFile(
      managedClient,
      managedFilesystem,
      path
    ) {
      // Request download
      managedFilesystem.object.requestInputStream(
        path,
        function downloadStreamReceived(stream, mimetype) {
          // Parse filename from string
          var filename = path.match(/(.*[\\/])?(.*)/)[2];

          // Start download
          tunnelService.downloadStream(
            managedClient.tunnel.uuid,
            stream,
            mimetype,
            filename
          );
        }
      );
    };

    /**
     * Changes the current directory of the given filesystem, automatically
     * refreshing the contents of that directory.
     *
     * @param {ManagedFilesystem} filesystem
     *     The filesystem whose current directory should be changed.
     *
     * @param {ManagedFilesystem.File} file
     *     The directory to change to.
     */
    ManagedFilesystem.changeDirectory = function changeDirectory(
      filesystem,
      file
    ) {
      // Refresh contents
      ManagedFilesystem.refresh(filesystem, file);

      // Set current directory
      filesystem.currentDirectory = file;
    };

    /**
     * A file within a ManagedFilesystem. Each ManagedFilesystem.File provides
     * sufficient information for retrieval or replacement of the file's
     * contents, as well as the file's name and type.
     *
     * @param {ManagedFilesystem|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ManagedFilesystem.File.
     */
    ManagedFilesystem.File = function File(template) {
      /**
       * The mimetype of the data contained within this file.
       *
       * @type String
       */
      this.mimetype = template.mimetype;

      /**
       * The name of the stream representing this files contents within its
       * associated filesystem object.
       *
       * @type String
       */
      this.streamName = template.streamName;

      /**
       * The type of this file. All legal file type strings are defined
       * within ManagedFilesystem.File.Type.
       *
       * @type String
       */
      this.type = template.type;

      /**
       * The name of this file.
       *
       * @type String
       */
      this.name = template.name;

      /**
       * The parent directory of this file. In the case of the root
       * directory, this will be null.
       *
       * @type ManagedFilesystem.File
       */
      this.parent = template.parent;

      /**
       * Map of all known files containined within this file by name. This is
       * only applicable to directories.
       *
       * @type Object.<String, ManagedFilesystem.File>
       */
      this.files = template.files || {};
    };

    /**
     * All legal type strings for a ManagedFilesystem.File.
     *
     * @type Object.<String, String>
     */
    ManagedFilesystem.File.Type = {
      /**
       * A normal file. As ManagedFilesystem does not currently represent any
       * other non-directory types of files, like symbolic links, this type
       * string may be used for any non-directory file.
       *
       * @type String
       */
      NORMAL: "NORMAL",

      /**
       * A directory.
       *
       * @type String
       */
      DIRECTORY: "DIRECTORY",
    };

    return ManagedFilesystem;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the ManagedShareLink class used by ManagedClient to represent
 * generated connection sharing links.
 */
angular.module("client").factory("ManagedShareLink", [
  "$injector",
  function defineManagedShareLink($injector) {
    // Required types
    var UserCredentials = $injector.get("UserCredentials");

    /**
     * Object which represents a link which can be used to gain access to an
     * active Guacamole connection.
     *
     * @constructor
     * @param {ManagedShareLink|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ManagedShareLink.
     */
    var ManagedShareLink = function ManagedShareLink(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The human-readable display name of this share link.
       *
       * @type String
       */
      this.name = template.name;

      /**
       * The actual URL of the link which can be used to access the shared
       * connection.
       *
       * @type String
       */
      this.href = template.href;

      /**
       * The sharing profile which was used to generate the share link.
       *
       * @type SharingProfile
       */
      this.sharingProfile = template.sharingProfile;

      /**
       * The credentials from which the share link was derived.
       *
       * @type UserCredentials
       */
      this.sharingCredentials = template.sharingCredentials;
    };

    /**
     * Creates a new ManagedShareLink from a set of UserCredentials and the
     * SharingProfile which was used to generate those UserCredentials.
     *
     * @param {SharingProfile} sharingProfile
     *     The SharingProfile which was used, via the REST API, to generate the
     *     given UserCredentials.
     *
     * @param {UserCredentials} sharingCredentials
     *     The UserCredentials object returned by the REST API in response to a
     *     request to share a connection using the given SharingProfile.
     *
     * @return {ManagedShareLink}
     *     A new ManagedShareLink object can be used to access the connection
     *     shared via the given SharingProfile and resulting UserCredentials.
     */
    ManagedShareLink.getInstance = function getInstance(
      sharingProfile,
      sharingCredentials
    ) {
      // Generate new share link using the given profile and credentials
      return new ManagedShareLink({
        name: sharingProfile.name,
        href: UserCredentials.getLink(sharingCredentials),
        sharingProfile: sharingProfile,
        sharingCredentials: sharingCredentials,
      });
    };

    return ManagedShareLink;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The module for code used to manipulate/observe the clipboard.
 */
angular.module("clipboard", []);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive provides an editor whose contents are exposed via a
 * ClipboardData object via the "data" attribute. If this data should also be
 * synced to the local clipboard, or sent via a connected Guacamole client
 * using a "guacClipboard" event, it is up to external code to do so.
 */
angular.module("clipboard").directive("guacClipboard", [
  "$injector",
  function guacClipboard($injector) {
    // Required types
    var ClipboardData = $injector.get("ClipboardData");

    /**
     * Configuration object for the guacClipboard directive.
     *
     * @type Object.<String, Object>
     */
    var config = {
      restrict: "E",
      replace: true,
      templateUrl: "app/clipboard/templates/guacClipboard.html",
    };

    // Scope properties exposed by the guacClipboard directive
    config.scope = {
      /**
       * The data to display within the field provided by this directive. This
       * data will modified or replaced when the user manually alters the
       * contents of the field.
       *
       * @type ClipboardData
       */
      data: "=",
    };

    // guacClipboard directive controller
    config.controller = [
      "$scope",
      "$injector",
      "$element",
      function guacClipboardController($scope, $injector, $element) {
        /**
         * The DOM element which will contain the clipboard contents within the
         * user interface provided by this directive.
         *
         * @type Element
         */
        var element = $element[0];

        /**
         * Rereads the contents of the clipboard field, updating the
         * ClipboardData object on the scope as necessary. The type of data
         * stored within the ClipboardData object will be heuristically
         * determined from the HTML contents of the clipboard field.
         */
        var updateClipboardData = function updateClipboardData() {
          // Read contents of clipboard textarea
          $scope.$evalAsync(function assignClipboardText() {
            $scope.data = new ClipboardData({
              type: "text/plain",
              data: element.value,
            });
          });
        };

        // Update the internally-stored clipboard data when events are fired
        // that indicate the clipboard field may have been changed
        element.addEventListener("input", updateClipboardData);
        element.addEventListener("change", updateClipboardData);

        // Watch clipboard for new data, updating the clipboard textarea as
        // necessary
        $scope.$watch("data", function clipboardDataChanged(data) {
          // If the clipboard data is a string, render it as text
          if (typeof data.data === "string") element.value = data.data;

          // Ignore other data types for now
        }); // end $scope.data watch
      },
    ];

    return config;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for accessing local clipboard data.
 */
angular.module("clipboard").factory("clipboardService", [
  "$injector",
  function clipboardService($injector) {
    // Get required services
    var $q = $injector.get("$q");
    var $window = $injector.get("$window");

    // Required types
    var ClipboardData = $injector.get("ClipboardData");

    var service = {};

    /**
     * The amount of time to wait before actually serving a request to read
     * clipboard data, in milliseconds. Providing a reasonable delay between
     * request and read attempt allows the cut/copy operation to settle, in
     * case the data we are anticipating to be present is not actually present
     * in the clipboard yet.
     *
     * @constant
     * @type Number
     */
    var CLIPBOARD_READ_DELAY = 100;

    /**
     * The promise associated with the current pending clipboard read attempt.
     * If no clipboard read is active, this will be null.
     *
     * @type Promise.<ClipboardData>
     */
    var pendingRead = null;

    /**
     * Reference to the window.document object.
     *
     * @private
     * @type HTMLDocument
     */
    var document = $window.document;

    /**
     * The textarea that will be used to hold the local clipboard contents.
     *
     * @type Element
     */
    var clipboardContent = document.createElement("textarea");

    // Ensure clipboard target is selectable but not visible
    clipboardContent.className = "clipboard-service-target";

    // Add clipboard target to DOM
    document.body.appendChild(clipboardContent);

    /**
     * Stops the propogation of the given event through the DOM tree. This is
     * identical to invoking stopPropogation() on the event directly, except
     * that this function is usable as an event handler itself.
     *
     * @param {Event} e
     *     The event whose propogation through the DOM tree should be stopped.
     */
    var stopEventPropagation = function stopEventPropagation(e) {
      e.stopPropagation();
    };

    // Prevent events generated due to execCommand() from disturbing external things
    clipboardContent.addEventListener("cut", stopEventPropagation);
    clipboardContent.addEventListener("copy", stopEventPropagation);
    clipboardContent.addEventListener("paste", stopEventPropagation);
    clipboardContent.addEventListener("input", stopEventPropagation);

    /**
     * A stack of past node selection ranges. A range convering the nodes
     * currently selected within the document can be pushed onto this stack
     * with pushSelection(), and the most recently pushed selection can be
     * popped off the stack (and thus re-selected) with popSelection().
     *
     * @type Range[]
     */
    var selectionStack = [];

    /**
     * Pushes the current selection range to the selection stack such that it
     * can later be restored with popSelection().
     */
    var pushSelection = function pushSelection() {
      // Add a range representing the current selection to the stack
      var selection = $window.getSelection();
      if (selection.getRangeAt && selection.rangeCount)
        selectionStack.push(selection.getRangeAt(0));
    };

    /**
     * Pops a selection range off the selection stack restoring the document's
     * previous selection state. The selection range will be the most recent
     * selection range pushed by pushSelection(). If there are no selection
     * ranges currently on the stack, this function has no effect.
     */
    var popSelection = function popSelection() {
      // Pull one selection range from the stack
      var range = selectionStack.pop();
      if (!range) return;

      // Replace any current selection with the retrieved selection
      var selection = $window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
    };

    /**
     * Selects all nodes within the given element. This will replace the
     * current selection with a new selection range that covers the element's
     * contents. If the original selection should be preserved, use
     * pushSelection() and popSelection().
     *
     * @param {Element} element
     *     The element whose contents should be selected.
     */
    var selectAll = function selectAll(element) {
      // Use the select() function defined for input elements, if available
      if (element.select) element.select();
      // Fallback to manual manipulation of the selection
      else {
        // Generate a range which selects all nodes within the given element
        var range = document.createRange();
        range.selectNodeContents(element);

        // Replace any current selection with the generated range
        var selection = $window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
      }
    };

    /**
     * Sets the local clipboard, if possible, to the given text.
     *
     * @param {ClipboardData} data
     *     The data to assign to the local clipboard should be set.
     *
     * @return {Promise}
     *     A promise that will resolve if setting the clipboard was successful,
     *     and will reject if it failed.
     */
    service.setLocalClipboard = function setLocalClipboard(data) {
      var deferred = $q.defer();

      try {
        // Attempt to read the clipboard using the Asynchronous Clipboard
        // API, if it's available
        if (navigator.clipboard && navigator.clipboard.writeText) {
          if (data.type === "text/plain") {
            navigator.clipboard
              .writeText(data.data)
              .then(deferred.resolve, deferred.reject);
            return deferred.promise;
          }
        }
      } catch (ignore) {
        // Ignore any hard failures to use Asynchronous Clipboard API, falling
        // back to traditional document.execCommand()
      }

      // Track the originally-focused element prior to changing focus
      var originalElement = document.activeElement;
      pushSelection();

      // Copy the given value into the clipboard DOM element
      if (typeof data.data === "string") clipboardContent.value = data.data;
      else {
        clipboardContent.innerHTML = "";
        var img = document.createElement("img");
        img.src = URL.createObjectURL(data.data);
        clipboardContent.appendChild(img);
      }

      // Select all data within the clipboard target
      clipboardContent.focus();
      selectAll(clipboardContent);

      // Attempt to copy data from clipboard element into local clipboard
      if (document.execCommand("copy")) deferred.resolve();
      else deferred.reject();

      // Unfocus the clipboard DOM event to avoid mobile keyboard opening,
      // restoring whichever element was originally focused
      clipboardContent.blur();
      originalElement.focus();
      popSelection();

      return deferred.promise;
    };

    /**
     * Parses the given data URL, returning its decoded contents as a new Blob.
     * If the URL is not a valid data URL, null will be returned instead.
     *
     * @param {String} url
     *     The data URL to parse.
     *
     * @returns {Blob}
     *     A new Blob containing the decoded contents of the data URL, or null
     *     if the URL is not a valid data URL.
     */
    service.parseDataURL = function parseDataURL(url) {
      // Parse given string as a data URL
      var result = /^data:([^;]*);base64,([a-zA-Z0-9+/]*[=]*)$/.exec(url);
      if (!result) return null;

      // Pull the mimetype and base64 contents of the data URL
      var type = result[1];
      var data = $window.atob(result[2]);

      // Convert the decoded binary string into a typed array
      var buffer = new Uint8Array(data.length);
      for (var i = 0; i < data.length; i++) buffer[i] = data.charCodeAt(i);

      // Produce a proper blob containing the data and type provided in
      // the data URL
      return new Blob([buffer], { type: type });
    };

    /**
     * Returns the content of the given element as plain, unformatted text,
     * preserving only individual characters and newlines. Formatting, images,
     * etc. are not taken into account.
     *
     * @param {Element} element
     *     The element whose text content should be returned.
     *
     * @returns {String}
     *     The plain text contents of the given element, including newlines and
     *     spacing but otherwise without any formatting.
     */
    service.getTextContent = function getTextContent(element) {
      var blocks = [];
      var currentBlock = "";

      // For each child of the given element
      var current = element.firstChild;
      while (current) {
        // Simply append the content of any text nodes
        if (current.nodeType === Node.TEXT_NODE)
          currentBlock += current.nodeValue;
        // Render <br> as a newline character
        else if (current.nodeName === "BR") currentBlock += "\n";
        // Render <img> as alt text, if available
        else if (current.nodeName === "IMG")
          currentBlock += current.getAttribute("alt") || "";
        // For all other nodes, handling depends on whether they are
        // block-level elements
        else {
          // If we are entering a new block context, start a new block if
          // the current block is non-empty
          if (
            currentBlock.length &&
            $window.getComputedStyle(current).display === "block"
          ) {
            // Trim trailing newline (would otherwise inflate the line count by 1)
            if (currentBlock.substring(currentBlock.length - 1) === "\n")
              currentBlock = currentBlock.substring(0, currentBlock.length - 1);

            // Finish current block and start a new block
            blocks.push(currentBlock);
            currentBlock = "";
          }

          // Append the content of the current element to the current block
          currentBlock += service.getTextContent(current);
        }

        current = current.nextSibling;
      }

      // Add any in-progress block
      if (currentBlock.length) blocks.push(currentBlock);

      // Combine all non-empty blocks, separated by newlines
      return blocks.join("\n");
    };

    /**
     * Replaces the current text content of the given element with the given
     * text. To avoid affecting the position of the cursor within an editable
     * element, or firing unnecessary DOM modification events, the underlying
     * <code>textContent</code> property of the element is only touched if
     * doing so would actually change the text.
     *
     * @param {Element} element
     *     The element whose text content should be changed.
     *
     * @param {String} text
     *     The text content to assign to the given element.
     */
    service.setTextContent = function setTextContent(element, text) {
      // Strip out any images
      $(element).find("img").remove();

      // Reset text content only if doing so will actually change the content
      if (service.getTextContent(element) !== text) element.textContent = text;
    };

    /**
     * Returns the URL of the single image within the given element, if the
     * element truly contains only one child and that child is an image. If the
     * content of the element is mixed or not an image, null is returned.
     *
     * @param {Element} element
     *     The element whose image content should be retrieved.
     *
     * @returns {String}
     *     The URL of the image contained within the given element, if that
     *     element contains only a single child element which happens to be an
     *     image, or null if the content of the element is not purely an image.
     */
    service.getImageContent = function getImageContent(element) {
      // Return the source of the single child element, if it is an image
      var firstChild = element.firstChild;
      if (
        firstChild &&
        firstChild.nodeName === "IMG" &&
        !firstChild.nextSibling
      )
        return firstChild.getAttribute("src");

      // Otherwise, the content of this element is not simply an image
      return null;
    };

    /**
     * Replaces the current contents of the given element with a single image
     * having the given URL. To avoid affecting the position of the cursor
     * within an editable element, or firing unnecessary DOM modification
     * events, the content of the element is only touched if doing so would
     * actually change content.
     *
     * @param {Element} element
     *     The element whose image content should be changed.
     *
     * @param {String} url
     *     The URL of the image which should be assigned as the contents of the
     *     given element.
     */
    service.setImageContent = function setImageContent(element, url) {
      // Retrieve the URL of the current image contents, if any
      var currentImage = service.getImageContent(element);

      // If the current contents are not the given image (or not an image
      // at all), reassign the contents
      if (currentImage !== url) {
        // Clear current contents
        element.innerHTML = "";

        // Add a new image as the sole contents of the element
        var img = document.createElement("img");
        img.src = url;
        element.appendChild(img);
      }
    };

    /**
     * Get the current value of the local clipboard.
     *
     * @return {Promise.<ClipboardData>}
     *     A promise that will resolve with the contents of the local clipboard
     *     if getting the clipboard was successful, and will reject if it
     *     failed.
     */
    service.getLocalClipboard = function getLocalClipboard() {
      // If the clipboard is already being read, do not overlap the read
      // attempts; instead share the result across all requests
      if (pendingRead) return pendingRead;

      var deferred = $q.defer();

      try {
        // Attempt to read the clipboard using the Asynchronous Clipboard
        // API, if it's available
        if (navigator.clipboard && navigator.clipboard.readText) {
          navigator.clipboard.readText().then(function textRead(text) {
            deferred.resolve(
              new ClipboardData({
                type: "text/plain",
                data: text,
              })
            );
          }, deferred.reject);

          return deferred.promise;
        }
      } catch (ignore) {
        // Ignore any hard failures to use Asynchronous Clipboard API, falling
        // back to traditional document.execCommand()
      }

      // Track the originally-focused element prior to changing focus
      var originalElement = document.activeElement;

      /**
       * Attempts to paste the clipboard contents into the
       * currently-focused element. The promise related to the current
       * attempt to read the clipboard will be resolved or rejected
       * depending on whether the attempt to paste succeeds.
       */
      var performPaste = function performPaste() {
        // Attempt paste local clipboard into clipboard DOM element
        if (document.execCommand("paste")) {
          // If the pasted data is a single image, resolve with a blob
          // containing that image
          var currentImage = service.getImageContent(clipboardContent);
          if (currentImage) {
            // Convert the image's data URL into a blob
            var blob = service.parseDataURL(currentImage);
            if (blob) {
              deferred.resolve(
                new ClipboardData({
                  type: blob.type,
                  data: blob,
                })
              );
            }

            // Reject if conversion fails
            else deferred.reject();
          } // end if clipboard is an image

          // Otherwise, assume the clipboard contains plain text
          else
            deferred.resolve(
              new ClipboardData({
                type: "text/plain",
                data: clipboardContent.value,
              })
            );
        }

        // Otherwise, reading from the clipboard has failed
        else deferred.reject();
      };

      // Mark read attempt as in progress, cleaning up event listener and
      // selection once the paste attempt has completed
      pendingRead = deferred.promise["finally"](function cleanupReadAttempt() {
        // Do not use future changes in focus
        clipboardContent.removeEventListener("focus", performPaste);

        // Unfocus the clipboard DOM event to avoid mobile keyboard opening,
        // restoring whichever element was originally focused
        clipboardContent.blur();
        originalElement.focus();
        popSelection();

        // No read is pending any longer
        pendingRead = null;
      });

      // Wait for the next event queue run before attempting to read
      // clipboard data (in case the copy/cut has not yet completed)
      $window.setTimeout(function deferredClipboardRead() {
        pushSelection();

        // Ensure clipboard element is blurred (and that the "focus" event
        // will fire)
        clipboardContent.blur();
        clipboardContent.addEventListener("focus", performPaste);

        // Clear and select the clipboard DOM element
        clipboardContent.value = "";
        clipboardContent.focus();
        selectAll(clipboardContent);

        // If focus failed to be set, we cannot read the clipboard
        if (document.activeElement !== clipboardContent) deferred.reject();
      }, CLIPBOARD_READ_DELAY);

      return pendingRead;
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the ClipboardData class used for interchange between the
 * guacClipboard directive, clipboardService service, etc.
 */
angular.module("clipboard").factory("ClipboardData", [
  function defineClipboardData() {
    /**
     * Arbitrary data which can be contained by the clipboard.
     *
     * @constructor
     * @param {ClipboardData|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ClipboardData.
     */
    var ClipboardData = function ClipboardData(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The mimetype of the data currently stored within the clipboard.
       *
       * @type String
       */
      this.type = template.type || "text/plain";

      /**
       * The data currently stored within the clipboard. Depending on the
       * nature of the stored data, this may be either a String, a Blob, or a
       * File.
       *
       * @type String|Blob|File
       */
      this.data = template.data || "";
    };

    return ClipboardData;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which allows elements to be manually focused / blurred.
 */
angular.module("element").directive("guacFocus", [
  "$injector",
  function guacFocus($injector) {
    // Required services
    var $parse = $injector.get("$parse");
    var $timeout = $injector.get("$timeout");

    return {
      restrict: "A",

      link: function linkGuacFocus($scope, $element, $attrs) {
        /**
         * Whether the element associated with this directive should be
         * focussed.
         *
         * @type Boolean
         */
        var guacFocus = $parse($attrs.guacFocus);

        /**
         * The element which will be focused / blurred.
         *
         * @type Element
         */
        var element = $element[0];

        // Set/unset focus depending on value of guacFocus
        $scope.$watch(guacFocus, function updateFocus(value) {
          $timeout(function updateFocusAfterRender() {
            if (value) element.focus();
            else element.blur();
          });
        });
      }, // end guacFocus link function
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which stores a marker which refers to a specific element,
 * allowing that element to be scrolled into view when desired.
 */
angular.module("element").directive("guacMarker", [
  "$injector",
  function guacMarker($injector) {
    // Required types
    var Marker = $injector.get("Marker");

    // Required services
    var $parse = $injector.get("$parse");

    return {
      restrict: "A",

      link: function linkGuacMarker($scope, $element, $attrs) {
        /**
         * The property in which a new Marker should be stored. The new
         * Marker will refer to the element associated with this directive.
         *
         * @type Marker
         */
        var guacMarker = $parse($attrs.guacMarker);

        /**
         * The element to associate with the new Marker.
         *
         * @type Element
         */
        var element = $element[0];

        // Assign new marker
        guacMarker.assign($scope, new Marker(element));
      },
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which calls a given callback when its associated element is
 * resized. This will modify the internal DOM tree of the associated element,
 * and the associated element MUST have position (for example,
 * "position: relative").
 */
angular.module("element").directive("guacResize", [
  "$document",
  function guacResize($document) {
    return {
      restrict: "A",

      link: function linkGuacResize($scope, $element, $attrs) {
        /**
         * The function to call whenever the associated element is
         * resized. The function will be passed the width and height of
         * the element, in pixels.
         *
         * @type Function
         */
        var guacResize = $scope.$eval($attrs.guacResize);

        /**
         * The element which will monitored for size changes.
         *
         * @type Element
         */
        var element = $element[0];

        /**
         * The resize sensor - an HTML object element.
         *
         * @type HTMLObjectElement
         */
        var resizeSensor = $document[0].createElement("object");

        /**
         * The width of the associated element, in pixels.
         *
         * @type Number
         */
        var lastWidth = element.offsetWidth;

        /**
         * The height of the associated element, in pixels.
         *
         * @type Number
         */
        var lastHeight = element.offsetHeight;

        /**
         * Checks whether the size of the associated element has changed
         * and, if so, calls the resize callback with the new width and
         * height as parameters.
         */
        var checkSize = function checkSize() {
          // Call callback only if size actually changed
          if (
            element.offsetWidth !== lastWidth ||
            element.offsetHeight !== lastHeight
          ) {
            // Call resize callback, if defined
            if (guacResize) {
              $scope.$evalAsync(function elementSizeChanged() {
                guacResize(element.offsetWidth, element.offsetHeight);
              });
            }

            // Update stored size
            lastWidth = element.offsetWidth;
            lastHeight = element.offsetHeight;
          }
        };

        // Register event listener once window object exists
        resizeSensor.onload = function resizeSensorReady() {
          resizeSensor.contentDocument.defaultView.addEventListener(
            "resize",
            checkSize
          );
          checkSize();
        };

        // Load blank contents
        resizeSensor.className = "resize-sensor";
        resizeSensor.type = "text/html";
        // resizeSensor.data      = 'app/element/templates/blank.html';
        // resizeSensor.contentDocument.body.innerHTML = ''
        // Add resize sensor to associated element
        element.insertBefore(resizeSensor, element.firstChild);
      }, // end guacResize link function
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which allows elements to be manually scrolled, and for their
 * scroll state to be observed.
 */
angular.module("element").directive("guacScroll", [
  function guacScroll() {
    return {
      restrict: "A",

      link: function linkGuacScroll($scope, $element, $attrs) {
        /**
         * The current scroll state of the element.
         *
         * @type ScrollState
         */
        var guacScroll = $scope.$eval($attrs.guacScroll);

        /**
         * The element which is being scrolled, or monitored for changes
         * in scroll.
         *
         * @type Element
         */
        var element = $element[0];

        /**
         * Returns the current left edge of the scrolling rectangle.
         *
         * @returns {Number}
         *     The current left edge of the scrolling rectangle.
         */
        var getScrollLeft = function getScrollLeft() {
          return guacScroll.left;
        };

        /**
         * Returns the current top edge of the scrolling rectangle.
         *
         * @returns {Number}
         *     The current top edge of the scrolling rectangle.
         */
        var getScrollTop = function getScrollTop() {
          return guacScroll.top;
        };

        // Update underlying scrollLeft property when left changes
        $scope.$watch(getScrollLeft, function scrollLeftChanged(left) {
          element.scrollLeft = left;
          guacScroll.left = element.scrollLeft;
        });

        // Update underlying scrollTop property when top changes
        $scope.$watch(getScrollTop, function scrollTopChanged(top) {
          element.scrollTop = top;
          guacScroll.top = element.scrollTop;
        });
      }, // end guacScroll link function
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which allows multiple files to be uploaded. Clicking on the
 * associated element will result in a file selector dialog, which then calls
 * the provided callback function with any chosen files.
 */
angular.module("element").directive("guacUpload", [
  "$document",
  function guacUpload($document) {
    return {
      restrict: "A",

      link: function linkGuacUpload($scope, $element, $attrs) {
        /**
         * The function to call whenever files are chosen. The callback is
         * provided a single parameter: the FileList containing all chosen
         * files.
         *
         * @type Function
         */
        var guacUpload = $scope.$eval($attrs.guacUpload);

        /**
         * The element which will register the drag gesture.
         *
         * @type Element
         */
        var element = $element[0];

        /**
         * Internal form, containing a single file input element.
         *
         * @type HTMLFormElement
         */
        var form = $document[0].createElement("form");

        /**
         * Internal file input element.
         *
         * @type HTMLInputElement
         */
        var input = $document[0].createElement("input");

        // Init input element
        input.type = "file";
        input.multiple = true;

        // Add input element to internal form
        form.appendChild(input);

        // Notify of any chosen files
        input.addEventListener("change", function filesSelected() {
          $scope.$apply(function setSelectedFiles() {
            // Only set chosen files selection is not canceled
            if (guacUpload && input.files.length > 0) guacUpload(input.files);

            // Reset selection
            form.reset();
          });
        });

        // Open file chooser when element is clicked
        element.addEventListener("click", function elementClicked() {
          input.click();
        });
      }, // end guacUpload link function
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Module for manipulating element state, such as focus or scroll position, as
 * well as handling browser events.
 */
angular.module("element", []);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the Marker class definition.
 */
angular.module("element").factory("Marker", [
  function defineMarker() {
    /**
     * Creates a new Marker which allows its associated element to be scolled
     * into view as desired.
     *
     * @constructor
     * @param {Element} element
     *     The element to associate with this marker.
     */
    var Marker = function Marker(element) {
      /**
       * Scrolls scrollable elements, or the window, as needed to bring the
       * element associated with this marker into view.
       */
      this.scrollIntoView = function scrollIntoView() {
        element.scrollIntoView();
      };
    };

    return Marker;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the ScrollState class definition.
 */
angular.module("element").factory("ScrollState", [
  function defineScrollState() {
    /**
     * Creates a new ScrollState, representing the current scroll position of
     * an arbitrary element. This constructor initializes the properties of the
     * new ScrollState with the corresponding properties of the given template.
     *
     * @constructor
     * @param {ScrollState|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ScrollState.
     */
    var ScrollState = function ScrollState(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The left edge of the view rectangle within the scrollable area. This
       * value naturally increases as the user scrolls right.
       *
       * @type Number
       */
      this.left = template.left || 0;

      /**
       * The top edge of the view rectangle within the scrollable area. This
       * value naturally increases as the user scrolls down.
       *
       * @type Number
       */
      this.top = template.top || 0;
    };

    return ScrollState;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Controller for checkbox fields.
 */
angular.module("form").controller("checkboxFieldController", [
  "$scope",
  function checkboxFieldController($scope) {
    // Update typed value when model is changed
    $scope.$watch("model", function modelChanged(model) {
      $scope.typedValue = model === $scope.field.options[0];
    });

    // Update string value in model when typed value is changed
    $scope.$watch("typedValue", function typedValueChanged(typedValue) {
      $scope.model = typedValue ? $scope.field.options[0] : "";
    });
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Controller for date fields.
 */
angular.module("form").controller("dateFieldController", [
  "$scope",
  "$injector",
  function dateFieldController($scope, $injector) {
    // Required services
    var $filter = $injector.get("$filter");

    /**
     * Options which dictate the behavior of the input field model, as defined
     * by https://docs.angularjs.org/api/ng/directive/ngModelOptions
     *
     * @type Object.<String, String>
     */
    $scope.modelOptions = {
      /**
       * Space-delimited list of events on which the model will be updated.
       *
       * @type String
       */
      updateOn: "blur",

      /**
       * The time zone to use when reading/writing the Date object of the
       * model.
       *
       * @type String
       */
      timezone: "UTC",
    };

    /**
     * Parses the date components of the given string into a Date with only the
     * date components set. The resulting Date will be in the UTC timezone,
     * with the time left as midnight. The input string must be in the format
     * YYYY-MM-DD (zero-padded).
     *
     * @param {String} str
     *     The date string to parse.
     *
     * @returns {Date}
     *     A Date object, in the UTC timezone, with only the date components
     *     set.
     */
    var parseDate = function parseDate(str) {
      // Parse date, return blank if invalid
      var parsedDate = new Date(str + "T00:00Z");
      if (isNaN(parsedDate.getTime())) return null;

      return parsedDate;
    };

    // Update typed value when model is changed
    $scope.$watch("model", function modelChanged(model) {
      $scope.typedValue = model ? parseDate(model) : null;
    });

    // Update string value in model when typed value is changed
    $scope.$watch("typedValue", function typedValueChanged(typedValue) {
      $scope.model = typedValue
        ? $filter("date")(typedValue, "yyyy-MM-dd", "UTC")
        : "";
    });
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Controller for the language field type. The language field type allows the
 * user to select a language from the set of languages supported by the
 * Guacamole web application.
 */
angular.module("form").controller("languageFieldController", [
  "$scope",
  "$injector",
  function languageFieldController($scope, $injector) {
    // Required services
    var languageService = $injector.get("languageService");
    var requestService = $injector.get("requestService");

    /**
     * A map of all available language keys to their human-readable
     * names.
     *
     * @type Object.<String, String>
     */
    $scope.languages = null;

    // Retrieve defined languages
    languageService.getLanguages().then(function languagesRetrieved(languages) {
      $scope.languages = languages;
    }, requestService.DIE);

    // Interpret undefined/null as empty string
    $scope.$watch("model", function setModel(model) {
      if (!model && model !== "") $scope.model = "";
    });
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Controller for number fields.
 */
angular.module("form").controller("numberFieldController", [
  "$scope",
  function numberFieldController($scope) {
    // Update typed value when model is changed
    $scope.$watch("model", function modelChanged(model) {
      $scope.typedValue = model ? Number(model) : null;
    });

    // Update string value in model when typed value is changed
    $scope.$watch("typedValue", function typedValueChanged(typedValue) {
      $scope.model =
        typedValue || typedValue === 0 ? typedValue.toString() : "";
    });
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Controller for password fields.
 */
angular.module("form").controller("passwordFieldController", [
  "$scope",
  function passwordFieldController($scope) {
    /**
     * The type to use for the input field. By default, the input field will
     * have the type 'password', and thus will be masked.
     *
     * @type String
     * @default 'password'
     */
    $scope.passwordInputType = "password";

    /**
     * Returns a string which describes the action the next call to
     * togglePassword() will have.
     *
     * @return {String}
     *     A string which describes the action the next call to
     *     togglePassword() will have.
     */
    $scope.getTogglePasswordHelpText = function getTogglePasswordHelpText() {
      // If password is hidden, togglePassword() will show the password
      if ($scope.passwordInputType === "password")
        return "FORM.HELP_SHOW_PASSWORD";

      // If password is shown, togglePassword() will hide the password
      return "FORM.HELP_HIDE_PASSWORD";
    };

    /**
     * Toggles visibility of the field contents, if this field is a
     * password field. Initially, password contents are masked
     * (invisible).
     */
    $scope.togglePassword = function togglePassword() {
      // If password is hidden, show the password
      if ($scope.passwordInputType === "password")
        $scope.passwordInputType = "text";
      // If password is shown, hide the password
      else $scope.passwordInputType = "password";
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Controller for the redirect field, which redirects the user to the provided
 * URL.
 */
angular.module("form").controller("redirectFieldController", [
  "$scope",
  "$window",
  function redirectFieldController($scope, $window) {
    /**
     * Redirect the user to the provided URL.
     */
    $window.location.href = $scope.field.redirectUrl;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Controller for select fields.
 */
angular.module("form").controller("selectFieldController", [
  "$scope",
  "$injector",
  function selectFieldController($scope, $injector) {
    // Interpret undefined/null as empty string
    $scope.$watch("model", function setModel(model) {
      if (!model && model !== "") $scope.model = "";
    });
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Controller for terminal color scheme fields.
 */
angular.module("form").controller("terminalColorSchemeFieldController", [
  "$scope",
  "$injector",
  function terminalColorSchemeFieldController($scope, $injector) {
    // Required types
    var ColorScheme = $injector.get("ColorScheme");

    /**
     * The currently selected color scheme. If a pre-defined color scheme is
     * selected, this will be the connection parameter value associated with
     * that color scheme. If a custom color scheme is selected, this will be
     * the string "custom".
     *
     * @type String
     */
    $scope.selectedColorScheme = "";

    /**
     * The current custom color scheme, if a custom color scheme has been
     * specified. If no custom color scheme has yet been specified, this will
     * be a ColorScheme instance that has been initialized to the default
     * colors.
     *
     * @type ColorScheme
     */
    $scope.customColorScheme = new ColorScheme();

    /**
     * The array of colors to include within the color picker as pre-defined
     * options for convenience.
     *
     * @type String[]
     */
    $scope.defaultPalette = new ColorScheme().colors;

    /**
     * Whether the raw details of the custom color scheme should be shown. By
     * default, such details are hidden.
     *
     * @type Boolean
     */
    $scope.detailsShown = false;

    /**
     * The palette indices of all colors which are considered low-intensity.
     *
     * @type Number[]
     */
    $scope.lowIntensity = [0, 1, 2, 3, 4, 5, 6, 7];

    /**
     * The palette indices of all colors which are considered high-intensity.
     *
     * @type Number[]
     */
    $scope.highIntensity = [8, 9, 10, 11, 12, 13, 14, 15];

    /**
     * The string value which is assigned to selectedColorScheme if a custom
     * color scheme is selected.
     *
     * @constant
     * @type String
     */
    var CUSTOM_COLOR_SCHEME = "custom";

    /**
     * Returns whether a custom color scheme has been selected.
     *
     * @returns {Boolean}
     *     true if a custom color scheme has been selected, false otherwise.
     */
    $scope.isCustom = function isCustom() {
      return $scope.selectedColorScheme === CUSTOM_COLOR_SCHEME;
    };

    /**
     * Shows the raw details of the custom color scheme. If the details are
     * already shown, this function has no effect.
     */
    $scope.showDetails = function showDetails() {
      $scope.detailsShown = true;
    };

    /**
     * Hides the raw details of the custom color scheme. If the details are
     * already hidden, this function has no effect.
     */
    $scope.hideDetails = function hideDetails() {
      $scope.detailsShown = false;
    };

    // Keep selected color scheme and custom color scheme in sync with changes
    // to model
    $scope.$watch("model", function modelChanged(model) {
      if (
        $scope.selectedColorScheme === CUSTOM_COLOR_SCHEME ||
        (model && !_.includes($scope.field.options, model))
      ) {
        $scope.customColorScheme = ColorScheme.fromString(model);
        $scope.selectedColorScheme = CUSTOM_COLOR_SCHEME;
      } else $scope.selectedColorScheme = model || "";
    });

    // Keep model in sync with changes to selected color scheme
    $scope.$watch(
      "selectedColorScheme",
      function selectedColorSchemeChanged(selectedColorScheme) {
        if (!selectedColorScheme) $scope.model = "";
        else if (selectedColorScheme === CUSTOM_COLOR_SCHEME)
          $scope.model = ColorScheme.toString($scope.customColorScheme);
        else $scope.model = selectedColorScheme;
      }
    );

    // Keep model in sync with changes to custom color scheme
    $scope.$watch(
      "customColorScheme",
      function customColorSchemeChanged(customColorScheme) {
        if ($scope.selectedColorScheme === CUSTOM_COLOR_SCHEME)
          $scope.model = ColorScheme.toString(customColorScheme);
      },
      true
    );
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Controller for text fields.
 */
angular.module("form").controller("textFieldController", [
  "$scope",
  "$injector",
  function textFieldController($scope, $injector) {
    /**
     * The ID of the datalist element that should be associated with the text
     * field, providing a set of known-good values. If no such values are
     * defined, this will be null.
     *
     * @type String
     */
    $scope.dataListId = null;

    // Generate unique ID for datalist, if applicable
    if ($scope.field.options && $scope.field.options.length)
      $scope.dataListId = $scope.fieldId + "-datalist";
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Controller for time fields.
 */
angular.module("form").controller("timeFieldController", [
  "$scope",
  "$injector",
  function timeFieldController($scope, $injector) {
    // Required services
    var $filter = $injector.get("$filter");

    /**
     * Options which dictate the behavior of the input field model, as defined
     * by https://docs.angularjs.org/api/ng/directive/ngModelOptions
     *
     * @type Object.<String, String>
     */
    $scope.modelOptions = {
      /**
       * Space-delimited list of events on which the model will be updated.
       *
       * @type String
       */
      updateOn: "blur",

      /**
       * The time zone to use when reading/writing the Date object of the
       * model.
       *
       * @type String
       */
      timezone: "UTC",
    };

    /**
     * Parses the time components of the given string into a Date with only the
     * time components set. The resulting Date will be in the UTC timezone,
     * with the date left as 1970-01-01. The input string must be in the format
     * HH:MM:SS (zero-padded, 24-hour).
     *
     * @param {String} str
     *     The time string to parse.
     *
     * @returns {Date}
     *     A Date object, in the UTC timezone, with only the time components
     *     set.
     */
    var parseTime = function parseTime(str) {
      // Parse time, return blank if invalid
      var parsedDate = new Date("1970-01-01T" + str + "Z");
      if (isNaN(parsedDate.getTime())) return null;

      return parsedDate;
    };

    // Update typed value when model is changed
    $scope.$watch("model", function modelChanged(model) {
      $scope.typedValue = model ? parseTime(model) : null;
    });

    // Update string value in model when typed value is changed
    $scope.$watch("typedValue", function typedValueChanged(typedValue) {
      $scope.model = typedValue
        ? $filter("date")(typedValue, "HH:mm:ss", "UTC")
        : "";
    });
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Controller for time zone fields. Time zone fields use IANA time zone
 * database identifiers as the standard representation for each supported time
 * zone. These identifiers are also legal Java time zone IDs.
 */
angular.module("form").controller("timeZoneFieldController", [
  "$scope",
  "$injector",
  function timeZoneFieldController($scope, $injector) {
    /**
     * Map of time zone regions to the map of all time zone name/ID pairs
     * within those regions.
     *
     * @type Object.<String, Object.<String, String>>
     */
    $scope.timeZones = {
      Africa: {
        Abidjan: "Africa/Abidjan",
        Accra: "Africa/Accra",
        "Addis Ababa": "Africa/Addis_Ababa",
        Algiers: "Africa/Algiers",
        Asmara: "Africa/Asmara",
        Asmera: "Africa/Asmera",
        Bamako: "Africa/Bamako",
        Bangui: "Africa/Bangui",
        Banjul: "Africa/Banjul",
        Bissau: "Africa/Bissau",
        Blantyre: "Africa/Blantyre",
        Brazzaville: "Africa/Brazzaville",
        Bujumbura: "Africa/Bujumbura",
        Cairo: "Africa/Cairo",
        Casablanca: "Africa/Casablanca",
        Ceuta: "Africa/Ceuta",
        Conakry: "Africa/Conakry",
        Dakar: "Africa/Dakar",
        "Dar es Salaam": "Africa/Dar_es_Salaam",
        Djibouti: "Africa/Djibouti",
        Douala: "Africa/Douala",
        "El Aaiun": "Africa/El_Aaiun",
        Freetown: "Africa/Freetown",
        Gaborone: "Africa/Gaborone",
        Harare: "Africa/Harare",
        Johannesburg: "Africa/Johannesburg",
        Juba: "Africa/Juba",
        Kampala: "Africa/Kampala",
        Khartoum: "Africa/Khartoum",
        Kigali: "Africa/Kigali",
        Kinshasa: "Africa/Kinshasa",
        Lagos: "Africa/Lagos",
        Libreville: "Africa/Libreville",
        Lome: "Africa/Lome",
        Luanda: "Africa/Luanda",
        Lubumbashi: "Africa/Lubumbashi",
        Lusaka: "Africa/Lusaka",
        Malabo: "Africa/Malabo",
        Maputo: "Africa/Maputo",
        Maseru: "Africa/Maseru",
        Mbabane: "Africa/Mbabane",
        Mogadishu: "Africa/Mogadishu",
        Monrovia: "Africa/Monrovia",
        Nairobi: "Africa/Nairobi",
        Ndjamena: "Africa/Ndjamena",
        Niamey: "Africa/Niamey",
        Nouakchott: "Africa/Nouakchott",
        Ouagadougou: "Africa/Ouagadougou",
        "Porto-Novo": "Africa/Porto-Novo",
        "Sao Tome": "Africa/Sao_Tome",
        Timbuktu: "Africa/Timbuktu",
        Tripoli: "Africa/Tripoli",
        Tunis: "Africa/Tunis",
        Windhoek: "Africa/Windhoek",
      },

      America: {
        Adak: "America/Adak",
        Anchorage: "America/Anchorage",
        Anguilla: "America/Anguilla",
        Antigua: "America/Antigua",
        Araguaina: "America/Araguaina",
        "Argentina / Buenos Aires": "America/Argentina/Buenos_Aires",
        "Argentina / Catamarca": "America/Argentina/Catamarca",
        "Argentina / Comodoro Rivadavia": "America/Argentina/ComodRivadavia",
        "Argentina / Cordoba": "America/Argentina/Cordoba",
        "Argentina / Jujuy": "America/Argentina/Jujuy",
        "Argentina / La Rioja": "America/Argentina/La_Rioja",
        "Argentina / Mendoza": "America/Argentina/Mendoza",
        "Argentina / Rio Gallegos": "America/Argentina/Rio_Gallegos",
        "Argentina / Salta": "America/Argentina/Salta",
        "Argentina / San Juan": "America/Argentina/San_Juan",
        "Argentina / San Luis": "America/Argentina/San_Luis",
        "Argentina / Tucuman": "America/Argentina/Tucuman",
        "Argentina / Ushuaia": "America/Argentina/Ushuaia",
        Aruba: "America/Aruba",
        Asuncion: "America/Asuncion",
        Atikokan: "America/Atikokan",
        Atka: "America/Atka",
        Bahia: "America/Bahia",
        "Bahia Banderas": "America/Bahia_Banderas",
        Barbados: "America/Barbados",
        Belem: "America/Belem",
        Belize: "America/Belize",
        "Blanc-Sablon": "America/Blanc-Sablon",
        "Boa Vista": "America/Boa_Vista",
        Bogota: "America/Bogota",
        Boise: "America/Boise",
        "Buenos Aires": "America/Buenos_Aires",
        "Cambridge Bay": "America/Cambridge_Bay",
        "Campo Grande": "America/Campo_Grande",
        Cancun: "America/Cancun",
        Caracas: "America/Caracas",
        Catamarca: "America/Catamarca",
        Cayenne: "America/Cayenne",
        Cayman: "America/Cayman",
        Chicago: "America/Chicago",
        Chihuahua: "America/Chihuahua",
        "Coral Harbour": "America/Coral_Harbour",
        Cordoba: "America/Cordoba",
        "Costa Rica": "America/Costa_Rica",
        Creston: "America/Creston",
        Cuiaba: "America/Cuiaba",
        Curacao: "America/Curacao",
        Danmarkshavn: "America/Danmarkshavn",
        Dawson: "America/Dawson",
        "Dawson Creek": "America/Dawson_Creek",
        Denver: "America/Denver",
        Detroit: "America/Detroit",
        Dominica: "America/Dominica",
        Edmonton: "America/Edmonton",
        Eirunepe: "America/Eirunepe",
        "El Salvador": "America/El_Salvador",
        Ensenada: "America/Ensenada",
        "Fort Wayne": "America/Fort_Wayne",
        Fortaleza: "America/Fortaleza",
        "Glace Bay": "America/Glace_Bay",
        Godthab: "America/Godthab",
        "Goose Bay": "America/Goose_Bay",
        "Grand Turk": "America/Grand_Turk",
        Grenada: "America/Grenada",
        Guadeloupe: "America/Guadeloupe",
        Guatemala: "America/Guatemala",
        Guayaquil: "America/Guayaquil",
        Guyana: "America/Guyana",
        Halifax: "America/Halifax",
        Havana: "America/Havana",
        Hermosillo: "America/Hermosillo",
        "Indiana / Indianapolis": "America/Indiana/Indianapolis",
        "Indiana / Knox": "America/Indiana/Knox",
        "Indiana / Marengo": "America/Indiana/Marengo",
        "Indiana / Petersburg": "America/Indiana/Petersburg",
        "Indiana / Tell City": "America/Indiana/Tell_City",
        "Indiana / Vevay": "America/Indiana/Vevay",
        "Indiana / Vincennes": "America/Indiana/Vincennes",
        "Indiana / Winamac": "America/Indiana/Winamac",
        Indianapolis: "America/Indianapolis",
        Inuvik: "America/Inuvik",
        Iqaluit: "America/Iqaluit",
        Jamaica: "America/Jamaica",
        Jujuy: "America/Jujuy",
        Juneau: "America/Juneau",
        "Kentucky / Louisville": "America/Kentucky/Louisville",
        "Kentucky / Monticello": "America/Kentucky/Monticello",
        Kralendijk: "America/Kralendijk",
        "La Paz": "America/La_Paz",
        Lima: "America/Lima",
        "Los Angeles": "America/Los_Angeles",
        Louisville: "America/Louisville",
        "Lower Princes": "America/Lower_Princes",
        Maceio: "America/Maceio",
        Managua: "America/Managua",
        Manaus: "America/Manaus",
        Marigot: "America/Marigot",
        Martinique: "America/Martinique",
        Matamoros: "America/Matamoros",
        Mazatlan: "America/Mazatlan",
        Mendoza: "America/Mendoza",
        Menominee: "America/Menominee",
        Merida: "America/Merida",
        Metlakatla: "America/Metlakatla",
        "Mexico City": "America/Mexico_City",
        Miquelon: "America/Miquelon",
        Moncton: "America/Moncton",
        Monterrey: "America/Monterrey",
        Montevideo: "America/Montevideo",
        Montreal: "America/Montreal",
        Montserrat: "America/Montserrat",
        Nassau: "America/Nassau",
        "New York": "America/New_York",
        Nipigon: "America/Nipigon",
        Nome: "America/Nome",
        Noronha: "America/Noronha",
        "North Dakota / Beulah": "America/North_Dakota/Beulah",
        "North Dakota / Center": "America/North_Dakota/Center",
        "North Dakota / New Salem": "America/North_Dakota/New_Salem",
        Ojinaga: "America/Ojinaga",
        Panama: "America/Panama",
        Pangnirtung: "America/Pangnirtung",
        Paramaribo: "America/Paramaribo",
        Phoenix: "America/Phoenix",
        "Port-au-Prince": "America/Port-au-Prince",
        "Port of Spain": "America/Port_of_Spain",
        "Porto Acre": "America/Porto_Acre",
        "Porto Velho": "America/Porto_Velho",
        "Puerto Rico": "America/Puerto_Rico",
        "Rainy River": "America/Rainy_River",
        "Rankin Inlet": "America/Rankin_Inlet",
        Recife: "America/Recife",
        Regina: "America/Regina",
        Resolute: "America/Resolute",
        "Rio Branco": "America/Rio_Branco",
        Rosario: "America/Rosario",
        "Santa Isabel": "America/Santa_Isabel",
        Santarem: "America/Santarem",
        Santiago: "America/Santiago",
        "Santo Domingo": "America/Santo_Domingo",
        "Sao Paulo": "America/Sao_Paulo",
        Scoresbysund: "America/Scoresbysund",
        Shiprock: "America/Shiprock",
        Sitka: "America/Sitka",
        "St. Barthelemy": "America/St_Barthelemy",
        "St. Johns": "America/St_Johns",
        "St. Kitts": "America/St_Kitts",
        "St. Lucia": "America/St_Lucia",
        "St. Thomas": "America/St_Thomas",
        "St. Vincent": "America/St_Vincent",
        "Swift Current": "America/Swift_Current",
        Tegucigalpa: "America/Tegucigalpa",
        Thule: "America/Thule",
        "Thunder Bay": "America/Thunder_Bay",
        Tijuana: "America/Tijuana",
        Toronto: "America/Toronto",
        Tortola: "America/Tortola",
        Vancouver: "America/Vancouver",
        Virgin: "America/Virgin",
        Whitehorse: "America/Whitehorse",
        Winnipeg: "America/Winnipeg",
        Yakutat: "America/Yakutat",
        Yellowknife: "America/Yellowknife",
      },

      Antarctica: {
        Casey: "Antarctica/Casey",
        Davis: "Antarctica/Davis",
        "Dumont d'Urville": "Antarctica/DumontDUrville",
        Macquarie: "Antarctica/Macquarie",
        Mawson: "Antarctica/Mawson",
        McMurdo: "Antarctica/McMurdo",
        Palmer: "Antarctica/Palmer",
        Rothera: "Antarctica/Rothera",
        "South Pole": "Antarctica/South_Pole",
        Syowa: "Antarctica/Syowa",
        Troll: "Antarctica/Troll",
        Vostok: "Antarctica/Vostok",
      },

      Arctic: {
        Longyearbyen: "Arctic/Longyearbyen",
      },

      Asia: {
        Aden: "Asia/Aden",
        Almaty: "Asia/Almaty",
        Amman: "Asia/Amman",
        Anadyr: "Asia/Anadyr",
        Aqtau: "Asia/Aqtau",
        Aqtobe: "Asia/Aqtobe",
        Ashgabat: "Asia/Ashgabat",
        Ashkhabad: "Asia/Ashkhabad",
        Baghdad: "Asia/Baghdad",
        Bahrain: "Asia/Bahrain",
        Baku: "Asia/Baku",
        Bangkok: "Asia/Bangkok",
        Beirut: "Asia/Beirut",
        Bishkek: "Asia/Bishkek",
        Brunei: "Asia/Brunei",
        Calcutta: "Asia/Calcutta",
        Chita: "Asia/Chita",
        Choibalsan: "Asia/Choibalsan",
        Chongqing: "Asia/Chongqing",
        Colombo: "Asia/Colombo",
        Dacca: "Asia/Dacca",
        Damascus: "Asia/Damascus",
        Dhaka: "Asia/Dhaka",
        Dili: "Asia/Dili",
        Dubai: "Asia/Dubai",
        Dushanbe: "Asia/Dushanbe",
        Gaza: "Asia/Gaza",
        Harbin: "Asia/Harbin",
        Hebron: "Asia/Hebron",
        "Ho Chi Minh": "Asia/Ho_Chi_Minh",
        "Hong Kong": "Asia/Hong_Kong",
        Hovd: "Asia/Hovd",
        Irkutsk: "Asia/Irkutsk",
        Istanbul: "Asia/Istanbul",
        Jakarta: "Asia/Jakarta",
        Jayapura: "Asia/Jayapura",
        Jerusalem: "Asia/Jerusalem",
        Kabul: "Asia/Kabul",
        Kamchatka: "Asia/Kamchatka",
        Karachi: "Asia/Karachi",
        Kashgar: "Asia/Kashgar",
        Kathmandu: "Asia/Kathmandu",
        Katmandu: "Asia/Katmandu",
        Khandyga: "Asia/Khandyga",
        Kolkata: "Asia/Kolkata",
        Krasnoyarsk: "Asia/Krasnoyarsk",
        "Kuala Lumpur": "Asia/Kuala_Lumpur",
        Kuching: "Asia/Kuching",
        Kuwait: "Asia/Kuwait",
        Macao: "Asia/Macao",
        Macau: "Asia/Macau",
        Magadan: "Asia/Magadan",
        Makassar: "Asia/Makassar",
        Manila: "Asia/Manila",
        Muscat: "Asia/Muscat",
        Nicosia: "Asia/Nicosia",
        Novokuznetsk: "Asia/Novokuznetsk",
        Novosibirsk: "Asia/Novosibirsk",
        Omsk: "Asia/Omsk",
        Oral: "Asia/Oral",
        "Phnom Penh": "Asia/Phnom_Penh",
        Pontianak: "Asia/Pontianak",
        Pyongyang: "Asia/Pyongyang",
        Qatar: "Asia/Qatar",
        Qyzylorda: "Asia/Qyzylorda",
        Rangoon: "Asia/Rangoon",
        Riyadh: "Asia/Riyadh",
        Saigon: "Asia/Saigon",
        Sakhalin: "Asia/Sakhalin",
        Samarkand: "Asia/Samarkand",
        Seoul: "Asia/Seoul",
        Shanghai: "Asia/Shanghai",
        Singapore: "Asia/Singapore",
        Srednekolymsk: "Asia/Srednekolymsk",
        Taipei: "Asia/Taipei",
        Tashkent: "Asia/Tashkent",
        Tbilisi: "Asia/Tbilisi",
        Tehran: "Asia/Tehran",
        "Tel Aviv": "Asia/Tel_Aviv",
        Thimbu: "Asia/Thimbu",
        Thimphu: "Asia/Thimphu",
        Tokyo: "Asia/Tokyo",
        "Ujung Pandang": "Asia/Ujung_Pandang",
        Ulaanbaatar: "Asia/Ulaanbaatar",
        "Ulan Bator": "Asia/Ulan_Bator",
        Urumqi: "Asia/Urumqi",
        "Ust-Nera": "Asia/Ust-Nera",
        Vientiane: "Asia/Vientiane",
        Vladivostok: "Asia/Vladivostok",
        Yakutsk: "Asia/Yakutsk",
        Yekaterinburg: "Asia/Yekaterinburg",
        Yerevan: "Asia/Yerevan",
      },

      Atlantic: {
        Azores: "Atlantic/Azores",
        Bermuda: "Atlantic/Bermuda",
        Canary: "Atlantic/Canary",
        "Cape Verde": "Atlantic/Cape_Verde",
        Faeroe: "Atlantic/Faeroe",
        Faroe: "Atlantic/Faroe",
        "Jan Mayen": "Atlantic/Jan_Mayen",
        Madeira: "Atlantic/Madeira",
        Reykjavik: "Atlantic/Reykjavik",
        "South Georgia": "Atlantic/South_Georgia",
        "St. Helena": "Atlantic/St_Helena",
        Stanley: "Atlantic/Stanley",
      },

      Australia: {
        Adelaide: "Australia/Adelaide",
        Brisbane: "Australia/Brisbane",
        "Broken Hill": "Australia/Broken_Hill",
        Canberra: "Australia/Canberra",
        Currie: "Australia/Currie",
        Darwin: "Australia/Darwin",
        Eucla: "Australia/Eucla",
        Hobart: "Australia/Hobart",
        Lindeman: "Australia/Lindeman",
        "Lord Howe": "Australia/Lord_Howe",
        Melbourne: "Australia/Melbourne",
        North: "Australia/North",
        Perth: "Australia/Perth",
        Queensland: "Australia/Queensland",
        South: "Australia/South",
        Sydney: "Australia/Sydney",
        Tasmania: "Australia/Tasmania",
        Victoria: "Australia/Victoria",
        West: "Australia/West",
        Yancowinna: "Australia/Yancowinna",
      },

      Brazil: {
        Acre: "Brazil/Acre",
        "Fernando de Noronha": "Brazil/DeNoronha",
        East: "Brazil/East",
        West: "Brazil/West",
      },

      Canada: {
        Atlantic: "Canada/Atlantic",
        Central: "Canada/Central",
        Eastern: "Canada/Eastern",
        Mountain: "Canada/Mountain",
        Newfoundland: "Canada/Newfoundland",
        Pacific: "Canada/Pacific",
        Saskatchewan: "Canada/Saskatchewan",
        Yukon: "Canada/Yukon",
      },

      Chile: {
        Continental: "Chile/Continental",
        "Easter Island": "Chile/EasterIsland",
      },

      Europe: {
        Amsterdam: "Europe/Amsterdam",
        Andorra: "Europe/Andorra",
        Athens: "Europe/Athens",
        Belfast: "Europe/Belfast",
        Belgrade: "Europe/Belgrade",
        Berlin: "Europe/Berlin",
        Bratislava: "Europe/Bratislava",
        Brussels: "Europe/Brussels",
        Bucharest: "Europe/Bucharest",
        Budapest: "Europe/Budapest",
        Busingen: "Europe/Busingen",
        Chisinau: "Europe/Chisinau",
        Copenhagen: "Europe/Copenhagen",
        Dublin: "Europe/Dublin",
        Gibraltar: "Europe/Gibraltar",
        Guernsey: "Europe/Guernsey",
        Helsinki: "Europe/Helsinki",
        "Isle of Man": "Europe/Isle_of_Man",
        Istanbul: "Europe/Istanbul",
        Jersey: "Europe/Jersey",
        Kaliningrad: "Europe/Kaliningrad",
        Kiev: "Europe/Kiev",
        Lisbon: "Europe/Lisbon",
        Ljubljana: "Europe/Ljubljana",
        London: "Europe/London",
        Luxembourg: "Europe/Luxembourg",
        Madrid: "Europe/Madrid",
        Malta: "Europe/Malta",
        Mariehamn: "Europe/Mariehamn",
        Minsk: "Europe/Minsk",
        Monaco: "Europe/Monaco",
        Moscow: "Europe/Moscow",
        Nicosia: "Europe/Nicosia",
        Oslo: "Europe/Oslo",
        Paris: "Europe/Paris",
        Podgorica: "Europe/Podgorica",
        Prague: "Europe/Prague",
        Riga: "Europe/Riga",
        Rome: "Europe/Rome",
        Samara: "Europe/Samara",
        "San Marino": "Europe/San_Marino",
        Sarajevo: "Europe/Sarajevo",
        Simferopol: "Europe/Simferopol",
        Skopje: "Europe/Skopje",
        Sofia: "Europe/Sofia",
        Stockholm: "Europe/Stockholm",
        Tallinn: "Europe/Tallinn",
        Tirane: "Europe/Tirane",
        Tiraspol: "Europe/Tiraspol",
        Uzhgorod: "Europe/Uzhgorod",
        Vaduz: "Europe/Vaduz",
        Vatican: "Europe/Vatican",
        Vienna: "Europe/Vienna",
        Vilnius: "Europe/Vilnius",
        Volgograd: "Europe/Volgograd",
        Warsaw: "Europe/Warsaw",
        Zagreb: "Europe/Zagreb",
        Zaporozhye: "Europe/Zaporozhye",
        Zurich: "Europe/Zurich",
      },

      GMT: {
        "GMT-14": "Etc/GMT-14",
        "GMT-13": "Etc/GMT-13",
        "GMT-12": "Etc/GMT-12",
        "GMT-11": "Etc/GMT-11",
        "GMT-10": "Etc/GMT-10",
        "GMT-9": "Etc/GMT-9",
        "GMT-8": "Etc/GMT-8",
        "GMT-7": "Etc/GMT-7",
        "GMT-6": "Etc/GMT-6",
        "GMT-5": "Etc/GMT-5",
        "GMT-4": "Etc/GMT-4",
        "GMT-3": "Etc/GMT-3",
        "GMT-2": "Etc/GMT-2",
        "GMT-1": "Etc/GMT-1",
        "GMT+0": "Etc/GMT+0",
        "GMT+1": "Etc/GMT+1",
        "GMT+2": "Etc/GMT+2",
        "GMT+3": "Etc/GMT+3",
        "GMT+4": "Etc/GMT+4",
        "GMT+5": "Etc/GMT+5",
        "GMT+6": "Etc/GMT+6",
        "GMT+7": "Etc/GMT+7",
        "GMT+8": "Etc/GMT+8",
        "GMT+9": "Etc/GMT+9",
        "GMT+10": "Etc/GMT+10",
        "GMT+11": "Etc/GMT+11",
        "GMT+12": "Etc/GMT+12",
      },

      Indian: {
        Antananarivo: "Indian/Antananarivo",
        Chagos: "Indian/Chagos",
        Christmas: "Indian/Christmas",
        Cocos: "Indian/Cocos",
        Comoro: "Indian/Comoro",
        Kerguelen: "Indian/Kerguelen",
        Mahe: "Indian/Mahe",
        Maldives: "Indian/Maldives",
        Mauritius: "Indian/Mauritius",
        Mayotte: "Indian/Mayotte",
        Reunion: "Indian/Reunion",
      },

      Mexico: {
        "Baja Norte": "Mexico/BajaNorte",
        "Baja Sur": "Mexico/BajaSur",
        General: "Mexico/General",
      },

      Pacific: {
        Apia: "Pacific/Apia",
        Auckland: "Pacific/Auckland",
        Bougainville: "Pacific/Bougainville",
        Chatham: "Pacific/Chatham",
        Chuuk: "Pacific/Chuuk",
        Easter: "Pacific/Easter",
        Efate: "Pacific/Efate",
        Enderbury: "Pacific/Enderbury",
        Fakaofo: "Pacific/Fakaofo",
        Fiji: "Pacific/Fiji",
        Funafuti: "Pacific/Funafuti",
        Galapagos: "Pacific/Galapagos",
        Gambier: "Pacific/Gambier",
        Guadalcanal: "Pacific/Guadalcanal",
        Guam: "Pacific/Guam",
        Honolulu: "Pacific/Honolulu",
        Johnston: "Pacific/Johnston",
        Kiritimati: "Pacific/Kiritimati",
        Kosrae: "Pacific/Kosrae",
        Kwajalein: "Pacific/Kwajalein",
        Majuro: "Pacific/Majuro",
        Marquesas: "Pacific/Marquesas",
        Midway: "Pacific/Midway",
        Nauru: "Pacific/Nauru",
        Niue: "Pacific/Niue",
        Norfolk: "Pacific/Norfolk",
        Noumea: "Pacific/Noumea",
        "Pago Pago": "Pacific/Pago_Pago",
        Palau: "Pacific/Palau",
        Pitcairn: "Pacific/Pitcairn",
        Pohnpei: "Pacific/Pohnpei",
        Ponape: "Pacific/Ponape",
        "Port Moresby": "Pacific/Port_Moresby",
        Rarotonga: "Pacific/Rarotonga",
        Saipan: "Pacific/Saipan",
        Samoa: "Pacific/Samoa",
        Tahiti: "Pacific/Tahiti",
        Tarawa: "Pacific/Tarawa",
        Tongatapu: "Pacific/Tongatapu",
        Truk: "Pacific/Truk",
        Wake: "Pacific/Wake",
        Wallis: "Pacific/Wallis",
        Yap: "Pacific/Yap",
      },
    };

    /**
     * All selectable regions.
     *
     * @type String[]
     */
    $scope.regions = (function collectRegions() {
      // Start with blank entry
      var regions = [""];

      // Add each available region
      for (var region in $scope.timeZones) regions.push(region);

      return regions;
    })();

    /**
     * Direct mapping of all time zone IDs to the region containing that ID.
     *
     * @type Object.<String, String>
     */
    var timeZoneRegions = (function mapRegions() {
      var regions = {};

      // For each available region
      for (var region in $scope.timeZones) {
        // Get time zones within that region
        var timeZonesInRegion = $scope.timeZones[region];

        // For each of those time zones
        for (var timeZoneName in timeZonesInRegion) {
          // Get corresponding ID
          var timeZoneID = timeZonesInRegion[timeZoneName];

          // Store region in map
          regions[timeZoneID] = region;
        }
      }

      return regions;
    })();

    /**
     * Map of regions to the currently selected time zone for that region.
     * Initially, all regions will be set to default selections (the first
     * time zone, sorted lexicographically).
     *
     * @type Object.<String, String>
     */
    var selectedTimeZone = (function produceDefaultTimeZones() {
      var defaultTimeZone = {};

      // For each available region
      for (var region in $scope.timeZones) {
        // Get time zones within that region
        var timeZonesInRegion = $scope.timeZones[region];

        // No default initially
        var defaultZoneName = null;
        var defaultZoneID = null;

        // For each of those time zones
        for (var timeZoneName in timeZonesInRegion) {
          // Get corresponding ID
          var timeZoneID = timeZonesInRegion[timeZoneName];

          // Set as default if earlier than existing default
          if (!defaultZoneName || timeZoneName < defaultZoneName) {
            defaultZoneName = timeZoneName;
            defaultZoneID = timeZoneID;
          }
        }

        // Store default zone
        defaultTimeZone[region] = defaultZoneID;
      }

      return defaultTimeZone;
    })();

    /**
     * The name of the region currently selected. The selected region narrows
     * which time zones are selectable.
     *
     * @type String
     */
    $scope.region = "";

    // Ensure corresponding region is selected
    $scope.$watch("model", function setModel(model) {
      $scope.region = timeZoneRegions[model] || "";
      selectedTimeZone[$scope.region] = model;
    });

    // Restore time zone selection when region changes
    $scope.$watch("region", function restoreSelection(region) {
      $scope.model = selectedTimeZone[region] || null;
    });
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive that allows editing of a collection of fields.
 */
angular.module("form").directive("guacForm", [
  function form() {
    return {
      // Element only
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The translation namespace of the translation strings that will
         * be generated for all fields. This namespace is absolutely
         * required. If this namespace is omitted, all generated
         * translation strings will be placed within the MISSING_NAMESPACE
         * namespace, as a warning.
         *
         * @type String
         */
        namespace: "=",

        /**
         * The form content to display. This may be a form, an array of
         * forms, or a simple array of fields.
         *
         * @type Form[]|Form|Field[]|Field
         */
        content: "=",

        /**
         * The object which will receive all field values. Each field value
         * will be assigned to the property of this object having the same
         * name.
         *
         * @type Object.<String, String>
         */
        model: "=",

        /**
         * Whether the contents of the form should be restricted to those
         * fields/forms which match properties defined within the given
         * model object. By default, all fields will be shown.
         *
         * @type Boolean
         */
        modelOnly: "=",

        /**
         * Whether the contents of the form should be rendered as disabled.
         * By default, form fields are enabled.
         *
         * @type Boolean
         */
        disabled: "=",

        /**
         * The name of the field to be focused, if any.
         *
         * @type String
         */
        focused: "=",
      },
      templateUrl: "app/form/templates/form.html",
      controller: [
        "$scope",
        "$injector",
        function formController($scope, $injector) {
          // Required services
          var translationStringService = $injector.get(
            "translationStringService"
          );

          /**
           * The array of all forms to display.
           *
           * @type Form[]
           */
          $scope.forms = [];

          /**
           * The object which will receive all field values. Normally, this
           * will be the object provided within the "model" attribute. If
           * no such object has been provided, a blank model will be used
           * instead as a placeholder, such that the fields of this form
           * will have something to bind to.
           *
           * @type Object.<String, String>
           */
          $scope.values = {};

          /**
           * Produces the translation string for the section header of the
           * given form. The translation string will be of the form:
           *
           * <code>NAMESPACE.SECTION_HEADER_NAME<code>
           *
           * where <code>NAMESPACE</code> is the namespace provided to the
           * directive and <code>NAME</code> is the form name transformed
           * via translationStringService.canonicalize().
           *
           * @param {Form} form
           *     The form for which to produce the translation string.
           *
           * @returns {String}
           *     The translation string which produces the translated header
           *     of the form.
           */
          $scope.getSectionHeader = function getSectionHeader(form) {
            // If no form, or no name, then no header
            if (!form || !form.name) return "";

            return (
              translationStringService.canonicalize(
                $scope.namespace || "MISSING_NAMESPACE"
              ) +
              ".SECTION_HEADER_" +
              translationStringService.canonicalize(form.name)
            );
          };

          /**
           * Determines whether the given object is a form, under the
           * assumption that the object is either a form or a field.
           *
           * @param {Form|Field} obj
           *     The object to test.
           *
           * @returns {Boolean}
           *     true if the given object appears to be a form, false
           *     otherwise.
           */
          var isForm = function isForm(obj) {
            return !!("name" in obj && "fields" in obj);
          };

          // Produce set of forms from any given content
          $scope.$watch("content", function setContent(content) {
            // If no content provided, there are no forms
            if (!content) {
              $scope.forms = [];
              return;
            }

            // Ensure content is an array
            if (!angular.isArray(content)) content = [content];

            // If content is an array of fields, convert to an array of forms
            if (content.length && !isForm(content[0])) {
              content = [
                {
                  fields: content,
                },
              ];
            }

            // Content is now an array of forms
            $scope.forms = content;
          });

          // Update string value and re-assign to model when field is changed
          $scope.$watch("model", function setModel(model) {
            // Assign new model only if provided
            if (model) $scope.values = model;
            // Otherwise, use blank model
            else $scope.values = {};
          });

          /**
           * Returns whether the given field should be focused or not.
           *
           * @param {Field} field
           *     The field to check.
           *
           * @returns {Boolean}
           *     true if the given field should be focused, false otherwise.
           */
          $scope.isFocused = function isFocused(field) {
            return field && field.name === $scope.focused;
          };

          /**
           * Returns whether the given field should be displayed to the
           * current user.
           *
           * @param {Field} field
           *     The field to check.
           *
           * @returns {Boolean}
           *     true if the given field should be visible, false otherwise.
           */
          $scope.isVisible = function isVisible(field) {
            // All fields are visible if contents are not restricted to
            // model properties only
            if (!$scope.modelOnly) return true;

            // Otherwise, fields are only visible if they are present
            // within the model
            return field && field.name in $scope.values;
          };

          /**
           * Returns whether at least one of the given fields should be
           * displayed to the current user.
           *
           * @param {Field[]} fields
           *     The array of fields to check.
           *
           * @returns {Boolean}
           *     true if at least one field within the given array should be
           *     visible, false otherwise.
           */
          $scope.containsVisible = function containsVisible(fields) {
            // If fields are defined, check whether at least one is visible
            if (fields) {
              for (var i = 0; i < fields.length; i++) {
                if ($scope.isVisible(fields[i])) return true;
              }
            }

            // Otherwise, there are no visible fields
            return false;
          };
        },
      ], // end controller
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive that allows editing of a field.
 */
angular.module("form").directive("guacFormField", [
  function formField() {
    return {
      // Element only
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The translation namespace of the translation strings that will
         * be generated for this field. This namespace is absolutely
         * required. If this namespace is omitted, all generated
         * translation strings will be placed within the MISSING_NAMESPACE
         * namespace, as a warning.
         *
         * @type String
         */
        namespace: "=",

        /**
         * The field to display.
         *
         * @type Field
         */
        field: "=",

        /**
         * The property which contains this fields current value. When this
         * field changes, the property will be updated accordingly.
         *
         * @type String
         */
        model: "=",

        /**
         * Whether this field should be rendered as disabled. By default,
         * form fields are enabled.
         *
         * @type Boolean
         */
        disabled: "=",

        /**
         * Whether this field should be focused.
         *
         * @type Boolean
         */
        focused: "=",
      },
      templateUrl: "app/form/templates/formField.html",
      controller: [
        "$scope",
        "$injector",
        "$element",
        function formFieldController($scope, $injector, $element) {
          // Required services
          var $log = $injector.get("$log");
          var formService = $injector.get("formService");
          var translationStringService = $injector.get(
            "translationStringService"
          );

          /**
           * The element which should contain any compiled field content. The
           * actual content of a field is dynamically determined by its type.
           *
           * @type Element[]
           */
          var fieldContent = $element.find(".form-field");

          /**
           * An ID value which is reasonably likely to be unique relative to
           * other elements on the page. This ID should be used to associate
           * the relevant input element with the label provided by the
           * guacFormField directive, if there is such an input element.
           *
           * @type String
           */
          $scope.fieldId =
            "guac-field-XXXXXXXXXXXXXXXX".replace(
              /X/g,
              function getRandomCharacter() {
                return Math.floor(Math.random() * 36).toString(36);
              }
            ) +
            "-" +
            new Date().getTime().toString(36);

          /**
           * Produces the translation string for the header of the current
           * field. The translation string will be of the form:
           *
           * <code>NAMESPACE.FIELD_HEADER_NAME<code>
           *
           * where <code>NAMESPACE</code> is the namespace provided to the
           * directive and <code>NAME</code> is the field name transformed
           * via translationStringService.canonicalize().
           *
           * @returns {String}
           *     The translation string which produces the translated header
           *     of the field.
           */
          $scope.getFieldHeader = function getFieldHeader() {
            // If no field, or no name, then no header
            if (!$scope.field || !$scope.field.name) return "";

            return (
              translationStringService.canonicalize(
                $scope.namespace || "MISSING_NAMESPACE"
              ) +
              ".FIELD_HEADER_" +
              translationStringService.canonicalize($scope.field.name)
            );
          };

          /**
           * Produces the translation string for the given field option
           * value. The translation string will be of the form:
           *
           * <code>NAMESPACE.FIELD_OPTION_NAME_VALUE<code>
           *
           * where <code>NAMESPACE</code> is the namespace provided to the
           * directive, <code>NAME</code> is the field name transformed
           * via translationStringService.canonicalize(), and
           * <code>VALUE</code> is the option value transformed via
           * translationStringService.canonicalize()
           *
           * @param {String} value
           *     The name of the option value.
           *
           * @returns {String}
           *     The translation string which produces the translated name of the
           *     value specified.
           */
          $scope.getFieldOption = function getFieldOption(value) {
            // If no field, or no value, then no corresponding translation string
            if (!$scope.field || !$scope.field.name) return "";

            return (
              translationStringService.canonicalize(
                $scope.namespace || "MISSING_NAMESPACE"
              ) +
              ".FIELD_OPTION_" +
              translationStringService.canonicalize($scope.field.name) +
              "_" +
              translationStringService.canonicalize(value || "EMPTY")
            );
          };

          /**
           * Returns whether the current field should be displayed.
           *
           * @returns {Boolean}
           *     true if the current field should be displayed, false
           *     otherwise.
           */
          $scope.isFieldVisible = function isFieldVisible() {
            return fieldContent[0].hasChildNodes();
          };

          // Update field contents when field definition is changed
          $scope.$watch("field", function setField(field) {
            // Reset contents
            fieldContent.innerHTML = "";

            // Append field content
            if (field) {
              formService
                .insertFieldElement(fieldContent[0], field.type, $scope)
                ["catch"](function fieldCreationFailed() {
                  $log.warn(
                    'Failed to retrieve field with type "' + field.type + '"'
                  );
                });
            }
          });
        },
      ], // end controller
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which implements a color input field. If the underlying color
 * picker implementation cannot be used due to a lack of browser support, this
 * directive will become read-only, functioning essentially as a color preview.
 *
 * @see colorPickerService
 */
angular.module("form").directive("guacInputColor", [
  function guacInputColor() {
    var config = {
      restrict: "E",
      replace: true,
      templateUrl: "app/form/templates/guacInputColor.html",
      transclude: true,
    };

    config.scope = {
      /**
       * The current selected color value, in standard 6-digit hexadecimal
       * RGB notation. When the user selects a different color using this
       * directive, this value will updated accordingly.
       *
       * @type String
       */
      model: "=",

      /**
       * An optional array of colors to include within the color picker as a
       * convenient selection of pre-defined colors. The colors within the
       * array must be in standard 6-digit hexadecimal RGB notation.
       *
       * @type String[]
       */
      palette: "=",
    };

    config.controller = [
      "$scope",
      "$element",
      "$injector",
      function guacInputColorController($scope, $element, $injector) {
        // Required services
        var colorPickerService = $injector.get("colorPickerService");

        /**
         * @borrows colorPickerService.isAvailable()
         */
        $scope.isColorPickerAvailable = colorPickerService.isAvailable;

        /**
         * Returns whether the color currently selected is "dark" in the sense
         * that the color white will have higher contrast against it than the
         * color black.
         *
         * @returns {Boolean}
         *     true if the currently selected color is relatively dark (white
         *     text would provide better contrast than black), false otherwise.
         */
        $scope.isDark = function isDark() {
          // Assume not dark if color is invalid or undefined
          var rgb =
            $scope.model &&
            /^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/.exec(
              $scope.model
            );
          if (!rgb) return false;

          // Parse color component values as hexadecimal
          var red = parseInt(rgb[1], 16);
          var green = parseInt(rgb[2], 16);
          var blue = parseInt(rgb[3], 16);

          // Convert RGB to luminance in HSL space (as defined by the
          // relative luminance formula given by the W3C for accessibility)
          var luminance = 0.2126 * red + 0.7152 * green + 0.0722 * blue;

          // Consider the background to be dark if white text over that
          // background would provide better contrast than black
          return luminance <= 153; // 153 is the component value 0.6 converted from 0-1 to the 0-255 range
        };

        /**
         * Prompts the user to choose a color by displaying a color selection
         * dialog. If the user chooses a color, this directive's model is
         * automatically updated. If the user cancels the dialog, the model is
         * left untouched.
         */
        $scope.selectColor = function selectColor() {
          colorPickerService
            .selectColor($element[0], $scope.model, $scope.palette)
            .then(function colorSelected(color) {
              $scope.model = color;
            }, angular.noop);
        };
      },
    ];

    return config;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which modifies the parsing and formatting of ngModel when used
 * on an HTML5 date input field, relaxing the otherwise strict parsing and
 * validation behavior. The behavior of this directive for other input elements
 * is undefined.
 */
angular.module("form").directive("guacLenientDate", [
  "$injector",
  function guacLenientDate($injector) {
    // Required services
    var $filter = $injector.get("$filter");

    /**
     * Directive configuration object.
     *
     * @type Object.<String, Object>
     */
    var config = {
      restrict: "A",
      require: "ngModel",
    };

    // Linking function
    config.link = function linkGuacLenientDate(
      $scope,
      $element,
      $attrs,
      ngModel
    ) {
      // Parse date strings leniently
      ngModel.$parsers = [
        function parse(viewValue) {
          // If blank, return null
          if (!viewValue) return null;

          // Match basic date pattern
          var match = /([0-9]*)(?:-([0-9]*)(?:-([0-9]*))?)?/.exec(viewValue);
          if (!match) return null;

          // Determine year, month, and day based on pattern
          var year = parseInt(match[1] || "0") || new Date().getFullYear();
          var month = parseInt(match[2] || "0") || 1;
          var day = parseInt(match[3] || "0") || 1;

          // Convert to Date object
          var parsedDate = new Date(Date.UTC(year, month - 1, day));
          if (isNaN(parsedDate.getTime())) return null;

          return parsedDate;
        },
      ];

      // Format date strings as "yyyy-MM-dd"
      ngModel.$formatters = [
        function format(modelValue) {
          return modelValue
            ? $filter("date")(modelValue, "yyyy-MM-dd", "UTC")
            : "";
        },
      ];
    };

    return config;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which modifies the parsing and formatting of ngModel when used
 * on an HTML5 time input field, relaxing the otherwise strict parsing and
 * validation behavior. The behavior of this directive for other input elements
 * is undefined.
 */
angular.module("form").directive("guacLenientTime", [
  "$injector",
  function guacLenientTime($injector) {
    // Required services
    var $filter = $injector.get("$filter");

    /**
     * Directive configuration object.
     *
     * @type Object.<String, Object>
     */
    var config = {
      restrict: "A",
      require: "ngModel",
    };

    // Linking function
    config.link = function linkGuacLenientTIme(
      $scope,
      $element,
      $attrs,
      ngModel
    ) {
      // Parse time strings leniently
      ngModel.$parsers = [
        function parse(viewValue) {
          // If blank, return null
          if (!viewValue) return null;

          // Match basic time pattern
          var match = /([0-9]*)(?::([0-9]*)(?::([0-9]*))?)?(?:\s*(a|p))?/.exec(
            viewValue.toLowerCase()
          );
          if (!match) return null;

          // Determine hour, minute, and second based on pattern
          var hour = parseInt(match[1] || "0");
          var minute = parseInt(match[2] || "0");
          var second = parseInt(match[3] || "0");

          // Handle AM/PM
          if (match[4]) {
            // Interpret 12 AM as 00:00 and 12 PM as 12:00
            if (hour === 12) hour = 0;

            // Increment hour to evening if PM
            if (match[4] === "p") hour += 12;
          }

          // Wrap seconds and minutes into minutes and hours
          minute += second / 60;
          second %= 60;
          hour += minute / 60;
          minute %= 60;

          // Constrain hours to 0 - 23
          hour %= 24;

          // Convert to Date object
          var parsedDate = new Date(Date.UTC(1970, 0, 1, hour, minute, second));
          if (isNaN(parsedDate.getTime())) return null;

          return parsedDate;
        },
      ];

      // Format time strings as "HH:mm:ss"
      ngModel.$formatters = [
        function format(modelValue) {
          return modelValue
            ? $filter("date")(modelValue, "HH:mm:ss", "UTC")
            : "";
        },
      ];
    };

    return config;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Module for displaying dynamic forms.
 */
angular.module("form", ["locale", "rest"]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for prompting the user to choose a color using the "Pickr" color
 * picker. As the Pickr color picker might not be available if the JavaScript
 * features it requires are not supported by the browser (Internet Explorer),
 * the isAvailable() function should be used to test for usability.
 */
angular
  .module("form")
  .provider("colorPickerService", function colorPickerServiceProvider() {
    /**
     * A singleton instance of the "Pickr" color picker, shared by all users of
     * this service. Pickr does not initialize synchronously, nor is it
     * supported by all browsers. If Pickr is not yet initialized, or is
     * unsupported, this will be null.
     *
     * @type {Pickr}
     */
    var pickr = null;

    /**
     * Whether Pickr has completed initialization.
     *
     * @type {Boolean}
     */
    var pickrInitComplete = false;

    /**
     * The HTML element to provide to Pickr as the root element.
     *
     * @type {HTMLDivElement}
     */
    var pickerContainer = document.createElement("div");
    pickerContainer.className = "shared-color-picker";

    /**
     * An instance of Deferred which represents an active request for the
     * user to choose a color. The promise associated with the Deferred will
     * be resolved with the chosen color once a color is chosen, and rejected
     * if the request is cancelled or Pickr is not available. If no request is
     * active, this will be null.
     *
     * @type {Deferred}
     */
    var activeRequest = null;

    /**
     * Resolves the current active request with the given color value. If no
     * color value is provided, the active request is rejected. If no request
     * is active, this function has no effect.
     *
     * @param {String} [color]
     *     The color value to resolve the active request with.
     */
    var completeActiveRequest = function completeActiveRequest(color) {
      if (activeRequest) {
        // Hide color picker, if shown
        pickr.hide();

        // Resolve/reject active request depending on value provided
        if (color) activeRequest.resolve(color);
        else activeRequest.reject();

        // No active request
        activeRequest = null;
      }
    };

    try {
      pickr = Pickr.create({
        // Bind color picker to the container element
        el: pickerContainer,

        // Wrap color picker dialog in Guacamole-specific class for
        // sake of additional styling
        appClass: "guac-input-color-picker",

        default: "#000000",

        // Display color details as hex
        defaultRepresentation: "HEX",

        // Use "monolith" theme, as a nice balance between "nano" (does
        // not work in Internet Explorer) and "classic" (too big)
        theme: "monolith",

        // Leverage the container element as the button which shows the
        // picker, relying on our own styling for that button
        useAsButton: true,
        appendToBody: true,

        // Do not include opacity controls
        lockOpacity: true,

        // Include a selection of palette entries for convenience and
        // reference
        swatches: [],

        components: {
          // Include hue and color preview controls
          preview: true,
          hue: true,

          // Display only a text color input field and the save and
          // cancel buttons (no clear button)
          interaction: {
            input: true,
            save: true,
            cancel: true,
          },
        },
      });

      // Hide color picker after user clicks "cancel"
      pickr.on("cancel", function colorChangeCanceled() {
        completeActiveRequest();
      });

      // Keep model in sync with changes to the color picker
      pickr.on("save", function colorChanged(color) {
        completeActiveRequest(color.toHEXA().toString());
        activeRequest = null;
      });

      // Keep color picker in sync with changes to the model
      pickr.on("init", function pickrReady() {
        pickrInitComplete = true;
      });
    } catch (e) {
      // If the "Pickr" color picker cannot be loaded (Internet Explorer),
      // the available flag will remain set to false
    }

    // Factory method required by provider
    this.$get = [
      "$injector",
      function colorPickerServiceFactory($injector) {
        // Required services
        var $q = $injector.get("$q");
        var $translate = $injector.get("$translate");

        var service = {};

        /**
         * Promise which is resolved when Pickr initialization has completed
         * and rejected if Pickr cannot be used.
         *
         * @type {Promise}
         */
        var pickrPromise = (function getPickr() {
          var deferred = $q.defer();

          // Resolve promise when Pickr has completed initialization
          if (pickrInitComplete) deferred.resolve();
          else if (pickr) pickr.on("init", deferred.resolve);
          // Reject promise if Pickr cannot be used at all
          else deferred.reject();

          return deferred.promise;
        })();

        /**
         * Returns whether the underlying color picker (Pickr) can be used by
         * calling selectColor(). If the browser cannot support the color
         * picker, false is returned.
         *
         * @returns {Boolean}
         *     true if the underlying color picker can be used by calling
         *     selectColor(), false otherwise.
         */
        service.isAvailable = function isAvailable() {
          return !!pickr;
        };

        /**
         * Prompts the user to choose a color, returning the color chosen via a
         * Promise.
         *
         * @param {Element} element
         *     The element that the user interacted with to indicate their
         *     desire to choose a color.
         *
         * @param {String} current
         *     The color that should be selected by default, in standard
         *     6-digit hexadecimal RGB format, including "#" prefix.
         *
         * @param {String[]} [palette]
         *     An array of color choices which should be exposed to the user
         *     within the color chooser for convenience. Each color must be in
         *     standard 6-digit hexadecimal RGB format, including "#" prefix.
         *
         * @returns {Promise.<String>}
         *     A Promise which is resolved with the color chosen by the user,
         *     in standard 6-digit hexadecimal RGB format with "#" prefix, and
         *     rejected if the selection operation was cancelled or the color
         *     picker cannot be used.
         */
        service.selectColor = function selectColor(element, current, palette) {
          // Show picker once the relevant translation strings have been
          // retrieved and Pickr is ready for use
          return $q
            .all({
              saveString: $translate("APP.ACTION_SAVE"),
              cancelString: $translate("APP.ACTION_CANCEL"),
              pickr: pickrPromise,
            })
            .then(function dependenciesReady(deps) {
              // Cancel any active request
              completeActiveRequest();

              // Reset state of color picker to provided parameters
              pickr.setColor(current);
              element.appendChild(pickerContainer);

              // Assign translated strings to button text
              var pickrRoot = pickr.getRoot();
              pickrRoot.interaction.save.value = deps.saveString;
              pickrRoot.interaction.cancel.value = deps.cancelString;

              // Replace all color swatches with the palette of colors given
              while (pickr.removeSwatch(0)) {}
              angular.forEach(palette, pickr.addSwatch.bind(pickr));

              // Show color picker and wait for user to complete selection
              activeRequest = $q.defer();
              pickr.show();
              return activeRequest.promise;
            });
        };

        return service;
      },
    ];
  });
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for maintaining form-related metadata and linking that data to
 * corresponding controllers and templates.
 */
angular.module("form").provider("formService", function formServiceProvider() {
  /**
   * Reference to the provider itself.
   *
   * @type formServiceProvider
   */
  var provider = this;

  /**
   * Map of all registered field type definitions by name.
   *
   * @type Object.<String, FieldType>
   */
  this.fieldTypes = {
    /**
     * Text field type.
     *
     * @see {@link Field.Type.TEXT}
     * @type FieldType
     */
    TEXT: {
      module: "form",
      controller: "textFieldController",
      templateUrl: "app/form/templates/textField.html",
    },

    /**
     * Email address field type.
     *
     * @see {@link Field.Type.EMAIL}
     * @type FieldType
     */
    EMAIL: {
      templateUrl: "app/form/templates/emailField.html",
    },

    /**
     * Numeric field type.
     *
     * @see {@link Field.Type.NUMERIC}
     * @type FieldType
     */
    NUMERIC: {
      module: "form",
      controller: "numberFieldController",
      templateUrl: "app/form/templates/numberField.html",
    },

    /**
     * Boolean field type.
     *
     * @see {@link Field.Type.BOOLEAN}
     * @type FieldType
     */
    BOOLEAN: {
      module: "form",
      controller: "checkboxFieldController",
      templateUrl: "app/form/templates/checkboxField.html",
    },

    /**
     * Username field type. Identical in principle to a text field, but may
     * have different semantics.
     *
     * @see {@link Field.Type.USERNAME}
     * @type FieldType
     */
    USERNAME: {
      templateUrl: "app/form/templates/textField.html",
    },

    /**
     * Password field type. Similar to a text field, but the contents of
     * the field are masked.
     *
     * @see {@link Field.Type.PASSWORD}
     * @type FieldType
     */
    PASSWORD: {
      module: "form",
      controller: "passwordFieldController",
      templateUrl: "app/form/templates/passwordField.html",
    },

    /**
     * Enumerated field type. The user is presented a finite list of values
     * to choose from.
     *
     * @see {@link Field.Type.ENUM}
     * @type FieldType
     */
    ENUM: {
      module: "form",
      controller: "selectFieldController",
      templateUrl: "app/form/templates/selectField.html",
    },

    /**
     * Multiline field type. The user may enter multiple lines of text.
     *
     * @see {@link Field.Type.MULTILINE}
     * @type FieldType
     */
    MULTILINE: {
      templateUrl: "app/form/templates/textAreaField.html",
    },

    /**
     * Field type which allows selection of languages. The languages
     * displayed are the set of languages supported by the Guacamole web
     * application. Legal values are valid language IDs, as dictated by
     * the filenames of Guacamole's available translations.
     *
     * @see {@link Field.Type.LANGUAGE}
     * @type FieldType
     */
    LANGUAGE: {
      module: "form",
      controller: "languageFieldController",
      templateUrl: "app/form/templates/languageField.html",
    },

    /**
     * Field type which allows selection of time zones.
     *
     * @see {@link Field.Type.TIMEZONE}
     * @type FieldType
     */
    TIMEZONE: {
      module: "form",
      controller: "timeZoneFieldController",
      templateUrl: "app/form/templates/timeZoneField.html",
    },

    /**
     * Field type which allows selection of individual dates.
     *
     * @see {@link Field.Type.DATE}
     * @type FieldType
     */
    DATE: {
      module: "form",
      controller: "dateFieldController",
      templateUrl: "app/form/templates/dateField.html",
    },

    /**
     * Field type which allows selection of times of day.
     *
     * @see {@link Field.Type.TIME}
     * @type FieldType
     */
    TIME: {
      module: "form",
      controller: "timeFieldController",
      templateUrl: "app/form/templates/timeField.html",
    },

    /**
     * Field type which allows selection of color schemes accepted by the
     * Guacamole server terminal emulator and protocols which leverage it.
     *
     * @see {@link Field.Type.TERMINAL_COLOR_SCHEME}
     * @type FieldType
     */
    TERMINAL_COLOR_SCHEME: {
      module: "form",
      controller: "terminalColorSchemeFieldController",
      templateUrl: "app/form/templates/terminalColorSchemeField.html",
    },

    /**
     * Field type that supports redirecting the client browser to another
     * URL.
     *
     * @see {@link Field.Type.REDIRECT}
     * @type FieldType
     */
    REDIRECT: {
      module: "form",
      controller: "redirectFieldController",
      templateUrl: "app/form/templates/redirectField.html",
    },
  };

  /**
   * Registers a new field type under the given name.
   *
   * @param {String} fieldTypeName
   *     The name which uniquely identifies the field type being registered.
   *
   * @param {FieldType} fieldType
   *     The field type definition to associate with the given name.
   */
  this.registerFieldType = function registerFieldType(
    fieldTypeName,
    fieldType
  ) {
    // Store field type
    provider.fieldTypes[fieldTypeName] = fieldType;
  };

  // Factory method required by provider
  this.$get = [
    "$injector",
    function formServiceFactory($injector) {
      // Required services
      var $compile = $injector.get("$compile");
      var $q = $injector.get("$q");
      var $templateRequest = $injector.get("$templateRequest");

      /**
       * Map of module name to the injector instance created for that module.
       *
       * @type {Object.<String, injector>}
       */
      var injectors = {};

      var service = {};

      service.fieldTypes = provider.fieldTypes;

      /**
       * Given the name of a module, returns an injector instance which
       * injects dependencies within that module. A new injector may be
       * created and initialized if no such injector has yet been requested.
       * If the injector available to formService already includes the
       * requested module, that injector will simply be returned.
       *
       * @param {String} module
       *     The name of the module to produce an injector for.
       *
       * @returns {injector}
       *     An injector instance which injects dependencies for the given
       *     module.
       */
      var getInjector = function getInjector(module) {
        // Use the formService's injector if possible
        if ($injector.modules[module]) return $injector;

        // If the formService's injector does not include the requested
        // module, create the necessary injector, reusing that injector for
        // future calls
        injectors[module] =
          injectors[module] || angular.injector(["ng", module]);
        return injectors[module];
      };

      /**
       * Compiles and links the field associated with the given name to the given
       * scope, producing a distinct and independent DOM Element which functions
       * as an instance of that field. The scope object provided must include at
       * least the following properties:
       *
       * namespace:
       *     A String which defines the unique namespace associated the
       *     translation strings used by the form using a field of this type.
       *
       * fieldId:
       *     A String value which is reasonably likely to be unique and may
       *     be used to associate the main element of the field with its
       *     label.
       *
       * field:
       *     The Field object that is being rendered, representing a field of
       *     this type.
       *
       * model:
       *     The current String value of the field, if any.
       *
       * disabled:
       *     A boolean value which is true if the field should be disabled.
       *     If false or undefined, the field should be enabled.
       *
       * @param {Element} fieldContainer
       *     The DOM Element whose contents should be replaced with the
       *     compiled field template.
       *
       * @param {String} fieldTypeName
       *     The name of the field type defining the nature of the element to be
       *     created.
       *
       * @param {Object} scope
       *     The scope to which the new element will be linked.
       *
       * @return {Promise.<Element>}
       *     A Promise which resolves to the compiled Element. If an error occurs
       *     while retrieving the field type, this Promise will be rejected.
       */
      service.insertFieldElement = function insertFieldElement(
        fieldContainer,
        fieldTypeName,
        scope
      ) {
        // Ensure field type is defined
        var fieldType = provider.fieldTypes[fieldTypeName];
        if (!fieldType) return $q.reject();

        var templateRequest;

        // Use raw HTML template if provided
        if (fieldType.template) {
          var deferredTemplate = $q.defer();
          deferredTemplate.resolve(fieldType.template);
          templateRequest = deferredTemplate.promise;
        }

        // If no raw HTML template is provided, retrieve template from URL
        else if (fieldType.templateUrl)
          templateRequest = $templateRequest(fieldType.templateUrl);
        // Otherwise, use empty template
        else {
          var emptyTemplate = $q.defer();
          emptyTemplate.resolve("");
          templateRequest = emptyTemplate.promise;
        }

        // Defer compilation of template pending successful retrieval
        var compiledTemplate = $q.defer();

        // Resolve with compiled HTML upon success
        templateRequest
          .then(function templateRetrieved(html) {
            // Insert template into DOM
            fieldContainer.innerHTML = html;

            // Populate scope using defined controller
            if (fieldType.module && fieldType.controller) {
              var $controller = getInjector(fieldType.module).get(
                "$controller"
              );
              $controller(fieldType.controller, {
                $scope: scope,
                $element: angular.element(fieldContainer.childNodes),
              });
            }

            // Compile DOM with populated scope
            compiledTemplate.resolve(
              $compile(fieldContainer.childNodes)(scope)
            );
          })

          [
            // Reject on failure
            "catch"
          ](function templateError() {
            compiledTemplate.reject();
          });

        // Return promise which resolves to the compiled template
        return compiledTemplate.promise;
      };

      return service;
    },
  ];
});

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the ColorScheme class.
 */
angular.module("form").factory("ColorScheme", [
  function defineColorScheme() {
    /**
     * Intermediate representation of a custom color scheme which can be
     * converted to the color scheme format used by Guacamole's terminal
     * emulator. All colors must be represented in the six-digit hexadecimal
     * RGB notation used by HTML ("#000000" for black, etc.).
     *
     * @constructor
     * @param {ColorScheme|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ColorScheme.
     */
    var ColorScheme = function ColorScheme(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The terminal background color. This will be the default foreground
       * color of the Guacamole terminal emulator ("#000000") by default.
       *
       * @type {String}
       */
      this.background = template.background || "#000000";

      /**
       * The terminal foreground color. This will be the default foreground
       * color of the Guacamole terminal emulator ("#999999") by default.
       *
       * @type {String}
       */
      this.foreground = template.foreground || "#999999";

      /**
       * The terminal color palette. Default values are provided for the
       * normal 16 terminal colors using the default values of the Guacamole
       * terminal emulator, however the terminal emulator and this
       * representation support up to 256 colors.
       *
       * @type {String[]}
       */
      this.colors = template.colors || [
        // Normal colors
        "#000000", // Black
        "#993E3E", // Red
        "#3E993E", // Green
        "#99993E", // Brown
        "#3E3E99", // Blue
        "#993E99", // Magenta
        "#3E9999", // Cyan
        "#999999", // White

        // Intense colors
        "#3E3E3E", // Black
        "#FF6767", // Red
        "#67FF67", // Green
        "#FFFF67", // Brown
        "#6767FF", // Blue
        "#FF67FF", // Magenta
        "#67FFFF", // Cyan
        "#FFFFFF", // White
      ];

      /**
       * The string which was parsed to produce this ColorScheme instance, if
       * ColorScheme.fromString() was used to produce this ColorScheme.
       *
       * @private
       * @type {String}
       */
      this._originalString = template._originalString;
    };

    /**
     * Given a color string in the standard 6-digit hexadecimal RGB format,
     * returns a X11 color spec which represents the same color.
     *
     * @param {String} color
     *     The hexadecimal color string to convert.
     *
     * @returns {String}
     *     The X11 color spec representing the same color as the given
     *     hexadecimal string, or null if the given string is not a valid
     *     6-digit hexadecimal RGB color.
     */
    var fromHexColor = function fromHexColor(color) {
      var groups = /^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/.exec(
        color
      );
      if (!groups) return null;

      return "rgb:" + groups[1] + "/" + groups[2] + "/" + groups[3];
    };

    /**
     * Parses the same subset of the X11 color spec supported by the Guacamole
     * terminal emulator (the "rgb:*" format), returning the equivalent 6-digit
     * hexadecimal color string supported by the ColorScheme representation.
     * The X11 color spec defined by Xlib's XParseColor(). The human-readable
     * color names supported by the Guacamole terminal emulator (the same color
     * names as supported by xterm) may also be used.
     *
     * @param {String} color
     *     The X11 color spec to parse, or the name of a known named color.
     *
     * @returns {String}
     *     The 6-digit hexadecimal color string which represents the same color
     *     as the given X11 color spec/name, or null if the given spec/name is
     *     invalid.
     */
    var toHexColor = function toHexColor(color) {
      /**
       * Shifts or truncates the given hexadecimal string such that it
       * contains exactly two hexadecimal digits, as required by any
       * individual color component of the 6-digit hexadecimal RGB format.
       *
       * @param {String} component
       *     The hexadecimal string to shift or truncate to two digits.
       *
       * @returns {String}
       *     A new 2-digit hexadecimal string containing the same digits as
       *     the provided string, shifted or truncated as necessary to fit
       *     within the 2-digit length limit.
       */
      var toHexComponent = function toHexComponent(component) {
        return (component + "0").substring(0, 2).toUpperCase();
      };

      // Attempt to parse any non-RGB color as a named color
      var groups =
        /^rgb:([0-9A-Fa-f]{1,4})\/([0-9A-Fa-f]{1,4})\/([0-9A-Fa-f]{1,4})$/.exec(
          color
        );
      if (!groups) return ColorScheme.NAMED_COLORS[color.toLowerCase()] || null;

      // Convert to standard 6-digit hexadecimal RGB format
      return (
        "#" +
        toHexComponent(groups[1]) +
        toHexComponent(groups[2]) +
        toHexComponent(groups[3])
      );
    };

    /**
     * Converts the given string representation of a color scheme which is
     * supported by the Guacamole terminal emulator to a corresponding,
     * intermediate ColorScheme object.
     *
     * @param {String} str
     *     An arbitrary color scheme, in the string format supported by the
     *     Guacamole terminal emulator.
     *
     * @returns {ColorScheme}
     *     A new ColorScheme instance which represents the same color scheme as
     *     the given string.
     */
    ColorScheme.fromString = function fromString(str) {
      var scheme = new ColorScheme({ _originalString: str });

      // For each semicolon-separated statement in the provided color scheme
      var statements = str.split(/;/);
      for (var i = 0; i < statements.length; i++) {
        // Skip any statements which cannot be parsed
        var statement = statements[i];
        var groups =
          /^\s*(background|foreground|color([0-9]+))\s*:\s*(\S*)\s*$/.exec(
            statement
          );
        if (!groups) continue;

        // If the statement is valid and contains a valid color, map that
        // color to the appropriate property of the ColorScheme object
        var color = toHexColor(groups[3]);
        if (color) {
          if (groups[1] === "background") scheme.background = color;
          else if (groups[1] === "foreground") scheme.foreground = color;
          else scheme.colors[parseInt(groups[2])] = color;
        }
      }

      return scheme;
    };

    /**
     * Returns whether the two given color schemes define the exact same
     * colors.
     *
     * @param {ColorScheme} a
     *     The first ColorScheme to compare.
     *
     * @param {ColorScheme} b
     *     The second ColorScheme to compare.
     *
     * @returns {Boolean}
     *     true if both color schemes contain the same colors, false otherwise.
     */
    ColorScheme.equals = function equals(a, b) {
      return (
        a.foreground === b.foreground &&
        a.background === b.background &&
        _.isEqual(a.colors, b.colors)
      );
    };

    /**
     * Converts the given ColorScheme to a string representation which is
     * supported by the Guacamole terminal emulator.
     *
     * @param {ColorScheme} scheme
     *     The ColorScheme to convert to a string.
     *
     * @returns {String}
     *     The given color scheme, converted to the string format supported by
     *     the Guacamole terminal emulator.
     */
    ColorScheme.toString = function toString(scheme) {
      // Use originally-provided string if it equates to the exact same color scheme
      if (
        !_.isUndefined(scheme._originalString) &&
        ColorScheme.equals(
          scheme,
          ColorScheme.fromString(scheme._originalString)
        )
      )
        return scheme._originalString;

      // Add background and foreground
      var str =
        "background: " +
        fromHexColor(scheme.background) +
        ";\n" +
        "foreground: " +
        fromHexColor(scheme.foreground) +
        ";";

      // Add color definitions for each palette entry
      for (var index in scheme.colors)
        str +=
          "\ncolor" + index + ": " + fromHexColor(scheme.colors[index]) + ";";

      return str;
    };

    /**
     * The set of all named colors supported by the Guacamole terminal
     * emulator and their corresponding 6-digit hexadecimal RGB
     * representations. This set should contain all colors supported by xterm.
     *
     * @constant
     * @type {Object.<String, String>}
     */
    ColorScheme.NAMED_COLORS = {
      aliceblue: "#F0F8FF",
      antiquewhite: "#FAEBD7",
      antiquewhite1: "#FFEFDB",
      antiquewhite2: "#EEDFCC",
      antiquewhite3: "#CDC0B0",
      antiquewhite4: "#8B8378",
      aqua: "#00FFFF",
      aquamarine: "#7FFFD4",
      aquamarine1: "#7FFFD4",
      aquamarine2: "#76EEC6",
      aquamarine3: "#66CDAA",
      aquamarine4: "#458B74",
      azure: "#F0FFFF",
      azure1: "#F0FFFF",
      azure2: "#E0EEEE",
      azure3: "#C1CDCD",
      azure4: "#838B8B",
      beige: "#F5F5DC",
      bisque: "#FFE4C4",
      bisque1: "#FFE4C4",
      bisque2: "#EED5B7",
      bisque3: "#CDB79E",
      bisque4: "#8B7D6B",
      black: "#000000",
      blanchedalmond: "#FFEBCD",
      blue: "#0000FF",
      blue1: "#0000FF",
      blue2: "#0000EE",
      blue3: "#0000CD",
      blue4: "#00008B",
      blueviolet: "#8A2BE2",
      brown: "#A52A2A",
      brown1: "#FF4040",
      brown2: "#EE3B3B",
      brown3: "#CD3333",
      brown4: "#8B2323",
      burlywood: "#DEB887",
      burlywood1: "#FFD39B",
      burlywood2: "#EEC591",
      burlywood3: "#CDAA7D",
      burlywood4: "#8B7355",
      cadetblue: "#5F9EA0",
      cadetblue1: "#98F5FF",
      cadetblue2: "#8EE5EE",
      cadetblue3: "#7AC5CD",
      cadetblue4: "#53868B",
      chartreuse: "#7FFF00",
      chartreuse1: "#7FFF00",
      chartreuse2: "#76EE00",
      chartreuse3: "#66CD00",
      chartreuse4: "#458B00",
      chocolate: "#D2691E",
      chocolate1: "#FF7F24",
      chocolate2: "#EE7621",
      chocolate3: "#CD661D",
      chocolate4: "#8B4513",
      coral: "#FF7F50",
      coral1: "#FF7256",
      coral2: "#EE6A50",
      coral3: "#CD5B45",
      coral4: "#8B3E2F",
      cornflowerblue: "#6495ED",
      cornsilk: "#FFF8DC",
      cornsilk1: "#FFF8DC",
      cornsilk2: "#EEE8CD",
      cornsilk3: "#CDC8B1",
      cornsilk4: "#8B8878",
      crimson: "#DC143C",
      cyan: "#00FFFF",
      cyan1: "#00FFFF",
      cyan2: "#00EEEE",
      cyan3: "#00CDCD",
      cyan4: "#008B8B",
      darkblue: "#00008B",
      darkcyan: "#008B8B",
      darkgoldenrod: "#B8860B",
      darkgoldenrod1: "#FFB90F",
      darkgoldenrod2: "#EEAD0E",
      darkgoldenrod3: "#CD950C",
      darkgoldenrod4: "#8B6508",
      darkgray: "#A9A9A9",
      darkgreen: "#006400",
      darkgrey: "#A9A9A9",
      darkkhaki: "#BDB76B",
      darkmagenta: "#8B008B",
      darkolivegreen: "#556B2F",
      darkolivegreen1: "#CAFF70",
      darkolivegreen2: "#BCEE68",
      darkolivegreen3: "#A2CD5A",
      darkolivegreen4: "#6E8B3D",
      darkorange: "#FF8C00",
      darkorange1: "#FF7F00",
      darkorange2: "#EE7600",
      darkorange3: "#CD6600",
      darkorange4: "#8B4500",
      darkorchid: "#9932CC",
      darkorchid1: "#BF3EFF",
      darkorchid2: "#B23AEE",
      darkorchid3: "#9A32CD",
      darkorchid4: "#68228B",
      darkred: "#8B0000",
      darksalmon: "#E9967A",
      darkseagreen: "#8FBC8F",
      darkseagreen1: "#C1FFC1",
      darkseagreen2: "#B4EEB4",
      darkseagreen3: "#9BCD9B",
      darkseagreen4: "#698B69",
      darkslateblue: "#483D8B",
      darkslategray: "#2F4F4F",
      darkslategray1: "#97FFFF",
      darkslategray2: "#8DEEEE",
      darkslategray3: "#79CDCD",
      darkslategray4: "#528B8B",
      darkslategrey: "#2F4F4F",
      darkturquoise: "#00CED1",
      darkviolet: "#9400D3",
      deeppink: "#FF1493",
      deeppink1: "#FF1493",
      deeppink2: "#EE1289",
      deeppink3: "#CD1076",
      deeppink4: "#8B0A50",
      deepskyblue: "#00BFFF",
      deepskyblue1: "#00BFFF",
      deepskyblue2: "#00B2EE",
      deepskyblue3: "#009ACD",
      deepskyblue4: "#00688B",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1E90FF",
      dodgerblue1: "#1E90FF",
      dodgerblue2: "#1C86EE",
      dodgerblue3: "#1874CD",
      dodgerblue4: "#104E8B",
      firebrick: "#B22222",
      firebrick1: "#FF3030",
      firebrick2: "#EE2C2C",
      firebrick3: "#CD2626",
      firebrick4: "#8B1A1A",
      floralwhite: "#FFFAF0",
      forestgreen: "#228B22",
      fuchsia: "#FF00FF",
      gainsboro: "#DCDCDC",
      ghostwhite: "#F8F8FF",
      gold: "#FFD700",
      gold1: "#FFD700",
      gold2: "#EEC900",
      gold3: "#CDAD00",
      gold4: "#8B7500",
      goldenrod: "#DAA520",
      goldenrod1: "#FFC125",
      goldenrod2: "#EEB422",
      goldenrod3: "#CD9B1D",
      goldenrod4: "#8B6914",
      gray: "#BEBEBE",
      gray0: "#000000",
      gray1: "#030303",
      gray10: "#1A1A1A",
      gray100: "#FFFFFF",
      gray11: "#1C1C1C",
      gray12: "#1F1F1F",
      gray13: "#212121",
      gray14: "#242424",
      gray15: "#262626",
      gray16: "#292929",
      gray17: "#2B2B2B",
      gray18: "#2E2E2E",
      gray19: "#303030",
      gray2: "#050505",
      gray20: "#333333",
      gray21: "#363636",
      gray22: "#383838",
      gray23: "#3B3B3B",
      gray24: "#3D3D3D",
      gray25: "#404040",
      gray26: "#424242",
      gray27: "#454545",
      gray28: "#474747",
      gray29: "#4A4A4A",
      gray3: "#080808",
      gray30: "#4D4D4D",
      gray31: "#4F4F4F",
      gray32: "#525252",
      gray33: "#545454",
      gray34: "#575757",
      gray35: "#595959",
      gray36: "#5C5C5C",
      gray37: "#5E5E5E",
      gray38: "#616161",
      gray39: "#636363",
      gray4: "#0A0A0A",
      gray40: "#666666",
      gray41: "#696969",
      gray42: "#6B6B6B",
      gray43: "#6E6E6E",
      gray44: "#707070",
      gray45: "#737373",
      gray46: "#757575",
      gray47: "#787878",
      gray48: "#7A7A7A",
      gray49: "#7D7D7D",
      gray5: "#0D0D0D",
      gray50: "#7F7F7F",
      gray51: "#828282",
      gray52: "#858585",
      gray53: "#878787",
      gray54: "#8A8A8A",
      gray55: "#8C8C8C",
      gray56: "#8F8F8F",
      gray57: "#919191",
      gray58: "#949494",
      gray59: "#969696",
      gray6: "#0F0F0F",
      gray60: "#999999",
      gray61: "#9C9C9C",
      gray62: "#9E9E9E",
      gray63: "#A1A1A1",
      gray64: "#A3A3A3",
      gray65: "#A6A6A6",
      gray66: "#A8A8A8",
      gray67: "#ABABAB",
      gray68: "#ADADAD",
      gray69: "#B0B0B0",
      gray7: "#121212",
      gray70: "#B3B3B3",
      gray71: "#B5B5B5",
      gray72: "#B8B8B8",
      gray73: "#BABABA",
      gray74: "#BDBDBD",
      gray75: "#BFBFBF",
      gray76: "#C2C2C2",
      gray77: "#C4C4C4",
      gray78: "#C7C7C7",
      gray79: "#C9C9C9",
      gray8: "#141414",
      gray80: "#CCCCCC",
      gray81: "#CFCFCF",
      gray82: "#D1D1D1",
      gray83: "#D4D4D4",
      gray84: "#D6D6D6",
      gray85: "#D9D9D9",
      gray86: "#DBDBDB",
      gray87: "#DEDEDE",
      gray88: "#E0E0E0",
      gray89: "#E3E3E3",
      gray9: "#171717",
      gray90: "#E5E5E5",
      gray91: "#E8E8E8",
      gray92: "#EBEBEB",
      gray93: "#EDEDED",
      gray94: "#F0F0F0",
      gray95: "#F2F2F2",
      gray96: "#F5F5F5",
      gray97: "#F7F7F7",
      gray98: "#FAFAFA",
      gray99: "#FCFCFC",
      green: "#00FF00",
      green1: "#00FF00",
      green2: "#00EE00",
      green3: "#00CD00",
      green4: "#008B00",
      greenyellow: "#ADFF2F",
      grey: "#BEBEBE",
      grey0: "#000000",
      grey1: "#030303",
      grey10: "#1A1A1A",
      grey100: "#FFFFFF",
      grey11: "#1C1C1C",
      grey12: "#1F1F1F",
      grey13: "#212121",
      grey14: "#242424",
      grey15: "#262626",
      grey16: "#292929",
      grey17: "#2B2B2B",
      grey18: "#2E2E2E",
      grey19: "#303030",
      grey2: "#050505",
      grey20: "#333333",
      grey21: "#363636",
      grey22: "#383838",
      grey23: "#3B3B3B",
      grey24: "#3D3D3D",
      grey25: "#404040",
      grey26: "#424242",
      grey27: "#454545",
      grey28: "#474747",
      grey29: "#4A4A4A",
      grey3: "#080808",
      grey30: "#4D4D4D",
      grey31: "#4F4F4F",
      grey32: "#525252",
      grey33: "#545454",
      grey34: "#575757",
      grey35: "#595959",
      grey36: "#5C5C5C",
      grey37: "#5E5E5E",
      grey38: "#616161",
      grey39: "#636363",
      grey4: "#0A0A0A",
      grey40: "#666666",
      grey41: "#696969",
      grey42: "#6B6B6B",
      grey43: "#6E6E6E",
      grey44: "#707070",
      grey45: "#737373",
      grey46: "#757575",
      grey47: "#787878",
      grey48: "#7A7A7A",
      grey49: "#7D7D7D",
      grey5: "#0D0D0D",
      grey50: "#7F7F7F",
      grey51: "#828282",
      grey52: "#858585",
      grey53: "#878787",
      grey54: "#8A8A8A",
      grey55: "#8C8C8C",
      grey56: "#8F8F8F",
      grey57: "#919191",
      grey58: "#949494",
      grey59: "#969696",
      grey6: "#0F0F0F",
      grey60: "#999999",
      grey61: "#9C9C9C",
      grey62: "#9E9E9E",
      grey63: "#A1A1A1",
      grey64: "#A3A3A3",
      grey65: "#A6A6A6",
      grey66: "#A8A8A8",
      grey67: "#ABABAB",
      grey68: "#ADADAD",
      grey69: "#B0B0B0",
      grey7: "#121212",
      grey70: "#B3B3B3",
      grey71: "#B5B5B5",
      grey72: "#B8B8B8",
      grey73: "#BABABA",
      grey74: "#BDBDBD",
      grey75: "#BFBFBF",
      grey76: "#C2C2C2",
      grey77: "#C4C4C4",
      grey78: "#C7C7C7",
      grey79: "#C9C9C9",
      grey8: "#141414",
      grey80: "#CCCCCC",
      grey81: "#CFCFCF",
      grey82: "#D1D1D1",
      grey83: "#D4D4D4",
      grey84: "#D6D6D6",
      grey85: "#D9D9D9",
      grey86: "#DBDBDB",
      grey87: "#DEDEDE",
      grey88: "#E0E0E0",
      grey89: "#E3E3E3",
      grey9: "#171717",
      grey90: "#E5E5E5",
      grey91: "#E8E8E8",
      grey92: "#EBEBEB",
      grey93: "#EDEDED",
      grey94: "#F0F0F0",
      grey95: "#F2F2F2",
      grey96: "#F5F5F5",
      grey97: "#F7F7F7",
      grey98: "#FAFAFA",
      grey99: "#FCFCFC",
      honeydew: "#F0FFF0",
      honeydew1: "#F0FFF0",
      honeydew2: "#E0EEE0",
      honeydew3: "#C1CDC1",
      honeydew4: "#838B83",
      hotpink: "#FF69B4",
      hotpink1: "#FF6EB4",
      hotpink2: "#EE6AA7",
      hotpink3: "#CD6090",
      hotpink4: "#8B3A62",
      indianred: "#CD5C5C",
      indianred1: "#FF6A6A",
      indianred2: "#EE6363",
      indianred3: "#CD5555",
      indianred4: "#8B3A3A",
      indigo: "#4B0082",
      ivory: "#FFFFF0",
      ivory1: "#FFFFF0",
      ivory2: "#EEEEE0",
      ivory3: "#CDCDC1",
      ivory4: "#8B8B83",
      khaki: "#F0E68C",
      khaki1: "#FFF68F",
      khaki2: "#EEE685",
      khaki3: "#CDC673",
      khaki4: "#8B864E",
      lavender: "#E6E6FA",
      lavenderblush: "#FFF0F5",
      lavenderblush1: "#FFF0F5",
      lavenderblush2: "#EEE0E5",
      lavenderblush3: "#CDC1C5",
      lavenderblush4: "#8B8386",
      lawngreen: "#7CFC00",
      lemonchiffon: "#FFFACD",
      lemonchiffon1: "#FFFACD",
      lemonchiffon2: "#EEE9BF",
      lemonchiffon3: "#CDC9A5",
      lemonchiffon4: "#8B8970",
      lightblue: "#ADD8E6",
      lightblue1: "#BFEFFF",
      lightblue2: "#B2DFEE",
      lightblue3: "#9AC0CD",
      lightblue4: "#68838B",
      lightcoral: "#F08080",
      lightcyan: "#E0FFFF",
      lightcyan1: "#E0FFFF",
      lightcyan2: "#D1EEEE",
      lightcyan3: "#B4CDCD",
      lightcyan4: "#7A8B8B",
      lightgoldenrod: "#EEDD82",
      lightgoldenrod1: "#FFEC8B",
      lightgoldenrod2: "#EEDC82",
      lightgoldenrod3: "#CDBE70",
      lightgoldenrod4: "#8B814C",
      lightgoldenrodyellow: "#FAFAD2",
      lightgray: "#D3D3D3",
      lightgreen: "#90EE90",
      lightgrey: "#D3D3D3",
      lightpink: "#FFB6C1",
      lightpink1: "#FFAEB9",
      lightpink2: "#EEA2AD",
      lightpink3: "#CD8C95",
      lightpink4: "#8B5F65",
      lightsalmon: "#FFA07A",
      lightsalmon1: "#FFA07A",
      lightsalmon2: "#EE9572",
      lightsalmon3: "#CD8162",
      lightsalmon4: "#8B5742",
      lightseagreen: "#20B2AA",
      lightskyblue: "#87CEFA",
      lightskyblue1: "#B0E2FF",
      lightskyblue2: "#A4D3EE",
      lightskyblue3: "#8DB6CD",
      lightskyblue4: "#607B8B",
      lightslateblue: "#8470FF",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#B0C4DE",
      lightsteelblue1: "#CAE1FF",
      lightsteelblue2: "#BCD2EE",
      lightsteelblue3: "#A2B5CD",
      lightsteelblue4: "#6E7B8B",
      lightyellow: "#FFFFE0",
      lightyellow1: "#FFFFE0",
      lightyellow2: "#EEEED1",
      lightyellow3: "#CDCDB4",
      lightyellow4: "#8B8B7A",
      lime: "#00FF00",
      limegreen: "#32CD32",
      linen: "#FAF0E6",
      magenta: "#FF00FF",
      magenta1: "#FF00FF",
      magenta2: "#EE00EE",
      magenta3: "#CD00CD",
      magenta4: "#8B008B",
      maroon: "#B03060",
      maroon1: "#FF34B3",
      maroon2: "#EE30A7",
      maroon3: "#CD2990",
      maroon4: "#8B1C62",
      mediumaquamarine: "#66CDAA",
      mediumblue: "#0000CD",
      mediumorchid: "#BA55D3",
      mediumorchid1: "#E066FF",
      mediumorchid2: "#D15FEE",
      mediumorchid3: "#B452CD",
      mediumorchid4: "#7A378B",
      mediumpurple: "#9370DB",
      mediumpurple1: "#AB82FF",
      mediumpurple2: "#9F79EE",
      mediumpurple3: "#8968CD",
      mediumpurple4: "#5D478B",
      mediumseagreen: "#3CB371",
      mediumslateblue: "#7B68EE",
      mediumspringgreen: "#00FA9A",
      mediumturquoise: "#48D1CC",
      mediumvioletred: "#C71585",
      midnightblue: "#191970",
      mintcream: "#F5FFFA",
      mistyrose: "#FFE4E1",
      mistyrose1: "#FFE4E1",
      mistyrose2: "#EED5D2",
      mistyrose3: "#CDB7B5",
      mistyrose4: "#8B7D7B",
      moccasin: "#FFE4B5",
      navajowhite: "#FFDEAD",
      navajowhite1: "#FFDEAD",
      navajowhite2: "#EECFA1",
      navajowhite3: "#CDB38B",
      navajowhite4: "#8B795E",
      navy: "#000080",
      navyblue: "#000080",
      oldlace: "#FDF5E6",
      olive: "#808000",
      olivedrab: "#6B8E23",
      olivedrab1: "#C0FF3E",
      olivedrab2: "#B3EE3A",
      olivedrab3: "#9ACD32",
      olivedrab4: "#698B22",
      orange: "#FFA500",
      orange1: "#FFA500",
      orange2: "#EE9A00",
      orange3: "#CD8500",
      orange4: "#8B5A00",
      orangered: "#FF4500",
      orangered1: "#FF4500",
      orangered2: "#EE4000",
      orangered3: "#CD3700",
      orangered4: "#8B2500",
      orchid: "#DA70D6",
      orchid1: "#FF83FA",
      orchid2: "#EE7AE9",
      orchid3: "#CD69C9",
      orchid4: "#8B4789",
      palegoldenrod: "#EEE8AA",
      palegreen: "#98FB98",
      palegreen1: "#9AFF9A",
      palegreen2: "#90EE90",
      palegreen3: "#7CCD7C",
      palegreen4: "#548B54",
      paleturquoise: "#AFEEEE",
      paleturquoise1: "#BBFFFF",
      paleturquoise2: "#AEEEEE",
      paleturquoise3: "#96CDCD",
      paleturquoise4: "#668B8B",
      palevioletred: "#DB7093",
      palevioletred1: "#FF82AB",
      palevioletred2: "#EE799F",
      palevioletred3: "#CD6889",
      palevioletred4: "#8B475D",
      papayawhip: "#FFEFD5",
      peachpuff: "#FFDAB9",
      peachpuff1: "#FFDAB9",
      peachpuff2: "#EECBAD",
      peachpuff3: "#CDAF95",
      peachpuff4: "#8B7765",
      peru: "#CD853F",
      pink: "#FFC0CB",
      pink1: "#FFB5C5",
      pink2: "#EEA9B8",
      pink3: "#CD919E",
      pink4: "#8B636C",
      plum: "#DDA0DD",
      plum1: "#FFBBFF",
      plum2: "#EEAEEE",
      plum3: "#CD96CD",
      plum4: "#8B668B",
      powderblue: "#B0E0E6",
      purple: "#A020F0",
      purple1: "#9B30FF",
      purple2: "#912CEE",
      purple3: "#7D26CD",
      purple4: "#551A8B",
      rebeccapurple: "#663399",
      red: "#FF0000",
      red1: "#FF0000",
      red2: "#EE0000",
      red3: "#CD0000",
      red4: "#8B0000",
      rosybrown: "#BC8F8F",
      rosybrown1: "#FFC1C1",
      rosybrown2: "#EEB4B4",
      rosybrown3: "#CD9B9B",
      rosybrown4: "#8B6969",
      royalblue: "#4169E1",
      royalblue1: "#4876FF",
      royalblue2: "#436EEE",
      royalblue3: "#3A5FCD",
      royalblue4: "#27408B",
      saddlebrown: "#8B4513",
      salmon: "#FA8072",
      salmon1: "#FF8C69",
      salmon2: "#EE8262",
      salmon3: "#CD7054",
      salmon4: "#8B4C39",
      sandybrown: "#F4A460",
      seagreen: "#2E8B57",
      seagreen1: "#54FF9F",
      seagreen2: "#4EEE94",
      seagreen3: "#43CD80",
      seagreen4: "#2E8B57",
      seashell: "#FFF5EE",
      seashell1: "#FFF5EE",
      seashell2: "#EEE5DE",
      seashell3: "#CDC5BF",
      seashell4: "#8B8682",
      sienna: "#A0522D",
      sienna1: "#FF8247",
      sienna2: "#EE7942",
      sienna3: "#CD6839",
      sienna4: "#8B4726",
      silver: "#C0C0C0",
      skyblue: "#87CEEB",
      skyblue1: "#87CEFF",
      skyblue2: "#7EC0EE",
      skyblue3: "#6CA6CD",
      skyblue4: "#4A708B",
      slateblue: "#6A5ACD",
      slateblue1: "#836FFF",
      slateblue2: "#7A67EE",
      slateblue3: "#6959CD",
      slateblue4: "#473C8B",
      slategray: "#708090",
      slategray1: "#C6E2FF",
      slategray2: "#B9D3EE",
      slategray3: "#9FB6CD",
      slategray4: "#6C7B8B",
      slategrey: "#708090",
      snow: "#FFFAFA",
      snow1: "#FFFAFA",
      snow2: "#EEE9E9",
      snow3: "#CDC9C9",
      snow4: "#8B8989",
      springgreen: "#00FF7F",
      springgreen1: "#00FF7F",
      springgreen2: "#00EE76",
      springgreen3: "#00CD66",
      springgreen4: "#008B45",
      steelblue: "#4682B4",
      steelblue1: "#63B8FF",
      steelblue2: "#5CACEE",
      steelblue3: "#4F94CD",
      steelblue4: "#36648B",
      tan: "#D2B48C",
      tan1: "#FFA54F",
      tan2: "#EE9A49",
      tan3: "#CD853F",
      tan4: "#8B5A2B",
      teal: "#008080",
      thistle: "#D8BFD8",
      thistle1: "#FFE1FF",
      thistle2: "#EED2EE",
      thistle3: "#CDB5CD",
      thistle4: "#8B7B8B",
      tomato: "#FF6347",
      tomato1: "#FF6347",
      tomato2: "#EE5C42",
      tomato3: "#CD4F39",
      tomato4: "#8B3626",
      turquoise: "#40E0D0",
      turquoise1: "#00F5FF",
      turquoise2: "#00E5EE",
      turquoise3: "#00C5CD",
      turquoise4: "#00868B",
      violet: "#EE82EE",
      violetred: "#D02090",
      violetred1: "#FF3E96",
      violetred2: "#EE3A8C",
      violetred3: "#CD3278",
      violetred4: "#8B2252",
      webgray: "#808080",
      webgreen: "#008000",
      webgrey: "#808080",
      webmaroon: "#800000",
      webpurple: "#800080",
      wheat: "#F5DEB3",
      wheat1: "#FFE7BA",
      wheat2: "#EED8AE",
      wheat3: "#CDBA96",
      wheat4: "#8B7E66",
      white: "#FFFFFF",
      whitesmoke: "#F5F5F5",
      x11gray: "#BEBEBE",
      x11green: "#00FF00",
      x11grey: "#BEBEBE",
      x11maroon: "#B03060",
      x11purple: "#A020F0",
      yellow: "#FFFF00",
      yellow1: "#FFFF00",
      yellow2: "#EEEE00",
      yellow3: "#CDCD00",
      yellow4: "#8B8B00",
      yellowgreen: "#9ACD32",
    };

    return ColorScheme;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the FieldType class.
 */
angular.module("form").factory("FieldType", [
  function defineFieldType() {
    /**
     * The object used by the formService for describing field types.
     *
     * @constructor
     * @param {FieldType|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     FieldType.
     */
    var FieldType = function FieldType(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The raw HTML of the template that should be injected into the DOM of
       * a form using this field type. If provided, this will be used instead
       * of templateUrl.
       *
       * @type String
       */
      this.template = template.template;

      /**
       * The URL of the template that should be injected into the DOM of a
       * form using this field type. This property will be ignored if a raw
       * HTML template is supplied via the template property.
       *
       * @type String
       */
      this.templateUrl = template.templateUrl;

      /**
       * The name of the AngularJS module defining the controller for this
       * field type. This is optional, as not all field types will need
       * controllers.
       *
       * @type String
       */
      this.module = template.module;

      /**
       * The name of the controller for this field type. This is optional, as
       * not all field types will need controllers. If a controller is
       * specified, it will receive the following properties on the scope:
       *
       * namespace:
       *     A String which defines the unique namespace associated the
       *     translation strings used by the form using a field of this type.
       *
       * field:
       *     The Field object that is being rendered, representing a field of
       *     this type.
       *
       * model:
       *     The current String value of the field, if any.
       *
       * @type String
       */
      this.controller = template.controller;
    };

    return FieldType;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which displays the contents of a connection group within an
 * automatically-paginated view.
 */
angular.module("groupList").directive("guacGroupList", [
  function guacGroupList() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The connection groups to display as a map of data source
         * identifier to corresponding root group.
         *
         * @type Object.<String, ConnectionGroup|GroupListItem>
         */
        connectionGroups: "=",

        /**
         * Arbitrary object which shall be made available to the connection
         * and connection group templates within the scope as
         * <code>context</code>.
         *
         * @type Object
         */
        context: "=",

        /**
         * The map of @link{GroupListItem} type to the URL or ID of the
         * Angular template to use when rendering a @link{GroupListItem} of
         * that type. The @link{GroupListItem} itself will be within the
         * scope of the template as <code>item</code>, and the arbitrary
         * context object, if any, will be exposed as <code>context</code>.
         * If the template for a type is omitted, items of that type will
         * not be rendered. All standard types are defined by
         * @link{GroupListItem.Type}, but use of custom types is legal.
         *
         * @type Object.<String, String>
         */
        templates: "=",

        /**
         * Whether the root of the connection group hierarchy given should
         * be shown. If false (the default), only the descendants of the
         * given connection group will be listed.
         *
         * @type Boolean
         */
        showRootGroup: "=",

        /**
         * The maximum number of connections or groups to show per page.
         *
         * @type Number
         */
        pageSize: "=",

        /**
         * A callback which accepts an array of GroupListItems as its sole
         * parameter. If provided, the callback will be invoked whenever an
         * array of root-level GroupListItems is about to be rendered.
         * Changes may be made by this function to that array or to the
         * GroupListItems themselves.
         *
         * @type Function
         */
        decorator: "=",
      },

      templateUrl: "app/groupList/templates/guacGroupList.html",
      controller: [
        "$scope",
        "$injector",
        function guacGroupListController($scope, $injector) {
          // Required services
          var activeConnectionService = $injector.get(
            "activeConnectionService"
          );
          var dataSourceService = $injector.get("dataSourceService");
          var requestService = $injector.get("requestService");

          // Required types
          var GroupListItem = $injector.get("GroupListItem");

          /**
           * Map of data source identifier to the number of active
           * connections associated with a given connection identifier.
           * If this information is unknown, or there are no active
           * connections for a given identifier, no number will be stored.
           *
           * @type Object.<String, Object.<String, Number>>
           */
          var connectionCount = {};

          /**
           * A list of all items which should appear at the root level. As
           * connections and connection groups from multiple data sources may
           * be included in a guacGroupList, there may be multiple root
           * items, even if the root connection group is shown.
           *
           * @type GroupListItem[]
           */
          $scope.rootItems = [];

          /**
           * Returns the number of active usages of a given connection.
           *
           * @param {String} dataSource
           *     The identifier of the data source containing the given
           *     connection.
           *
           * @param {Connection} connection
           *     The connection whose active connections should be counted.
           *
           * @returns {Number}
           *     The number of currently-active usages of the given
           *     connection.
           */
          var countActiveConnections = function countActiveConnections(
            dataSource,
            connection
          ) {
            return connectionCount[dataSource][connection.identifier];
          };

          /**
           * Returns whether a @link{GroupListItem} of the given type can be
           * displayed. If there is no template associated with the given
           * type, then a @link{GroupListItem} of that type cannot be
           * displayed.
           *
           * @param {String} type
           *     The type to check.
           *
           * @returns {Boolean}
           *     true if the given @link{GroupListItem} type can be displayed,
           *     false otherwise.
           */
          $scope.isVisible = function isVisible(type) {
            return !!$scope.templates[type];
          };

          // Set contents whenever the connection group is assigned or changed
          $scope.$watch(
            "connectionGroups",
            function setContents(connectionGroups) {
              // Reset stored data
              var dataSources = [];
              $scope.rootItems = [];
              connectionCount = {};

              // If connection groups are given, add them to the interface
              if (connectionGroups) {
                // Add each provided connection group
                angular.forEach(
                  connectionGroups,
                  function addConnectionGroup(connectionGroup, dataSource) {
                    var rootItem;

                    // Prepare data source for active connection counting
                    dataSources.push(dataSource);
                    connectionCount[dataSource] = {};

                    // If the provided connection group is already a
                    // GroupListItem, no need to create a new item
                    if (connectionGroup instanceof GroupListItem)
                      rootItem = connectionGroup;
                    // Create root item for current connection group
                    else
                      rootItem = GroupListItem.fromConnectionGroup(
                        dataSource,
                        connectionGroup,
                        $scope.isVisible(GroupListItem.Type.CONNECTION),
                        $scope.isVisible(GroupListItem.Type.SHARING_PROFILE),
                        countActiveConnections
                      );

                    // If root group is to be shown, add it as a root item
                    if ($scope.showRootGroup) $scope.rootItems.push(rootItem);
                    // Otherwise, add its children as root items
                    else {
                      angular.forEach(
                        rootItem.children,
                        function addRootItem(child) {
                          $scope.rootItems.push(child);
                        }
                      );
                    }
                  }
                );

                // Count active connections by connection identifier
                dataSourceService
                  .apply(
                    activeConnectionService.getActiveConnections,
                    dataSources
                  )
                  .then(function activeConnectionsRetrieved(
                    activeConnectionMap
                  ) {
                    // Within each data source, count each active connection by identifier
                    angular.forEach(
                      activeConnectionMap,
                      function addActiveConnections(
                        activeConnections,
                        dataSource
                      ) {
                        angular.forEach(
                          activeConnections,
                          function addActiveConnection(activeConnection) {
                            // If counter already exists, increment
                            var identifier =
                              activeConnection.connectionIdentifier;
                            if (connectionCount[dataSource][identifier])
                              connectionCount[dataSource][identifier]++;
                            // Otherwise, initialize counter to 1
                            else connectionCount[dataSource][identifier] = 1;
                          }
                        );
                      }
                    );
                  },
                  requestService.DIE);
              }

              // Invoke item decorator, if provided
              if ($scope.decorator) $scope.decorator($scope.rootItems);
            }
          );

          /**
           * Toggle the open/closed status of a group list item.
           *
           * @param {GroupListItem} groupListItem
           *     The list item to expand, which should represent a
           *     connection group.
           */
          $scope.toggleExpanded = function toggleExpanded(groupListItem) {
            groupListItem.expanded = !groupListItem.expanded;
          };
        },
      ],
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which provides a filtering text input field which automatically
 * produces a filtered subset of the given connection groups.
 */
angular.module("groupList").directive("guacGroupListFilter", [
  function guacGroupListFilter() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The property to which a subset of the provided map of connection
         * groups will be assigned. The type of each item within the
         * original map is preserved within the filtered map.
         *
         * @type Object.<String, ConnectionGroup|GroupListItem>
         */
        filteredConnectionGroups: "=",

        /**
         * The placeholder text to display within the filter input field
         * when no filter has been provided.
         *
         * @type String
         */
        placeholder: "&",

        /**
         * The connection groups to filter, as a map of data source
         * identifier to corresponding root group. A subset of this map
         * will be exposed as filteredConnectionGroups.
         *
         * @type Object.<String, ConnectionGroup|GroupListItem>
         */
        connectionGroups: "&",

        /**
         * An array of expressions to filter against for each connection in
         * the hierarchy of connections and groups in the provided map.
         * These expressions must be Angular expressions which resolve to
         * properties on the connections in the provided map.
         *
         * @type String[]
         */
        connectionProperties: "&",

        /**
         * An array of expressions to filter against for each connection group
         * in the hierarchy of connections and groups in the provided map.
         * These expressions must be Angular expressions which resolve to
         * properties on the connection groups in the provided map.
         *
         * @type String[]
         */
        connectionGroupProperties: "&",
      },

      templateUrl: "app/groupList/templates/guacGroupListFilter.html",
      controller: [
        "$scope",
        "$injector",
        function guacGroupListFilterController($scope, $injector) {
          // Required types
          var ConnectionGroup = $injector.get("ConnectionGroup");
          var FilterPattern = $injector.get("FilterPattern");
          var GroupListItem = $injector.get("GroupListItem");

          /**
           * The pattern object to use when filtering connections.
           *
           * @type FilterPattern
           */
          var connectionFilterPattern = new FilterPattern(
            $scope.connectionProperties()
          );

          /**
           * The pattern object to use when filtering connection groups.
           *
           * @type FilterPattern
           */
          var connectionGroupFilterPattern = new FilterPattern(
            $scope.connectionGroupProperties()
          );

          /**
           * The filter search string to use to restrict the displayed
           * connection groups.
           *
           * @type String
           */
          $scope.searchString = null;

          /**
           * Flattens the connection group hierarchy of the given connection
           * group such that all descendants are copied as immediate
           * children. The hierarchy of nested connection groups is otherwise
           * completely preserved. A connection or connection group nested
           * two or more levels deep within the hierarchy will thus appear
           * within the returned connection group in two places: in its
           * original location AND as an immediate child.
           *
           * @param {ConnectionGroup} connectionGroup
           *     The connection group whose descendents should be copied as
           *     first-level children.
           *
           * @returns {ConnectionGroup}
           *     A new connection group completely identical to the provided
           *     connection group, except that absolutely all descendents
           *     have been copied into the first level of children.
           */
          var flattenConnectionGroup = function flattenConnectionGroup(
            connectionGroup
          ) {
            // Replace connection group with shallow copy
            connectionGroup = new ConnectionGroup(connectionGroup);

            // Ensure child arrays are defined and independent copies
            connectionGroup.childConnections =
              angular.copy(connectionGroup.childConnections) || [];
            connectionGroup.childConnectionGroups =
              angular.copy(connectionGroup.childConnectionGroups) || [];

            // Flatten all children to the top-level group
            angular.forEach(
              connectionGroup.childConnectionGroups,
              function flattenChild(child) {
                var flattenedChild = flattenConnectionGroup(child);

                // Merge all child connections
                Array.prototype.push.apply(
                  connectionGroup.childConnections,
                  flattenedChild.childConnections
                );

                // Merge all child connection groups
                Array.prototype.push.apply(
                  connectionGroup.childConnectionGroups,
                  flattenedChild.childConnectionGroups
                );
              }
            );

            return connectionGroup;
          };

          /**
           * Flattens the connection group hierarchy of the given
           * GroupListItem such that all descendants are copied as immediate
           * children. The hierarchy of nested items is otherwise completely
           * preserved. A connection or connection group nested two or more
           * levels deep within the hierarchy will thus appear within the
           * returned item in two places: in its original location AND as an
           * immediate child.
           *
           * @param {GroupListItem} item
           *     The GroupListItem whose descendents should be copied as
           *     first-level children.
           *
           * @returns {GroupListItem}
           *     A new GroupListItem completely identical to the provided
           *     item, except that absolutely all descendents have been
           *     copied into the first level of children.
           */
          var flattenGroupListItem = function flattenGroupListItem(item) {
            // Replace item with shallow copy
            item = new GroupListItem(item);

            // Ensure children are defined and independent copies
            item.children = angular.copy(item.children) || [];

            // Flatten all children to the top-level group
            angular.forEach(item.children, function flattenChild(child) {
              if (child.type === GroupListItem.Type.CONNECTION_GROUP) {
                var flattenedChild = flattenGroupListItem(child);

                // Merge all children
                Array.prototype.push.apply(
                  item.children,
                  flattenedChild.children
                );
              }
            });

            return item;
          };

          /**
           * Replaces the set of children within the given GroupListItem such
           * that only children which match the filter predicate for the
           * current search string are present.
           *
           * @param {GroupListItem} item
           *     The GroupListItem whose children should be filtered.
           */
          var filterGroupListItem = function filterGroupListItem(item) {
            item.children = item.children.filter(function applyFilterPattern(
              child
            ) {
              // Filter connections and connection groups by
              // given pattern
              switch (child.type) {
                case GroupListItem.Type.CONNECTION:
                  return connectionFilterPattern.predicate(child.wrappedItem);

                case GroupListItem.Type.CONNECTION_GROUP:
                  return connectionGroupFilterPattern.predicate(
                    child.wrappedItem
                  );
              }

              // Include all other children
              return true;
            });
          };

          /**
           * Replaces the set of child connections and connection groups
           * within the given connection group such that only children which
           * match the filter predicate for the current search string are
           * present.
           *
           * @param {ConnectionGroup} connectionGroup
           *     The connection group whose children should be filtered.
           */
          var filterConnectionGroup = function filterConnectionGroup(
            connectionGroup
          ) {
            connectionGroup.childConnections =
              connectionGroup.childConnections.filter(
                connectionFilterPattern.predicate
              );
            connectionGroup.childConnectionGroups =
              connectionGroup.childConnectionGroups.filter(
                connectionGroupFilterPattern.predicate
              );
          };

          /**
           * Applies the current filter predicate, filtering all provided
           * connection groups and storing the result in
           * filteredConnectionGroups.
           */
          var updateFilteredConnectionGroups =
            function updateFilteredConnectionGroups() {
              // Do not apply any filtering (and do not flatten) if no
              // search string is provided
              if (!$scope.searchString) {
                $scope.filteredConnectionGroups =
                  $scope.connectionGroups() || {};
                return;
              }

              // Clear all current filtered groups
              $scope.filteredConnectionGroups = {};

              // Re-filter any provided groups
              var connectionGroups = $scope.connectionGroups();
              if (connectionGroups) {
                angular.forEach(
                  connectionGroups,
                  function updateFilteredConnectionGroup(
                    connectionGroup,
                    dataSource
                  ) {
                    var filteredGroup;

                    // Flatten and filter depending on type
                    if (connectionGroup instanceof GroupListItem) {
                      filteredGroup = flattenGroupListItem(connectionGroup);
                      filterGroupListItem(filteredGroup);
                    } else {
                      filteredGroup = flattenConnectionGroup(connectionGroup);
                      filterConnectionGroup(filteredGroup);
                    }

                    // Store now-filtered root
                    $scope.filteredConnectionGroups[dataSource] = filteredGroup;
                  }
                );
              }
            };

          // Recompile and refilter when pattern is changed
          $scope.$watch(
            "searchString",
            function searchStringChanged(searchString) {
              connectionFilterPattern.compile(searchString);
              connectionGroupFilterPattern.compile(searchString);
              updateFilteredConnectionGroups();
            }
          );

          // Refilter when items change
          $scope.$watchCollection(
            $scope.connectionGroups,
            function itemsChanged() {
              updateFilteredConnectionGroups();
            }
          );
        },
      ],
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Module for displaying the contents of a connection group, allowing the user
 * to select individual connections or groups.
 */
angular.module("groupList", ["navigation", "list", "rest"]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the GroupListItem class definition.
 */
angular.module("groupList").factory("GroupListItem", [
  "$injector",
  function defineGroupListItem($injector) {
    // Required types
    var ClientIdentifier = $injector.get("ClientIdentifier");
    var ConnectionGroup = $injector.get("ConnectionGroup");

    /**
     * Creates a new GroupListItem, initializing the properties of that
     * GroupListItem with the corresponding properties of the given template.
     *
     * @constructor
     * @param {GroupListItem|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     GroupListItem.
     */
    var GroupListItem = function GroupListItem(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The identifier of the data source associated with the connection,
       * connection group, or sharing profile this item represents.
       *
       * @type String
       */
      this.dataSource = template.dataSource;

      /**
       * The unique identifier associated with the connection, connection
       * group, or sharing profile this item represents.
       *
       * @type String
       */
      this.identifier = template.identifier;

      /**
       * The human-readable display name of this item.
       *
       * @type String
       */
      this.name = template.name;

      /**
       * The unique identifier of the protocol, if this item represents a
       * connection. If this item does not represent a connection, this
       * property is not applicable.
       *
       * @type String
       */
      this.protocol = template.protocol;

      /**
       * All children items of this item. If this item contains no children,
       * this will be an empty array.
       *
       * @type GroupListItem[]
       */
      this.children = template.children || [];

      /**
       * The type of object represented by this GroupListItem. Standard types
       * are defined by GroupListItem.Type, but custom types are also legal.
       *
       * @type String
       */
      this.type = template.type;

      /**
       * Whether this item, or items of the same type, can contain children.
       * This may be true even if this particular item does not presently
       * contain children.
       *
       * @type Boolean
       */
      this.expandable = template.expandable;

      /**
       * Whether this item represents a balancing connection group.
       *
       * @type Boolean
       */
      this.balancing = template.balancing;

      /**
       * Whether the children items should be displayed.
       *
       * @type Boolean
       */
      this.expanded = template.expanded;

      /**
       * Returns the number of currently active users for this connection,
       * connection group, or sharing profile, if known. If unknown, null may
       * be returned.
       *
       * @returns {Number}
       *     The number of currently active users for this connection,
       *     connection group, or sharing profile.
       */
      this.getActiveConnections =
        template.getActiveConnections ||
        function getActiveConnections() {
          return null;
        };

      /**
       * Returns the unique string identifier that must be used when
       * connecting to a connection or connection group represented by this
       * GroupListItem.
       *
       * @returns {String}
       *     The client identifier associated with the connection or
       *     connection group represented by this GroupListItem, or null if
       *     this GroupListItem cannot have an associated client identifier.
       */
      this.getClientIdentifier =
        template.getClientIdentifier ||
        function getClientIdentifier() {
          // If the item is a connection, generate a connection identifier
          if (this.type === GroupListItem.Type.CONNECTION)
            return ClientIdentifier.toString({
              dataSource: this.dataSource,
              type: ClientIdentifier.Types.CONNECTION,
              id: this.identifier,
            });

          // If the item is a connection group, generate a connection group identifier
          if (
            this.type === GroupListItem.Type.CONNECTION_GROUP &&
            this.balancing
          )
            return ClientIdentifier.toString({
              dataSource: this.dataSource,
              type: ClientIdentifier.Types.CONNECTION_GROUP,
              id: this.identifier,
            });

          // Otherwise, no such identifier can exist
          return null;
        };

      /**
       * Returns the relative URL of the client page that connects to the
       * connection or connection group represented by this GroupListItem.
       *
       * @returns {String}
       *     The relative URL of the client page that connects to the
       *     connection or connection group represented by this GroupListItem,
       *     or null if this GroupListItem cannot be connected to.
       */
      this.getClientURL =
        template.getClientURL ||
        function getClientURL() {
          // There is a client page for this item only if it has an
          // associated client identifier
          var identifier = this.getClientIdentifier();
          if (identifier) return "#/client/" + encodeURIComponent(identifier);

          return null;
        };

      /**
       * The connection, connection group, or sharing profile whose data is
       * exposed within this GroupListItem. If the type of this GroupListItem
       * is not one of the types defined by GroupListItem.Type, then this
       * value may be anything.
       *
       * @type Connection|ConnectionGroup|SharingProfile|*
       */
      this.wrappedItem = template.wrappedItem;

      /**
       * The sorting weight to apply when displaying this GroupListItem. This
       * weight is relative only to other sorting weights. If two items have
       * the same weight, they will be sorted based on their names.
       *
       * @type Number
       * @default 0
       */
      this.weight = template.weight || 0;
    };

    /**
     * Creates a new GroupListItem using the contents of the given connection.
     *
     * @param {String} dataSource
     *     The identifier of the data source containing the given connection
     *     group.
     *
     * @param {ConnectionGroup} connection
     *     The connection whose contents should be represented by the new
     *     GroupListItem.
     *
     * @param {Boolean} [includeSharingProfiles=true]
     *     Whether sharing profiles should be included in the contents of the
     *     resulting GroupListItem. By default, sharing profiles are included.
     *
     * @param {Function} [countActiveConnections]
     *     A getter which returns the current number of active connections for
     *     the given connection. If omitted, the number of active connections
     *     known at the time this function was called is used instead. This
     *     function will be passed, in order, the data source identifier and
     *     the connection in question.
     *
     * @returns {GroupListItem}
     *     A new GroupListItem which represents the given connection.
     */
    GroupListItem.fromConnection = function fromConnection(
      dataSource,
      connection,
      includeSharingProfiles,
      countActiveConnections
    ) {
      var children = [];

      // Add any sharing profiles
      if (connection.sharingProfiles && includeSharingProfiles !== false) {
        connection.sharingProfiles.forEach(function addSharingProfile(child) {
          children.push(
            GroupListItem.fromSharingProfile(
              dataSource,
              child,
              countActiveConnections
            )
          );
        });
      }

      // Return item representing the given connection
      return new GroupListItem({
        // Identifying information
        name: connection.name,
        identifier: connection.identifier,
        protocol: connection.protocol,
        dataSource: dataSource,

        // Type information
        expandable: includeSharingProfiles !== false,
        type: GroupListItem.Type.CONNECTION,

        // Already-converted children
        children: children,

        // Count of currently active connections using this connection
        getActiveConnections: function getActiveConnections() {
          // Use getter, if provided
          if (countActiveConnections)
            return countActiveConnections(dataSource, connection);

          return connection.activeConnections;
        },

        // Wrapped item
        wrappedItem: connection,
      });
    };

    /**
     * Creates a new GroupListItem using the contents and descendants of the
     * given connection group.
     *
     * @param {String} dataSource
     *     The identifier of the data source containing the given connection
     *     group.
     *
     * @param {ConnectionGroup} connectionGroup
     *     The connection group whose contents and descendants should be
     *     represented by the new GroupListItem and its descendants.
     *
     * @param {Boolean} [includeConnections=true]
     *     Whether connections should be included in the contents of the
     *     resulting GroupListItem. By default, connections are included.
     *
     * @param {Boolean} [includeSharingProfiles=true]
     *     Whether sharing profiles should be included in the contents of the
     *     resulting GroupListItem. By default, sharing profiles are included.
     *
     * @param {Function} [countActiveConnections]
     *     A getter which returns the current number of active connections for
     *     the given connection. If omitted, the number of active connections
     *     known at the time this function was called is used instead. This
     *     function will be passed, in order, the data source identifier and
     *     the connection group in question.
     *
     * @param {Function} [countActiveConnectionGroups]
     *     A getter which returns the current number of active connections for
     *     the given connection group. If omitted, the number of active
     *     connections known at the time this function was called is used
     *     instead. This function will be passed, in order, the data source
     *     identifier and the connection group in question.
     *
     * @returns {GroupListItem}
     *     A new GroupListItem which represents the given connection group,
     *     including all descendants.
     */
    GroupListItem.fromConnectionGroup = function fromConnectionGroup(
      dataSource,
      connectionGroup,
      includeConnections,
      includeSharingProfiles,
      countActiveConnections,
      countActiveConnectionGroups
    ) {
      var children = [];

      // Add any child connections
      if (connectionGroup.childConnections && includeConnections !== false) {
        connectionGroup.childConnections.forEach(function addChildConnection(
          child
        ) {
          children.push(
            GroupListItem.fromConnection(
              dataSource,
              child,
              includeSharingProfiles,
              countActiveConnections
            )
          );
        });
      }

      // Add any child groups
      if (connectionGroup.childConnectionGroups) {
        connectionGroup.childConnectionGroups.forEach(function addChildGroup(
          child
        ) {
          children.push(
            GroupListItem.fromConnectionGroup(
              dataSource,
              child,
              includeConnections,
              includeSharingProfiles,
              countActiveConnections,
              countActiveConnectionGroups
            )
          );
        });
      }

      // Return item representing the given connection group
      return new GroupListItem({
        // Identifying information
        name: connectionGroup.name,
        identifier: connectionGroup.identifier,
        dataSource: dataSource,

        // Type information
        type: GroupListItem.Type.CONNECTION_GROUP,
        balancing: connectionGroup.type === ConnectionGroup.Type.BALANCING,
        expandable: true,

        // Already-converted children
        children: children,

        // Count of currently active connection groups using this connection
        getActiveConnections: function getActiveConnections() {
          // Use getter, if provided
          if (countActiveConnectionGroups)
            return countActiveConnectionGroups(dataSource, connectionGroup);

          return connectionGroup.activeConnections;
        },

        // Wrapped item
        wrappedItem: connectionGroup,
      });
    };

    /**
     * Creates a new GroupListItem using the contents of the given sharing
     * profile.
     *
     * @param {String} dataSource
     *     The identifier of the data source containing the given sharing
     *     profile.
     *
     * @param {SharingProfile} sharingProfile
     *     The sharing profile whose contents should be represented by the new
     *     GroupListItem.
     *
     * @returns {GroupListItem}
     *     A new GroupListItem which represents the given sharing profile.
     */
    GroupListItem.fromSharingProfile = function fromSharingProfile(
      dataSource,
      sharingProfile
    ) {
      // Return item representing the given sharing profile
      return new GroupListItem({
        // Identifying information
        name: sharingProfile.name,
        identifier: sharingProfile.identifier,
        dataSource: dataSource,

        // Type information
        type: GroupListItem.Type.SHARING_PROFILE,

        // Wrapped item
        wrappedItem: sharingProfile,
      });
    };

    /**
     * All pre-defined types of GroupListItems. Note that, while these are the
     * standard types supported by GroupListItem and the related guacGroupList
     * directive, the type string is otherwise arbitrary and custom types are
     * legal.
     *
     * @type Object.<String, String>
     */
    GroupListItem.Type = {
      /**
       * The standard type string of a GroupListItem which represents a
       * connection.
       *
       * @type String
       */
      CONNECTION: "connection",

      /**
       * The standard type string of a GroupListItem which represents a
       * connection group.
       *
       * @type String
       */
      CONNECTION_GROUP: "connection-group",

      /**
       * The standard type string of a GroupListItem which represents a
       * sharing profile.
       *
       * @type String
       */
      SHARING_PROFILE: "sharing-profile",
    };

    return GroupListItem;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The module for code relating to connection history.
 */
angular.module("history", ["storage"]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for reading and manipulating the Guacamole connection history.
 */
angular.module("history").factory("guacHistory", [
  "$injector",
  function guacHistory($injector) {
    // Required types
    var HistoryEntry = $injector.get("HistoryEntry");

    // Required services
    var localStorageService = $injector.get("localStorageService");

    var service = {};

    // The parameter name for getting the history from local storage
    var GUAC_HISTORY_STORAGE_KEY = "GUAC_HISTORY";

    /**
     * The number of entries to allow before removing old entries based on the
     * cutoff.
     */
    var IDEAL_LENGTH = 6;

    /**
     * The top few recent connections, sorted in order of most recent access.
     *
     * @type HistoryEntry[]
     */
    service.recentConnections = [];

    /**
     * Updates the thumbnail and access time of the history entry for the
     * connection with the given ID.
     *
     * @param {String} id
     *     The ID of the connection whose history entry should be updated.
     *
     * @param {String} thumbnail
     *     The URL of the thumbnail image to associate with the history entry.
     */
    service.updateThumbnail = function (id, thumbnail) {
      var i;

      // Remove any existing entry for this connection
      for (i = 0; i < service.recentConnections.length; i++) {
        if (service.recentConnections[i].id === id) {
          service.recentConnections.splice(i, 1);
          break;
        }
      }

      // Store new entry in history
      service.recentConnections.unshift(
        new HistoryEntry(id, thumbnail, new Date().getTime())
      );

      // Truncate history to ideal length
      if (service.recentConnections.length > IDEAL_LENGTH)
        service.recentConnections.length = IDEAL_LENGTH;

      // Save updated history
      localStorageService.setItem(
        GUAC_HISTORY_STORAGE_KEY,
        service.recentConnections
      );
    };

    // Init stored connection history from localStorage
    var storedHistory =
      localStorageService.getItem(GUAC_HISTORY_STORAGE_KEY) || [];
    if (storedHistory instanceof Array)
      service.recentConnections = storedHistory;

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the HistoryEntry class used by the guacHistory service.
 */
angular.module("history").factory("HistoryEntry", [
  function defineHistoryEntry() {
    /**
     * A single entry in the connection history.
     *
     * @constructor
     * @param {String} id The ID of the connection.
     *
     * @param {String} thumbnail
     *     The URL of the thumbnail to use to represent the connection.
     */
    var HistoryEntry = function HistoryEntry(id, thumbnail) {
      /**
       * The ID of the connection associated with this history entry,
       * including type prefix.
       */
      this.id = id;

      /**
       * The thumbnail associated with the connection associated with this
       * history entry.
       */
      this.thumbnail = thumbnail;
    };

    return HistoryEntry;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The controller for the home page.
 */
angular.module("home").controller("homeController", [
  "$scope",
  "$injector",
  function homeController($scope, $injector) {
    // Get required types
    var ConnectionGroup = $injector.get("ConnectionGroup");
    var GroupListItem = $injector.get("GroupListItem");

    // Get required services
    var authenticationService = $injector.get("authenticationService");
    var connectionGroupService = $injector.get("connectionGroupService");
    var dataSourceService = $injector.get("dataSourceService");
    var requestService = $injector.get("requestService");

    /**
     * Map of data source identifier to the root connection group of that data
     * source, or null if the connection group hierarchy has not yet been
     * loaded.
     *
     * @type Object.<String, ConnectionGroup>
     */
    $scope.rootConnectionGroups = null;

    /**
     * Array of all connection properties that are filterable.
     *
     * @type String[]
     */
    $scope.filteredConnectionProperties = ["name"];

    /**
     * Array of all connection group properties that are filterable.
     *
     * @type String[]
     */
    $scope.filteredConnectionGroupProperties = ["name"];

    /**
     * Returns whether critical data has completed being loaded.
     *
     * @returns {Boolean}
     *     true if enough data has been loaded for the user interface to be
     *     useful, false otherwise.
     */
    $scope.isLoaded = function isLoaded() {
      return $scope.rootConnectionGroups !== null;
    };

    // Retrieve root groups and all descendants
    dataSourceService
      .apply(
        connectionGroupService.getConnectionGroupTree,
        authenticationService.getAvailableDataSources(),
        ConnectionGroup.ROOT_IDENTIFIER
      )
      .then(function rootGroupsRetrieved(rootConnectionGroups) {
        $scope.rootConnectionGroups = rootConnectionGroups;
      }, requestService.DIE);
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which displays the contents of a connection group.
 */
angular.module("home").directive("guacRecentConnections", [
  function guacRecentConnections() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The root connection groups to display, and all visible
         * descendants, as a map of data source identifier to the root
         * connection group within that data source. Recent connections
         * will only be shown if they exist within this hierarchy,
         * regardless of their existence within the history.
         *
         * @type Object.<String, ConnectionGroup>
         */
        rootGroups: "=",
      },

      templateUrl: "app/home/templates/guacRecentConnections.html",
      controller: [
        "$scope",
        "$injector",
        function guacRecentConnectionsController($scope, $injector) {
          // Required types
          var ActiveConnection = $injector.get("ActiveConnection");
          var ClientIdentifier = $injector.get("ClientIdentifier");
          var RecentConnection = $injector.get("RecentConnection");

          // Required services
          var guacClientManager = $injector.get("guacClientManager");
          var guacHistory = $injector.get("guacHistory");

          /**
           * Array of all known and visible active connections.
           *
           * @type ActiveConnection[]
           */
          $scope.activeConnections = [];

          /**
           * Array of all known and visible recently-used connections.
           *
           * @type RecentConnection[]
           */
          $scope.recentConnections = [];

          /**
           * Returns whether recent connections are available for display.
           * Note that, for the sake of this directive, recent connections
           * include any currently-active connections, even if they are not
           * yet in the history.
           *
           * @returns {Boolean}
           *     true if recent (or active) connections are present, false
           *     otherwise.
           */
          $scope.hasRecentConnections = function hasRecentConnections() {
            return !!(
              $scope.activeConnections.length || $scope.recentConnections.length
            );
          };

          /**
           * Map of all visible objects, connections or connection groups, by
           * object identifier.
           *
           * @type Object.<String, Connection|ConnectionGroup>
           */
          var visibleObjects = {};

          /**
           * Adds the given connection to the internal set of visible
           * objects.
           *
           * @param {String} dataSource
           *     The identifier of the data source associated with the
           *     given connection group.
           *
           * @param {Connection} connection
           *     The connection to add to the internal set of visible objects.
           */
          var addVisibleConnection = function addVisibleConnection(
            dataSource,
            connection
          ) {
            // Add given connection to set of visible objects
            visibleObjects[
              ClientIdentifier.toString({
                dataSource: dataSource,
                type: ClientIdentifier.Types.CONNECTION,
                id: connection.identifier,
              })
            ] = connection;
          };

          /**
           * Adds the given connection group to the internal set of visible
           * objects, along with any descendants.
           *
           * @param {String} dataSource
           *     The identifier of the data source associated with the
           *     given connection group.
           *
           * @param {ConnectionGroup} connectionGroup
           *     The connection group to add to the internal set of visible
           *     objects, along with any descendants.
           */
          var addVisibleConnectionGroup = function addVisibleConnectionGroup(
            dataSource,
            connectionGroup
          ) {
            // Add given connection group to set of visible objects
            visibleObjects[
              ClientIdentifier.toString({
                dataSource: dataSource,
                type: ClientIdentifier.Types.CONNECTION_GROUP,
                id: connectionGroup.identifier,
              })
            ] = connectionGroup;

            // Add all child connections
            if (connectionGroup.childConnections)
              connectionGroup.childConnections.forEach(
                function addChildConnection(child) {
                  addVisibleConnection(dataSource, child);
                }
              );

            // Add all child connection groups
            if (connectionGroup.childConnectionGroups)
              connectionGroup.childConnectionGroups.forEach(
                function addChildConnectionGroup(child) {
                  addVisibleConnectionGroup(dataSource, child);
                }
              );
          };

          // Update visible objects when root groups are set
          $scope.$watch("rootGroups", function setRootGroups(rootGroups) {
            // Clear connection arrays
            $scope.activeConnections = [];
            $scope.recentConnections = [];

            // Produce collection of visible objects
            visibleObjects = {};
            if (rootGroups) {
              angular.forEach(
                rootGroups,
                function addConnectionGroup(rootGroup, dataSource) {
                  addVisibleConnectionGroup(dataSource, rootGroup);
                }
              );
            }

            var managedClients = guacClientManager.getManagedClients();

            // Add all active connections
            for (var id in managedClients) {
              // Get corresponding managed client
              var client = managedClients[id];

              // Add active connections for clients with associated visible objects
              if (id in visibleObjects) {
                var object = visibleObjects[id];
                $scope.activeConnections.push(
                  new ActiveConnection(object.name, client)
                );
              }
            }

            // Add any recent connections that are visible
            guacHistory.recentConnections.forEach(function addRecentConnection(
              historyEntry
            ) {
              // Add recent connections for history entries with associated visible objects
              if (
                historyEntry.id in visibleObjects &&
                !(historyEntry.id in managedClients)
              ) {
                var object = visibleObjects[historyEntry.id];
                $scope.recentConnections.push(
                  new RecentConnection(object.name, historyEntry)
                );
              }
            });
          }); // end rootGroup scope watch
        },
      ],
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

angular.module("home", [
  "client",
  "groupList",
  "history",
  "navigation",
  "rest",
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the ActiveConnection class used by the guacRecentConnections
 * directive.
 */
angular.module("home").factory("ActiveConnection", [
  function defineActiveConnection() {
    /**
     * A recently-user connection, visible to the current user, with an
     * associated history entry.
     *
     * @constructor
     */
    var ActiveConnection = function ActiveConnection(name, client) {
      /**
       * The human-readable name of this connection.
       *
       * @type String
       */
      this.name = name;

      /**
       * The client associated with this active connection.
       *
       * @type ManagedClient
       */
      this.client = client;
    };

    return ActiveConnection;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the RecentConnection class used by the guacRecentConnections
 * directive.
 */
angular.module("home").factory("RecentConnection", [
  function defineRecentConnection() {
    /**
     * A recently-user connection, visible to the current user, with an
     * associated history entry.
     *
     * @constructor
     */
    var RecentConnection = function RecentConnection(name, entry) {
      /**
       * The human-readable name of this connection.
       *
       * @type String
       */
      this.name = name;

      /**
       * The history entry associated with this recent connection.
       *
       * @type HistoryEntry
       */
      this.entry = entry;
    };

    return RecentConnection;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Defaults for the AngularJS $http service.
 */
angular.module("index").config([
  "$httpProvider",
  function httpDefaults($httpProvider) {
    // Do not cache the responses of GET requests
    $httpProvider.defaults.headers.get = {
      "Cache-Control": "no-cache",
      Pragma: "no-cache",
    };

    // Use "application/json" content type by default for PATCH requests
    $httpProvider.defaults.headers.patch = {
      "Content-Type": "application/json",
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The configuration block for setting up everything having to do with i18n.
 */
angular.module("index").config([
  "$injector",
  function ($injector) {
    // Required providers
    var $translateProvider = $injector.get("$translateProvider");
    var preferenceServiceProvider = $injector.get("preferenceServiceProvider");

    // Fallback to US English
    $translateProvider.fallbackLanguage("en");

    // Prefer chosen language
    $translateProvider.preferredLanguage(
      preferenceServiceProvider.preferences.language
    );

    // Escape any HTML in translation strings
    $translateProvider.useSanitizeValueStrategy("escape");

    // Load translations via translationLoader service
    $translateProvider.useLoader("translationLoader");

    // Provide pluralization, etc. via messageformat.js
    $translateProvider.useMessageFormatInterpolation();
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Overrides $templateRequest such that HTML patches defined within Guacamole
 * extensions are automatically applied to template contents. As the results of
 * $templateRequest are cached internally, $templateCache is also overridden to
 * update the internal cache as necessary.
 */
angular.module("index").config([
  "$provide",
  function ($provide) {
    /**
     * A map of previously-returned promises from past calls to
     * $templateRequest(). Future calls to $templateRequest() will return
     * new promises chained to the first promise returned for a given URL,
     * rather than redo patch processing for every request.
     *
     * @type Object.<String, Promise.<String>>
     */
    var promiseCache = {};

    // Decorate $templateCache such that promiseCache is updated if a template
    // is modified within $templateCache at runtime
    $provide.decorator("$templateCache", [
      "$delegate",
      function decorateTemplateCache($delegate) {
        // Create shallow copy of original $templateCache which we can safely
        // override
        var decoratedTemplateCache = angular.extend({}, $delegate);

        /**
         * Overridden version of $templateCache.put() which automatically
         * invalidates the cached $templateRequest result when used. Only the
         * URL parameter is defined, as all other arguments, if any, will be
         * passed through to the original $templateCache.put() when the actual
         * put() operation is performed.
         *
         * @param {String} url
         *     The URL of the template whose entry is being updated.
         *
         * @return {Object}
         *     The value returned by $templateCache.put(), which is defined as
         *     being the value that was just stored at the provided URL.
         */
        decoratedTemplateCache.put = function put(url) {
          // Evict old cached $templateRequest() result
          delete promiseCache[url];

          // Continue with originally-requested put() operation
          return $delegate.put.apply(this, arguments);
        };

        return decoratedTemplateCache;
      },
    ]);

    // Decorate $templateRequest such that it automatically applies any HTML
    // patches associated with installed Guacamole extensions
    $provide.decorator("$templateRequest", [
      "$delegate",
      "$injector",
      function decorateTemplateRequest($delegate, $injector) {
        // Required services
        var $q = $injector.get("$q");
        var patchService = $injector.get("patchService");

        /**
         * Represents a single HTML patching operation which will be applied
         * to the raw HTML of a template. The name of the patching operation
         * MUST be one of the valid names defined within
         * PatchOperation.Operations.
         *
         * @constructor
         * @param {String} name
         *     The name of the patching operation that will be applied. Valid
         *     names are defined within PatchOperation.Operations.
         *
         * @param {String} selector
         *     The CSS selector which determines which elements within a
         *     template will be affected by the patch operation.
         */
        var PatchOperation = function PatchOperation(name, selector) {
          /**
           * Applies this patch operation to the template defined by the
           * given root element, which must be a single element wrapped by
           * JQuery.
           *
           * @param {Element[]} root
           *     The JQuery-wrapped root element of the template to which
           *     this patch operation should be applied.
           *
           * @param {Element[]} elements
           *     The elements which should be applied by the patch
           *     operation. For example, if the patch operation is inserting
           *     elements, these are the elements that will be inserted.
           */
          this.apply = function apply(root, elements) {
            PatchOperation.Operations[name](root, selector, elements);
          };
        };

        /**
         * Mapping of all valid patch operation names to their corresponding
         * implementations. Each implementation accepts the same three
         * parameters: the root element of the template being patched, the CSS
         * selector determining which elements within the template are patched,
         * and an array of elements which make up the body of the patch.
         *
         * @type Object.<String, Function>
         */
        PatchOperation.Operations = {
          /**
           * Inserts the given elements before the elements matched by the
           * provided CSS selector.
           *
           * @param {Element[]} root
           *     The JQuery-wrapped root element of the template being
           *     patched.
           *
           * @param {String} selector
           *     The CSS selector which determines where this patch operation
           *     should be applied within the template defined by root.
           *
           * @param {Element[]} elements
           *     The contents of the patch which should be applied to the
           *     template defined by root at the locations selected by the
           *     given CSS selector.
           */
          before: function before(root, selector, elements) {
            root.find(selector).before(elements);
          },

          /**
           * Inserts the given elements after the elements matched by the
           * provided CSS selector.
           *
           * @param {Element[]} root
           *     The JQuery-wrapped root element of the template being
           *     patched.
           *
           * @param {String} selector
           *     The CSS selector which determines where this patch operation
           *     should be applied within the template defined by root.
           *
           * @param {Element[]} elements
           *     The contents of the patch which should be applied to the
           *     template defined by root at the locations selected by the
           *     given CSS selector.
           */
          after: function after(root, selector, elements) {
            root.find(selector).after(elements);
          },

          /**
           * Replaces the elements matched by the provided CSS selector with
           * the given elements.
           *
           * @param {Element[]} root
           *     The JQuery-wrapped root element of the template being
           *     patched.
           *
           * @param {String} selector
           *     The CSS selector which determines where this patch operation
           *     should be applied within the template defined by root.
           *
           * @param {Element[]} elements
           *     The contents of the patch which should be applied to the
           *     template defined by root at the locations selected by the
           *     given CSS selector.
           */
          replace: function replace(root, selector, elements) {
            root.find(selector).replaceWith(elements);
          },

          /**
           * Inserts the given elements within the elements matched by the
           * provided CSS selector, before any existing children.
           *
           * @param {Element[]} root
           *     The JQuery-wrapped root element of the template being
           *     patched.
           *
           * @param {String} selector
           *     The CSS selector which determines where this patch operation
           *     should be applied within the template defined by root.
           *
           * @param {Element[]} elements
           *     The contents of the patch which should be applied to the
           *     template defined by root at the locations selected by the
           *     given CSS selector.
           */
          "before-children": function beforeChildren(root, selector, elements) {
            root.find(selector).prepend(elements);
          },

          /**
           * Inserts the given elements within the elements matched by the
           * provided CSS selector, after any existing children.
           *
           * @param {Element[]} root
           *     The JQuery-wrapped root element of the template being
           *     patched.
           *
           * @param {String} selector
           *     The CSS selector which determines where this patch operation
           *     should be applied within the template defined by root.
           *
           * @param {Element[]} elements
           *     The contents of the patch which should be applied to the
           *     template defined by root at the locations selected by the
           *     given CSS selector.
           */
          "after-children": function afterChildren(root, selector, elements) {
            root.find(selector).append(elements);
          },

          /**
           * Inserts the given elements within the elements matched by the
           * provided CSS selector, replacing any existing children.
           *
           * @param {Element[]} root
           *     The JQuery-wrapped root element of the template being
           *     patched.
           *
           * @param {String} selector
           *     The CSS selector which determines where this patch operation
           *     should be applied within the template defined by root.
           *
           * @param {Element[]} elements
           *     The contents of the patch which should be applied to the
           *     template defined by root at the locations selected by the
           *     given CSS selector.
           */
          "replace-children": function replaceChildren(
            root,
            selector,
            elements
          ) {
            root.find(selector).empty().append(elements);
          },
        };

        /**
         * Applies each of the given HTML patches to the given template.
         *
         * @param {Element[]} root
         *     The JQuery-wrapped root element of the template being
         *     patched.
         *
         * @param {String[]} patches
         *     An array of all HTML patches to be applied to the given
         *     template.
         */
        var applyPatches = function applyPatches(root, patches) {
          // Apply all defined patches
          angular.forEach(patches, function applyPatch(patch) {
            var elements = $(patch);

            // Filter out and parse all applicable meta tags
            var operations = [];
            elements = elements.filter(function filterMetaTags(index, element) {
              // Leave non-meta tags untouched
              if (element.tagName !== "META") return true;

              // Only meta tags having a valid "name" attribute need
              // to be filtered
              var name = element.getAttribute("name");
              if (!name || !(name in PatchOperation.Operations)) return true;

              // The "content" attribute must be present for any
              // valid "name" meta tag
              var content = element.getAttribute("content");
              if (!content) return true;

              // Filter out and parse meta tag
              operations.push(new PatchOperation(name, content));
              return false;
            });

            // Apply each operation implied by the meta tags
            angular.forEach(operations, function applyOperation(operation) {
              operation.apply(root, elements);
            });
          });
        };

        /**
         * Invokes $templateRequest() with all arguments exactly as provided,
         * applying all HTML patches from any installed Guacamole extensions
         * to the HTML of the requested template.
         *
         * @param {String} url
         *     The URL of the template being requested.
         *
         * @returns {Promise.<String>}
         *     A Promise which resolves with the patched HTML contents of the
         *     requested template if retrieval of the template is successful.
         */
        var decoratedTemplateRequest = function decoratedTemplateRequest(url) {
          var deferred = $q.defer();

          // Chain to cached promise if it already exists
          var cachedPromise = promiseCache[url];
          if (cachedPromise) {
            cachedPromise.then(deferred.resolve, deferred.reject);
            return deferred.promise;
          }

          // Resolve promise with patched template HTML
          $delegate.apply(this, arguments).then(function patchTemplate(data) {
            // Retrieve and apply all patches
            patchService
              .getPatches()
              .then(function applyRetrievedPatches(patches) {
                // Parse HTML into DOM tree
                var root = $("<div></div>").html(data);

                // Apply all HTML patches to the parsed DOM
                applyPatches(root, patches);

                // Transform back into HTML
                deferred.resolve.call(this, root.html());
              }, deferred.reject);
          }, deferred.reject);

          // Cache this promise for future results
          promiseCache[url] = deferred.promise;
          return deferred.promise;
        };

        return decoratedTemplateRequest;
      },
    ]);
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The controller for the root of the application.
 */
angular.module("index").controller("indexController", [
  "$scope",
  "$injector",
  function indexController($scope, $injector) {
    // Required services
    var $document = $injector.get("$document");
    var $window = $injector.get("$window");
    var clipboardService = $injector.get("clipboardService");
    var guacNotification = $injector.get("guacNotification");

    /**
     * The error that prevents the current page from rendering at all. If no
     * such error has occurred, this will be null.
     *
     * @type Error
     */
    $scope.fatalError = null;

    /**
     * The notification service.
     */
    $scope.guacNotification = guacNotification;

    /**
     * The message to display to the user as instructions for the login
     * process.
     *
     * @type TranslatableMessage
     */
    $scope.loginHelpText = null;

    /**
     * The credentials that the authentication service is has already accepted,
     * pending additional credentials, if any. If the user is logged in, or no
     * credentials have been accepted, this will be null. If credentials have
     * been accepted, this will be a map of name/value pairs corresponding to
     * the parameters submitted in a previous authentication attempt.
     *
     * @type Object.<String, String>
     */
    $scope.acceptedCredentials = null;

    /**
     * The credentials that the authentication service is currently expecting,
     * if any. If the user is logged in, this will be null.
     *
     * @type Field[]
     */
    $scope.expectedCredentials = null;
    /**
     * Basic page-level information.
     */
    $scope.page = {
      /**
       * The name of the CSS class to apply to the page body, if any.
       *
       * @type String
       */
      bodyClassName: "",
    };

    // Add default destination for input events
    var sink = new Guacamole.InputSink();
    $document[0].body.appendChild(sink.getElement());

    // Create event listeners at the global level
    var keyboard = new Guacamole.Keyboard($document[0]);
    keyboard.listenTo(sink.getElement());

    // Broadcast keydown events
    keyboard.onkeydown = function onkeydown(keysym) {
      // Do not handle key events if not logged in or if a notification is
      // shown
      if ($scope.expectedCredentials || guacNotification.getStatus())
        return true;

      // Warn of pending keydown
      var guacBeforeKeydownEvent = $scope.$broadcast(
        "guacBeforeKeydown",
        keysym,
        keyboard
      );
      if (guacBeforeKeydownEvent.defaultPrevented) return true;

      // If not prevented via guacBeforeKeydown, fire corresponding keydown event
      var guacKeydownEvent = $scope.$broadcast("guacKeydown", keysym, keyboard);
      return !guacKeydownEvent.defaultPrevented;
    };

    // Broadcast keyup events
    keyboard.onkeyup = function onkeyup(keysym) {
      // Do not handle key events if not logged in or if a notification is
      // shown
      if ($scope.expectedCredentials || guacNotification.getStatus()) return;

      // Warn of pending keyup
      var guacBeforeKeydownEvent = $scope.$broadcast(
        "guacBeforeKeyup",
        keysym,
        keyboard
      );
      if (guacBeforeKeydownEvent.defaultPrevented) return;

      // If not prevented via guacBeforeKeyup, fire corresponding keydown event
      $scope.$broadcast("guacKeyup", keysym, keyboard);
    };

    // Release all keys when window loses focus
    $window.onblur = function () {
      keyboard.reset();
    };

    // Release all keys upon form submission (there may not be corresponding
    // keyup events for key presses involved in submitting a form)
    $document.on("submit", function formSubmitted() {
      keyboard.reset();
    });

    /**
     * Checks whether the clipboard data has changed, firing a new
     * "guacClipboard" event if it has.
     */
    var checkClipboard = function checkClipboard() {
      clipboardService.getLocalClipboard().then(function clipboardRead(data) {
        $scope.$broadcast("guacClipboard", data);
      }, angular.noop);
    };

    // Attempt to read the clipboard if it may have changed
    $window.addEventListener("load", checkClipboard, true);
    $window.addEventListener("copy", checkClipboard);
    $window.addEventListener("cut", checkClipboard);
    $window.addEventListener(
      "focus",
      function focusGained(e) {
        // Only recheck clipboard if it's the window itself that gained focus
        if (e.target === $window) checkClipboard();
      },
      true
    );

    // Display login screen if a whole new set of credentials is needed
    $scope.$on(
      "guacInvalidCredentials",
      function loginInvalid(event, parameters, error) {
        $scope.loginHelpText = null;
        $scope.acceptedCredentials = {};
        $scope.expectedCredentials = error.expected;
        $scope.fatalError = null;
      }
    );

    // Prompt for remaining credentials if provided credentials were not enough
    $scope.$on(
      "guacInsufficientCredentials",
      function loginInsufficient(event, parameters, error) {
        $scope.loginHelpText = error.translatableMessage;
        $scope.acceptedCredentials = parameters;
        $scope.expectedCredentials = error.expected;
        $scope.fatalError = null;
      }
    );

    // Replace absolutely all content with an error message if the page itself
    // cannot be displayed due to an error
    $scope.$on("guacFatalPageError", function fatalPageError(error) {
      $scope.fatalError = error;
    });

    // Ensure new pages always start with clear keyboard state
    $scope.$on("$routeChangeStart", function routeChanging() {
      keyboard.reset();
    });

    // Update title and CSS class upon navigation
    $scope.$on("$routeChangeSuccess", function (event, current, previous) {
      // If the current route is available
      if (current.$$route) {
        // Clear login screen if route change was successful (and thus
        // login was either successful or not required)
        $scope.loginHelpText = null;
        $scope.acceptedCredentials = null;
        $scope.expectedCredentials = null;
        $scope.fatalError = null;

        // Set body CSS class
        // $scope.page.bodyClassName = current.$$route.bodyClassName || '';
      }
    });
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A filter for transforming an object into an array of all non-inherited
 * property key/value pairs. The resulting array contains one object for each
 * property in the original object, where the "key" property contains the
 * original property key and the "value" property contains the original
 * property value.
 */
angular.module("index").filter("toArray", [
  function toArrayFactory() {
    /**
     * The name of the property to use to store the cached result of converting
     * an object to an array. This property is added to each object converted,
     * such that the same array is returned each time unless the original
     * object has changed.
     *
     * @type String
     */
    var CACHE_KEY = "_guac_toArray";

    return function toArrayFilter(input) {
      // If no object is available, just return an empty array
      if (!input) {
        return [];
      }

      // Translate object into array of key/value pairs
      var array = [];
      angular.forEach(input, function fetchValueByKey(value, key) {
        array.push({
          key: key,
          value: value,
        });
      });

      // Sort consistently by key
      array.sort(function compareKeys(a, b) {
        if (a.key < b.key) return -1;
        if (a.key > b.key) return 1;
        return 0;
      });

      // Define non-enumerable property for holding cached array
      if (!input[CACHE_KEY]) {
        Object.defineProperty(input, CACHE_KEY, {
          value: [],
          enumerable: false,
          configurable: true,
          writable: true,
        });
      }

      // Update cache if resulting array is different
      if (!angular.equals(input[CACHE_KEY], array)) input[CACHE_KEY] = array;

      return input[CACHE_KEY];
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The module for the root of the application.
 */
angular.module("index", [
  "auth",
  "client",
  "clipboard",
  "home",
  "login",
  "manage",
  "navigation",
  "ngTouch",
  "notification",
  "pascalprecht.translate",
  "rest",
  "settings",
  "templates-main",
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for updating or resetting the favicon of the current page.
 */
angular.module("index").factory("iconService", [
  "$rootScope",
  function iconService($rootScope) {
    var service = {};

    /**
     * The URL of the image used for the low-resolution (64x64) favicon. This
     * MUST match the URL which is set statically within index.html.
     *
     * @constant
     * @type String
     */
    var DEFAULT_SMALL_ICON_URL = "images/logo-64.png";

    /**
     * The URL of the image used for the high-resolution (144x144) favicon. This
     * MUST match the URL which is set statically within index.html.
     *
     * @constant
     * @type String
     */
    var DEFAULT_LARGE_ICON_URL = "images/logo-144.png";

    /**
     * JQuery-wrapped array of all link tags which point to the small,
     * low-resolution page icon.
     *
     * @type Element[]
     */
    var smallIcons = $('link[rel=icon][href="' + DEFAULT_SMALL_ICON_URL + '"]');

    /**
     * JQuery-wrapped array of all link tags which point to the large,
     * high-resolution page icon.
     *
     * @type Element[]
     */
    var largeIcons = $('link[rel=icon][href="' + DEFAULT_LARGE_ICON_URL + '"]');

    /**
     * Generates an icon by scaling the provided image to fit the given
     * dimensions, returning a canvas containing the generated icon.
     *
     * @param {HTMLCanvasElement} canvas
     *     A canvas element containing the image which should be scaled to
     *     produce the contents of the generated icon.
     *
     * @param {Number} width
     *     The width of the icon to generate, in pixels.
     *
     * @param {Number} height
     *     The height of the icon to generate, in pixels.
     *
     * @returns {HTMLCanvasElement}
     *     A new canvas element having the given dimensions and containing the
     *     provided image, scaled to fit.
     */
    var generateIcon = function generateIcon(canvas, width, height) {
      // Create icon canvas having the provided dimensions
      var icon = document.createElement("canvas");
      icon.width = width;
      icon.height = height;

      // Calculate the scale factor necessary to fit the provided image
      // within the icon dimensions
      var scale = Math.min(width / canvas.width, height / canvas.height);

      // Calculate the dimensions and position of the scaled image within
      // the icon, offsetting the image such that it is centered
      var scaledWidth = canvas.width * scale;
      var scaledHeight = canvas.height * scale;
      var offsetX = (width - scaledWidth) / 2;
      var offsetY = (height - scaledHeight) / 2;

      // Draw the icon, scaling the provided image as necessary
      var context = icon.getContext("2d");
      context.drawImage(canvas, offsetX, offsetY, scaledWidth, scaledHeight);
      return icon;
    };

    /**
     * Temporarily sets the icon of the current page to the contents of the
     * given canvas element. The image within the canvas element will be
     * automatically scaled and centered to fit within the dimensions of the
     * page icons. The page icons will be automatically reset to their original
     * values upon navigation.
     *
     * @param {HTMLCanvasElement} canvas
     *     The canvas element containing the icon. If this value is null or
     *     undefined, this function has no effect.
     */
    service.setIcons = function setIcons(canvas) {
      // Do nothing if no canvas provided
      if (!canvas) return;

      // Assign low-resolution (64x64) icon
      var smallIcon = generateIcon(canvas, 64, 64);
      smallIcons.attr("href", smallIcon.toDataURL("image/png"));

      // Assign high-resolution (144x144) icon
      var largeIcon = generateIcon(canvas, 144, 144);
      largeIcons.attr("href", largeIcon.toDataURL("image/png"));
    };

    /**
     * Resets the icons of the current page to their original values, undoing
     * any previous calls to setIcons(). This function is automatically invoked
     * upon navigation.
     */
    service.setDefaultIcons = function setDefaultIcons() {
      smallIcons.attr("href", DEFAULT_SMALL_ICON_URL);
      largeIcons.attr("href", DEFAULT_LARGE_ICON_URL);
    };

    // Automatically reset page icons after navigation
    $rootScope.$on("$routeChangeSuccess", function resetIcon() {
      service.setDefaultIcons();
    });

    return service;
  },
]);

angular.module("index").factory("$routeParams", [
  function () {
    return {
      id: Date.now().toString(32),
      params: window.PARAMETERS || {},
    };
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which provides a filtering text input field which automatically
 * produces a filtered subset of the elements of some given array.
 */
angular.module("list").directive("guacFilter", [
  function guacFilter() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The property to which a subset of the provided array will be
         * assigned.
         *
         * @type Array
         */
        filteredItems: "=",

        /**
         * The placeholder text to display within the filter input field
         * when no filter has been provided.
         *
         * @type String
         */
        placeholder: "&",

        /**
         * An array of objects to filter. A subset of this array will be
         * exposed as filteredItems.
         *
         * @type Array
         */
        items: "&",

        /**
         * An array of expressions to filter against for each object in the
         * items array. These expressions must be Angular expressions
         * which resolve to properties on the objects in the items array.
         *
         * @type String[]
         */
        properties: "&",
      },

      templateUrl: "app/list/templates/guacFilter.html",
      controller: [
        "$scope",
        "$injector",
        function guacFilterController($scope, $injector) {
          // Required types
          var FilterPattern = $injector.get("FilterPattern");

          /**
           * The pattern object to use when filtering items.
           *
           * @type FilterPattern
           */
          var filterPattern = new FilterPattern($scope.properties());

          /**
           * The filter search string to use to restrict the displayed items.
           *
           * @type String
           */
          $scope.searchString = null;

          /**
           * Applies the current filter predicate, filtering all provided
           * items and storing the result in filteredItems.
           */
          var updateFilteredItems = function updateFilteredItems() {
            var items = $scope.items();
            if (items)
              $scope.filteredItems = items.filter(filterPattern.predicate);
            else $scope.filteredItems = [];
          };

          // Recompile and refilter when pattern is changed
          $scope.$watch(
            "searchString",
            function searchStringChanged(searchString) {
              filterPattern.compile(searchString);
              updateFilteredItems();
            }
          );

          // Refilter when items change
          $scope.$watchCollection($scope.items, function itemsChanged() {
            updateFilteredItems();
          });
        },
      ],
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which provides pagination controls, along with a paginated
 * subset of the elements of some given array.
 */
angular.module("list").directive("guacPager", [
  function guacPager() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The property to which a subset of the provided array will be
         * assigned.
         *
         * @type Array
         */
        page: "=",

        /**
         * The maximum number of items per page.
         *
         * @type Number
         */
        pageSize: "&",

        /**
         * The maximum number of page choices to provide, regardless of the
         * total number of pages.
         *
         * @type Number
         */
        pageCount: "&",

        /**
         * An array objects to paginate. Subsets of this array will be
         * exposed as pages.
         *
         * @type Array
         */
        items: "&",
      },

      templateUrl: "app/list/templates/guacPager.html",
      controller: [
        "$scope",
        function guacPagerController($scope) {
          /**
           * The default size of a page, if not provided via the pageSize
           * attribute.
           *
           * @type Number
           */
          var DEFAULT_PAGE_SIZE = 10;

          /**
           * The default maximum number of page choices to provide, if a
           * value is not providede via the pageCount attribute.
           *
           * @type Number
           */
          var DEFAULT_PAGE_COUNT = 11;

          /**
           * An array of arrays, where the Nth array contains the contents of
           * the Nth page.
           *
           * @type Array[]
           */
          var pages = [];

          /**
           * The number of the first selectable page.
           *
           * @type Number;
           */
          $scope.firstPage = 1;

          /**
           * The number of the page immediately before the currently-selected
           * page.
           *
           * @type Number;
           */
          $scope.previousPage = 1;

          /**
           * The number of the currently-selected page.
           *
           * @type Number;
           */
          $scope.currentPage = 1;

          /**
           * The number of the page immediately after the currently-selected
           * page.
           *
           * @type Number;
           */
          $scope.nextPage = 1;

          /**
           * The number of the last selectable page.
           *
           * @type Number;
           */
          $scope.lastPage = 1;

          /**
           * An array of relevant page numbers that the user may want to jump
           * to directly.
           *
           * @type Number[]
           */
          $scope.pageNumbers = [];

          /**
           * Updates the displayed page number choices.
           */
          var updatePageNumbers = function updatePageNumbers() {
            // Get page count
            var pageCount = $scope.pageCount() || DEFAULT_PAGE_COUNT;

            // Determine start/end of page window
            var windowStart = $scope.currentPage - (pageCount - 1) / 2;
            var windowEnd = windowStart + pageCount - 1;

            // Shift window as necessary if it extends beyond the first page
            if (windowStart < $scope.firstPage) {
              windowEnd = Math.min(
                $scope.lastPage,
                windowEnd - windowStart + $scope.firstPage
              );
              windowStart = $scope.firstPage;
            }

            // Shift window as necessary if it extends beyond the last page
            else if (windowEnd > $scope.lastPage) {
              windowStart = Math.max(
                1,
                windowStart - windowEnd + $scope.lastPage
              );
              windowEnd = $scope.lastPage;
            }

            // Generate list of relevant page numbers
            $scope.pageNumbers = [];
            for (
              var pageNumber = windowStart;
              pageNumber <= windowEnd;
              pageNumber++
            )
              $scope.pageNumbers.push(pageNumber);
          };

          /**
           * Iterates through the bound items array, splitting it into pages
           * based on the current page size.
           */
          var updatePages = function updatePages() {
            // Get current items and page size
            var items = $scope.items();
            var pageSize = $scope.pageSize() || DEFAULT_PAGE_SIZE;

            // Clear current pages
            pages = [];

            // Only split into pages if items actually exist
            if (items) {
              // Split into pages of pageSize items each
              for (var i = 0; i < items.length; i += pageSize)
                pages.push(items.slice(i, i + pageSize));
            }

            // Update minimum and maximum values
            $scope.firstPage = 1;
            $scope.lastPage = pages.length;

            // Select an appropriate page
            var adjustedCurrentPage = Math.min(
              $scope.lastPage,
              Math.max($scope.firstPage, $scope.currentPage)
            );
            $scope.selectPage(adjustedCurrentPage);
          };

          /**
           * Selects the page having the given number, assigning that page to
           * the property bound to the page attribute. If no such page
           * exists, the property will be set to undefined instead. Valid
           * page numbers begin at 1.
           *
           * @param {Number} page
           *     The number of the page to select. Valid page numbers begin
           *     at 1.
           */
          $scope.selectPage = function selectPage(page) {
            // Select the chosen page
            $scope.currentPage = page;
            $scope.page = pages[page - 1];

            // Update next/previous page numbers
            $scope.nextPage = Math.min($scope.lastPage, $scope.currentPage + 1);
            $scope.previousPage = Math.max(
              $scope.firstPage,
              $scope.currentPage - 1
            );

            // Update which page numbers are shown
            updatePageNumbers();
          };

          /**
           * Returns whether the given page number can be legally selected
           * via selectPage(), resulting in a different page being shown.
           *
           * @param {Number} page
           *     The page number to check.
           *
           * @returns {Boolean}
           *     true if the page having the given number can be selected,
           *     false otherwise.
           */
          $scope.canSelectPage = function canSelectPage(page) {
            return (
              page !== $scope.currentPage &&
              page >= $scope.firstPage &&
              page <= $scope.lastPage
            );
          };

          /**
           * Returns whether the page having the given number is currently
           * selected.
           *
           * @param {Number} page
           *     The page number to check.
           *
           * @returns {Boolean}
           *     true if the page having the given number is currently
           *     selected, false otherwise.
           */
          $scope.isSelected = function isSelected(page) {
            return page === $scope.currentPage;
          };

          /**
           * Returns whether pages exist before the first page listed in the
           * pageNumbers array.
           *
           * @returns {Boolean}
           *     true if pages exist before the first page listed in the
           *     pageNumbers array, false otherwise.
           */
          $scope.hasMorePagesBefore = function hasMorePagesBefore() {
            var firstPageNumber = $scope.pageNumbers[0];
            return firstPageNumber !== $scope.firstPage;
          };

          /**
           * Returns whether pages exist after the last page listed in the
           * pageNumbers array.
           *
           * @returns {Boolean}
           *     true if pages exist after the last page listed in the
           *     pageNumbers array, false otherwise.
           */
          $scope.hasMorePagesAfter = function hasMorePagesAfter() {
            var lastPageNumber =
              $scope.pageNumbers[$scope.pageNumbers.length - 1];
            return lastPageNumber !== $scope.lastPage;
          };

          // Update available pages when available items are changed
          $scope.$watchCollection($scope.items, function itemsChanged() {
            updatePages();
          });

          // Update available pages when page size is changed
          $scope.$watch($scope.pageSize, function pageSizeChanged() {
            updatePages();
          });

          // Update available page numbers when page count is changed
          $scope.$watch($scope.pageCount, function pageCountChanged() {
            updatePageNumbers();
          });
        },
      ],
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Updates the priority of the sorting property given by "guac-sort-property"
 * within the SortOrder object given by "guac-sort-order". The CSS classes
 * "sort-primary" and "sort-descending" will be applied to the associated
 * element depending on the priority and sort direction of the given property.
 *
 * The associated element will automatically be assigned the "sortable" CSS
 * class.
 */
angular.module("list").directive("guacSortOrder", [
  function guacFocus() {
    return {
      restrict: "A",

      link: function linkGuacSortOrder($scope, $element, $attrs) {
        /**
         * The object defining the sorting order.
         *
         * @type SortOrder
         */
        var sortOrder = $scope.$eval($attrs.guacSortOrder);

        /**
         * The name of the property whose priority within the sort order
         * is controlled by this directive.
         *
         * @type String
         */
        var sortProperty = $scope.$eval($attrs.guacSortProperty);

        /**
         * Returns whether the sort property defined via the
         * "guac-sort-property" attribute is the primary sort property of
         * the associated sort order.
         *
         * @returns {Boolean}
         *     true if the sort property defined via the
         *     "guac-sort-property" attribute is the primary sort property,
         *     false otherwise.
         */
        var isPrimary = function isPrimary() {
          return sortOrder.primary === sortProperty;
        };

        /**
         * Returns whether the primary property of the sort order is
         * sorted in descending order.
         *
         * @returns {Boolean}
         *     true if the primary property of the sort order is sorted in
         *     descending order, false otherwise.
         */
        var isDescending = function isDescending() {
          return sortOrder.descending;
        };

        // Assign "sortable" class to associated element
        $element.addClass("sortable");

        // Add/remove "sort-primary" class depending on sort order
        $scope.$watch(isPrimary, function primaryChanged(primary) {
          $element.toggleClass("sort-primary", primary);
        });

        // Add/remove "sort-descending" class depending on sort order
        $scope.$watch(isDescending, function descendingChanged(descending) {
          $element.toggleClass("sort-descending", descending);
        });

        // Update sort order when clicked
        $element[0].addEventListener("click", function clicked() {
          $scope.$evalAsync(function updateSortOrder() {
            sortOrder.togglePrimary(sortProperty);
          });
        });
      }, // end guacSortOrder link function
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which graphically represents an individual user.
 */
angular.module("list").directive("guacUserItem", [
  function guacUserItem() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The username of the user represented by this guacUserItem.
         *
         * @type String
         */
        username: "=",
      },

      templateUrl: "app/list/templates/guacUserItem.html",
      controller: [
        "$scope",
        "$injector",
        function guacUserItemController($scope, $injector) {
          // Required types
          var AuthenticationResult = $injector.get("AuthenticationResult");

          // Required services
          var $translate = $injector.get("$translate");

          /**
           * The string to display when listing the user having the provided
           * username. Generally, this will be the username itself, but can
           * also be an arbitrary human-readable representation of the user,
           * or null if the display name is not yet determined.
           *
           * @type String
           */
          $scope.displayName = null;

          /**
           * Returns whether the username provided to this directive denotes
           * a user that authenticated anonymously.
           *
           * @returns {Boolean}
           *     true if the username provided represents an anonymous user,
           *     false otherwise.
           */
          $scope.isAnonymous = function isAnonymous() {
            return $scope.username === AuthenticationResult.ANONYMOUS_USERNAME;
          };

          // Update display name whenever provided username changes
          $scope.$watch("username", function updateDisplayName(username) {
            // If the user is anonymous, pull the display name for anonymous
            // users from the translation service
            if ($scope.isAnonymous()) {
              $translate("LIST.TEXT_ANONYMOUS_USER").then(
                function retrieveAnonymousDisplayName(anonymousDisplayName) {
                  $scope.displayName = anonymousDisplayName;
                },
                angular.noop
              );
            }

            // For all other users, use the username verbatim
            else $scope.displayName = username;
          });
        },
      ], // end controller
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Module for displaying, sorting, and filtering the contents of a list, split
 * into multiple pages.
 */
angular.module("list", ["auth"]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for defining the FilterPattern class.
 */
angular.module("list").factory("FilterPattern", [
  "$injector",
  function defineFilterPattern($injector) {
    // Required types
    var FilterToken = $injector.get("FilterToken");
    var IPv4Network = $injector.get("IPv4Network");
    var IPv6Network = $injector.get("IPv6Network");

    // Required services
    var $parse = $injector.get("$parse");

    /**
     * Object which handles compilation of filtering predicates as used by
     * the Angular "filter" filter. Predicates are compiled from a user-
     * specified search string.
     *
     * @constructor
     * @param {String[]} expressions
     *     The Angular expressions whose values are to be filtered.
     */
    var FilterPattern = function FilterPattern(expressions) {
      /**
       * Reference to this instance.
       *
       * @type FilterPattern
       */
      var filterPattern = this;

      /**
       * Filter predicate which simply matches everything. This function
       * always returns true.
       *
       * @returns {Boolean}
       *     true.
       */
      var nullPredicate = function nullPredicate() {
        return true;
      };

      /**
       * Array of getters corresponding to the Angular expressions provided
       * to the constructor of this class. The functions returns are those
       * produced by the $parse service.
       *
       * @type Function[]
       */
      var getters = [];

      // Parse all expressions
      angular.forEach(expressions, function parseExpression(expression) {
        getters.push($parse(expression));
      });

      /**
       * Determines whether the given object contains properties that match
       * the given string, according to the provided getters.
       *
       * @param {Object} object
       *     The object to match against.
       *
       * @param {String} str
       *     The string to match.
       *
       * @returns {Boolean}
       *     true if the object matches the given string, false otherwise.
       */
      var matchesString = function matchesString(object, str) {
        // For each defined getter
        for (var i = 0; i < getters.length; i++) {
          // Retrieve value of current getter
          var value = getters[i](object);

          // If the value matches the pattern, the whole object matches
          if (String(value).toLowerCase().indexOf(str) !== -1) return true;
        }

        // No matches found
        return false;
      };

      /**
       * Determines whether the given object contains properties that match
       * the given IPv4 network, according to the provided getters.
       *
       * @param {Object} object
       *     The object to match against.
       *
       * @param {IPv4Network} network
       *     The IPv4 network to match.
       *
       * @returns {Boolean}
       *     true if the object matches the given network, false otherwise.
       */
      var matchesIPv4 = function matchesIPv4(object, network) {
        // For each defined getter
        for (var i = 0; i < getters.length; i++) {
          // Test each possible IPv4 address within the string against
          // the given IPv4 network
          var addresses = String(getters[i](object)).split(/[^0-9.]+/);
          for (var j = 0; j < addresses.length; j++) {
            var value = IPv4Network.parse(addresses[j]);
            if (value && network.contains(value)) return true;
          }
        }

        // No matches found
        return false;
      };

      /**
       * Determines whether the given object contains properties that match
       * the given IPv6 network, according to the provided getters.
       *
       * @param {Object} object
       *     The object to match against.
       *
       * @param {IPv6Network} network
       *     The IPv6 network to match.
       *
       * @returns {Boolean}
       *     true if the object matches the given network, false otherwise.
       */
      var matchesIPv6 = function matchesIPv6(object, network) {
        // For each defined getter
        for (var i = 0; i < getters.length; i++) {
          // Test each possible IPv6 address within the string against
          // the given IPv6 network
          var addresses = String(getters[i](object)).split(/[^0-9A-Fa-f:]+/);
          for (var j = 0; j < addresses.length; j++) {
            var value = IPv6Network.parse(addresses[j]);
            if (value && network.contains(value)) return true;
          }
        }

        // No matches found
        return false;
      };

      /**
       * Determines whether the given object matches the given filter pattern
       * token.
       *
       * @param {Object} object
       *     The object to match the token against.
       *
       * @param {FilterToken} token
       *     The token from the tokenized filter pattern to match aginst the
       *     given object.
       *
       * @returns {Boolean}
       *     true if the object matches the token, false otherwise.
       */
      var matchesToken = function matchesToken(object, token) {
        // Match depending on token type
        switch (token.type) {
          // Simple string literal
          case "LITERAL":
            return matchesString(object, token.value);

          // IPv4 network address / subnet
          case "IPV4_NETWORK":
            return matchesIPv4(object, token.value);

          // IPv6 network address / subnet
          case "IPV6_NETWORK":
            return matchesIPv6(object, token.value);

          // Unsupported token type
          default:
            return false;
        }
      };

      /**
       * The current filtering predicate.
       *
       * @type Function
       */
      this.predicate = nullPredicate;

      /**
       * Compiles the given pattern string, assigning the resulting filter
       * predicate. The resulting predicate will accept only objects that
       * match the given pattern.
       *
       * @param {String} pattern
       *     The pattern to compile.
       */
      this.compile = function compile(pattern) {
        // If no pattern provided, everything matches
        if (!pattern) {
          filterPattern.predicate = nullPredicate;
          return;
        }

        // Tokenize pattern, converting to lower case for case-insensitive matching
        var tokens = FilterToken.tokenize(pattern.toLowerCase());

        // Return predicate which matches against the value of any getter in the getters array
        filterPattern.predicate = function matchesAllTokens(object) {
          // False if any token does not match
          for (var i = 0; i < tokens.length; i++) {
            if (!matchesToken(object, tokens[i])) return false;
          }

          // True if all tokens matched
          return true;
        };
      };
    };

    return FilterPattern;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for defining the FilterToken class.
 */
angular.module("list").factory("FilterToken", [
  "$injector",
  function defineFilterToken($injector) {
    // Required types
    var IPv4Network = $injector.get("IPv4Network");
    var IPv6Network = $injector.get("IPv6Network");

    /**
     * An arbitrary token having an associated type and value.
     *
     * @constructor
     * @param {String} consumed
     *     The input string consumed to produce this token.
     *
     * @param {String} type
     *     The type of this token. Each legal type name is a property within
     *     FilterToken.Types.
     *
     * @param {Object} value
     *     The value of this token. The type of this value is determined by
     *     the token type.
     */
    var FilterToken = function FilterToken(consumed, type, value) {
      /**
       * The input string that was consumed to produce this token.
       *
       * @type String
       */
      this.consumed = consumed;

      /**
       * The type of this token. Each legal type name is a property within
       * FilterToken.Types.
       *
       * @type String
       */
      this.type = type;

      /**
       * The value of this token.
       *
       * @type Object
       */
      this.value = value;
    };

    /**
     * All legal token types, and corresponding functions which match them.
     * Each function returns the parsed token, or null if no such token was
     * found.
     *
     * @type Object.<String, Function>
     */
    FilterToken.Types = {
      /**
       * An IPv4 address or subnet. The value of an IPV4_NETWORK token is an
       * IPv4Network.
       */
      IPV4_NETWORK: function parseIPv4(str) {
        var pattern = /^\S+/;

        // Read first word via regex
        var matches = pattern.exec(str);
        if (!matches) return null;

        // Validate and parse as IPv4 address
        var network = IPv4Network.parse(matches[0]);
        if (!network) return null;

        return new FilterToken(matches[0], "IPV4_NETWORK", network);
      },

      /**
       * An IPv6 address or subnet. The value of an IPV6_NETWORK token is an
       * IPv6Network.
       */
      IPV6_NETWORK: function parseIPv6(str) {
        var pattern = /^\S+/;

        // Read first word via regex
        var matches = pattern.exec(str);
        if (!matches) return null;

        // Validate and parse as IPv6 address
        var network = IPv6Network.parse(matches[0]);
        if (!network) return null;

        return new FilterToken(matches[0], "IPV6_NETWORK", network);
      },

      /**
       * A string literal, which may be quoted. The value of a LITERAL token
       * is a String.
       */
      LITERAL: function parseLiteral(str) {
        var pattern = /^"([^"]*)"|^\S+/;

        // Validate against pattern
        var matches = pattern.exec(str);
        if (!matches) return null;

        // If literal is quoted, parse within the quotes
        if (matches[1])
          return new FilterToken(matches[0], "LITERAL", matches[1]);

        //  Otherwise, literal is unquoted
        return new FilterToken(matches[0], "LITERAL", matches[0]);
      },

      /**
       * Arbitrary contiguous whitespace. The value of a WHITESPACE token is
       * a String.
       */
      WHITESPACE: function parseWhitespace(str) {
        var pattern = /^\s+/;

        // Validate against pattern
        var matches = pattern.exec(str);
        if (!matches) return null;

        //  Generate token from matching whitespace
        return new FilterToken(matches[0], "WHITESPACE", matches[0]);
      },
    };

    /**
     * Tokenizes the given string, returning an array of tokens. Whitespace
     * tokens are dropped.
     *
     * @param {String} str
     *     The string to tokenize.
     *
     * @returns {FilterToken[]}
     *     All tokens identified within the given string, in order.
     */
    FilterToken.tokenize = function tokenize(str) {
      var tokens = [];

      /**
       * Returns the first token on the current string, removing the token
       * from that string.
       *
       * @returns FilterToken
       *     The first token on the string, or null if no tokens match.
       */
      var popToken = function popToken() {
        // Attempt to find a matching token
        for (var type in FilterToken.Types) {
          // Get matching function for current type
          var matcher = FilterToken.Types[type];

          // If token matches, return the matching group
          var token = matcher(str);
          if (token) {
            str = str.substring(token.consumed.length);
            return token;
          }
        }

        // No match
        return null;
      };

      // Tokenize input until no input remains
      while (str) {
        // Remove first token
        var token = popToken();
        if (!token) break;

        // Add token to tokens array, if not whitespace
        if (token.type !== "WHITESPACE") tokens.push(token);
      }

      return tokens;
    };

    return FilterToken;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for defining the IPv4Network class.
 */
angular.module("list").factory("IPv4Network", [
  function defineIPv4Network() {
    /**
     * Represents an IPv4 network as a pairing of base address and netmask,
     * both of which are in binary form. To obtain an IPv4Network from
     * standard CIDR or dot-decimal notation, use IPv4Network.parse().
     *
     * @constructor
     * @param {Number} address
     *     The IPv4 address of the network in binary form.
     *
     * @param {Number} netmask
     *     The IPv4 netmask of the network in binary form.
     */
    var IPv4Network = function IPv4Network(address, netmask) {
      /**
       * Reference to this IPv4Network.
       *
       * @type IPv4Network
       */
      var network = this;

      /**
       * The binary address of this network. This will be a 32-bit quantity.
       *
       * @type Number
       */
      this.address = address;

      /**
       * The binary netmask of this network. This will be a 32-bit quantity.
       *
       * @type Number
       */
      this.netmask = netmask;

      /**
       * Tests whether the given network is entirely within this network,
       * taking into account the base addresses and netmasks of both.
       *
       * @param {IPv4Network} other
       *     The network to test.
       *
       * @returns {Boolean}
       *     true if the other network is entirely within this network, false
       *     otherwise.
       */
      this.contains = function contains(other) {
        return (
          network.address === (other.address & other.netmask & network.netmask)
        );
      };
    };

    /**
     * Parses the given string as an IPv4 address or subnet, returning an
     * IPv4Network object which describes that address or subnet.
     *
     * @param {String} str
     *     The string to parse.
     *
     * @returns {IPv4Network}
     *     The parsed network, or null if the given string is not valid.
     */
    IPv4Network.parse = function parse(str) {
      // Regex which matches the general form of IPv4 addresses
      var pattern =
        /^([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})(?:\/([0-9]{1,2}))?$/;

      // Parse IPv4 address via regex
      var match = pattern.exec(str);
      if (!match) return null;

      // Parse netmask, if given
      var netmask = 0xffffffff;
      if (match[5]) {
        var bits = parseInt(match[5]);
        if (bits > 0 && bits <= 32) netmask = 0xffffffff << (32 - bits);
      }

      // Read each octet onto address
      var address = 0;
      for (var i = 1; i <= 4; i++) {
        // Validate octet range
        var octet = parseInt(match[i]);
        if (octet > 255) return null;

        // Shift on octet
        address = (address << 8) | octet;
      }

      return new IPv4Network(address, netmask);
    };

    return IPv4Network;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for defining the IPv6Network class.
 */
angular.module("list").factory("IPv6Network", [
  function defineIPv6Network() {
    /**
     * Represents an IPv6 network as a pairing of base address and netmask,
     * both of which are in binary form. To obtain an IPv6Network from
     * standard CIDR notation, use IPv6Network.parse().
     *
     * @constructor
     * @param {Number[]} addressGroups
     *     Array of eight IPv6 address groups in binary form, each group being
     *     16-bit number.
     *
     * @param {Number[]} netmaskGroups
     *     Array of eight IPv6 netmask groups in binary form, each group being
     *     16-bit number.
     */
    var IPv6Network = function IPv6Network(addressGroups, netmaskGroups) {
      /**
       * Reference to this IPv6Network.
       *
       * @type IPv6Network
       */
      var network = this;

      /**
       * The 128-bit binary address of this network as an array of eight
       * 16-bit numbers.
       *
       * @type Number[]
       */
      this.addressGroups = addressGroups;

      /**
       * The 128-bit binary netmask of this network as an array of eight
       * 16-bit numbers.
       *
       * @type Number
       */
      this.netmaskGroups = netmaskGroups;

      /**
       * Tests whether the given network is entirely within this network,
       * taking into account the base addresses and netmasks of both.
       *
       * @param {IPv6Network} other
       *     The network to test.
       *
       * @returns {Boolean}
       *     true if the other network is entirely within this network, false
       *     otherwise.
       */
      this.contains = function contains(other) {
        // Test that each masked 16-bit quantity matches the address
        for (var i = 0; i < 8; i++) {
          if (
            network.addressGroups[i] !==
            (other.addressGroups[i] &
              other.netmaskGroups[i] &
              network.netmaskGroups[i])
          )
            return false;
        }

        // All 16-bit numbers match
        return true;
      };
    };

    /**
     * Generates a netmask having the given number of ones on the left side.
     * All other bits within the netmask will be zeroes. The resulting netmask
     * will be an array of eight numbers, where each number corresponds to a
     * 16-bit group of an IPv6 netmask.
     *
     * @param {Number} bits
     *     The number of ones to include on the left side of the netmask. All
     *     other bits will be zeroes.
     *
     * @returns {Number[]}
     *     The generated netmask, having the given number of ones.
     */
    var generateNetmask = function generateNetmask(bits) {
      var netmask = [];

      // Only generate up to 128 bits
      bits = Math.min(128, bits);

      // Add any contiguous 16-bit sections of ones
      while (bits >= 16) {
        netmask.push(0xffff);
        bits -= 16;
      }

      // Add remaining ones
      if (bits > 0 && bits <= 16)
        netmask.push(0xffff & (0xffff << (16 - bits)));

      // Add remaining zeroes
      while (netmask.length < 8) netmask.push(0);

      return netmask;
    };

    /**
     * Splits the given IPv6 address or partial address into its corresponding
     * 16-bit groups.
     *
     * @param {String} str
     *     The IPv6 address or partial address to split.
     *
     * @returns Number[]
     *     The numeric values of all 16-bit groups within the given IPv6
     *     address.
     */
    var splitAddress = function splitAddress(str) {
      var address = [];

      // Split address into groups
      var groups = str.split(":");

      // Parse the numeric value of each group
      angular.forEach(groups, function addGroup(group) {
        var value = parseInt(group || "0", 16);
        address.push(value);
      });

      return address;
    };

    /**
     * Parses the given string as an IPv6 address or subnet, returning an
     * IPv6Network object which describes that address or subnet.
     *
     * @param {String} str
     *     The string to parse.
     *
     * @returns {IPv6Network}
     *     The parsed network, or null if the given string is not valid.
     */
    IPv6Network.parse = function parse(str) {
      // Regex which matches the general form of IPv6 addresses
      var pattern =
        /^([0-9a-f]{0,4}(?::[0-9a-f]{0,4}){0,7})(?:\/([0-9]{1,3}))?$/;

      // Parse rudimentary IPv6 address via regex
      var match = pattern.exec(str);
      if (!match) return null;

      // Extract address and netmask from parse results
      var unparsedAddress = match[1];
      var unparsedNetmask = match[2];

      // Parse netmask
      var netmask;
      if (unparsedNetmask) netmask = generateNetmask(parseInt(unparsedNetmask));
      else netmask = generateNetmask(128);

      var address;

      // Separate based on the double-colon, if present
      var doubleColon = unparsedAddress.indexOf("::");

      // If no double colon, just split into groups
      if (doubleColon === -1) address = splitAddress(unparsedAddress);
      // Otherwise, split either side of the double colon and pad with zeroes
      else {
        // Parse either side of the double colon
        var leftAddress = splitAddress(
          unparsedAddress.substring(0, doubleColon)
        );
        var rightAddress = splitAddress(
          unparsedAddress.substring(doubleColon + 2)
        );

        // Pad with zeroes up to address length
        var remaining = 8 - leftAddress.length - rightAddress.length;
        while (remaining > 0) {
          leftAddress.push(0);
          remaining--;
        }

        address = leftAddress.concat(rightAddress);
      }

      // Validate length of address
      if (address.length !== 8) return null;

      return new IPv6Network(address, netmask);
    };

    return IPv6Network;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for defining the SortOrder class.
 */
angular.module("list").factory("SortOrder", [
  function defineSortOrder() {
    /**
     * Maintains a sorting predicate as required by the Angular orderBy filter.
     * The order of properties sorted by the predicate can be altered while
     * otherwise maintaining the sort order.
     *
     * @constructor
     * @param {String[]} predicate
     *     The properties to sort by, in order of precidence.
     */
    var SortOrder = function SortOrder(predicate) {
      /**
       * Reference to this instance.
       *
       * @type SortOrder
       */
      var sortOrder = this;

      /**
       * The current sorting predicate.
       *
       * @type String[]
       */
      this.predicate = predicate;

      /**
       * The name of the highest-precedence sorting property.
       *
       * @type String
       */
      this.primary = predicate[0];

      /**
       * Whether the highest-precedence sorting property is sorted in
       * descending order.
       *
       * @type Boolean
       */
      this.descending = false;

      // Handle initially-descending primary properties
      if (this.primary.charAt(0) === "-") {
        this.primary = this.primary.substring(1);
        this.descending = true;
      }

      /**
       * Reorders the currently-defined predicate such that the named
       * property takes precidence over all others. The property will be
       * sorted in ascending order unless otherwise specified.
       *
       * @param {String} name
       *     The name of the property to reorder by.
       *
       * @param {Boolean} [descending=false]
       *     Whether the property should be sorted in descending order. By
       *     default, all properties are sorted in ascending order.
       */
      this.reorder = function reorder(name, descending) {
        // Build ascending and descending predicate components
        var ascendingName = name;
        var descendingName = "-" + name;

        // Remove requested property from current predicate
        sortOrder.predicate = sortOrder.predicate.filter(
          function notRequestedProperty(current) {
            return current !== ascendingName && current !== descendingName;
          }
        );

        // Add property to beginning of predicate
        if (descending) sortOrder.predicate.unshift(descendingName);
        else sortOrder.predicate.unshift(ascendingName);

        // Update sorted state
        sortOrder.primary = name;
        sortOrder.descending = !!descending;
      };

      /**
       * Returns whether the sort order is primarily determined by the given
       * property.
       *
       * @param {String} property
       *     The name of the property to check.
       *
       * @returns {Boolean}
       *     true if the sort order is primarily determined by the given
       *     property, false otherwise.
       */
      this.isSortedBy = function isSortedBy(property) {
        return sortOrder.primary === property;
      };

      /**
       * Sets the primary sorting property to the given property, if not already
       * set. If already set, the ascending/descending sort order is toggled.
       *
       * @param {String} property
       *     The name of the property to assign as the primary sorting property.
       */
      this.togglePrimary = function togglePrimary(property) {
        // Sort in ascending order by new property, if different
        if (!sortOrder.isSortedBy(property)) sortOrder.reorder(property, false);
        // Otherwise, toggle sort order
        else sortOrder.reorder(property, !sortOrder.descending);
      };
    };

    return SortOrder;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Module for handling common localization-related tasks.
 */
angular.module("locale", []);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for loading translation definition files, conforming to the
 * angular-translate documentation for custom translation loaders:
 *
 * https://github.com/angular-translate/angular-translate/wiki/Asynchronous-loading#using-custom-loader-service
 */
angular.module("locale").factory("translationLoader", [
  "$injector",
  function translationLoader($injector) {
    // Required services
    var $http = $injector.get("$http");
    var $q = $injector.get("$q");
    var cacheService = $injector.get("cacheService");
    var languageService = $injector.get("languageService");

    /**
     * Satisfies a translation request for the given key by searching for the
     * translation files for each key in the given array, in order. The request
     * fails only if none of the files can be found.
     *
     * @param {Deferred} deferred
     *     The Deferred object to resolve or reject depending on whether at
     *     least one translation file can be successfully loaded.
     *
     * @param {String} requestedKey
     *     The originally-requested language key.
     *
     * @param {String[]} remainingKeys
     *     The keys of the languages to attempt to load, in order, where the
     *     first key in this array is the language to try within this function
     *     call. The first key in the array is not necessarily the originally-
     *     requested language key.
     */
    var satisfyTranslation = function satisfyTranslation(
      deferred,
      requestedKey,
      remainingKeys
    ) {
      // Get current language key
      var currentKey = remainingKeys.shift();

      // If no languages to try, "succeed" with an empty translation (force fallback)
      if (!currentKey) {
        deferred.resolve("{}");
        return;
      }

      /**
       * Continues trying possible translation files until no possibilities
       * exist.
       *
       * @private
       */
      var tryNextTranslation = function tryNextTranslation() {
        satisfyTranslation(deferred, requestedKey, remainingKeys);
      };

      // Retrieve list of supported languages
      languageService
        .getLanguages()

        // Attempt to retrieve translation if language is supported
        .then(
          function retrievedLanguages(languages) {
            // Skip retrieval if language is not supported
            if (!(currentKey in languages)) {
              tryNextTranslation();
              return;
            }

            // Attempt to retrieve language
            $http({
              cache: cacheService.languages,
              method: "GET",
              url: "translations/" + encodeURIComponent(currentKey) + ".json",
            })
              // Resolve promise if translation retrieved successfully
              .then(
                function translationFileRetrieved(request) {
                  deferred.resolve(request.data);
                },

                // Retry with remaining languages if translation file could not be
                // retrieved
                tryNextTranslation
              );
          },

          // Retry with remaining languages if translation does not exist
          tryNextTranslation
        );
    };

    /**
     * Given a valid language key, returns all possible legal variations of
     * that key. Currently, this will be the given key and the given key
     * without the country code. If the key has no country code, only the
     * given key will be included in the returned array.
     *
     * @param {String} key
     *     The language key to generate variations of.
     *
     * @returns {String[]}
     *     All possible variations of the given language key.
     */
    var getKeyVariations = function getKeyVariations(key) {
      var underscore = key.indexOf("_");

      // If no underscore, only one possibility
      if (underscore === -1) return [key];

      // Otherwise, include the lack of country code as an option
      return [key, key.substr(0, underscore)];
    };

    /**
     * Custom loader function for angular-translate which loads the desired
     * language file dynamically via HTTP. If the language file cannot be
     * found, the fallback language is used instead.
     *
     * @param {Object} options
     *     Arbitrary options, containing at least a "key" property which
     *     contains the requested language key.
     *
     * @returns {Promise.<Object>}
     *     A promise which resolves to the requested translation string object.
     */
    return function loadTranslationFile(options) {
      var translation = $q.defer();

      // Satisfy the translation request using possible variations of the given key
      satisfyTranslation(
        translation,
        options.key,
        getKeyVariations(options.key)
      );

      // Return promise which is resolved only after the translation file is loaded
      return translation.promise;
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for manipulating translation strings and translation table
 * identifiers.
 */
angular.module("locale").factory("translationStringService", [
  function translationStringService() {
    var service = {};

    /**
     * Given an arbitrary identifier, returns the corresponding translation
     * table identifier. Translation table identifiers are uppercase strings,
     * word components separated by single underscores. For example, the
     * string "Swap red/blue" would become "SWAP_RED_BLUE".
     *
     * @param {String} identifier
     *     The identifier to transform into a translation table identifier.
     *
     * @returns {String}
     *     The translation table identifier.
     */
    service.canonicalize = function canonicalize(identifier) {
      return identifier.replace(/[^a-zA-Z0-9]+/g, "_").toUpperCase();
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive for displaying an arbitrary login form.
 */
angular.module("login").directive("guacLogin", [
  function guacLogin() {
    // Login directive
    var directive = {
      restrict: "E",
      replace: true,
      templateUrl: "app/login/templates/login.html",
    };

    // Login directive scope
    directive.scope = {
      /**
       * An optional instructional message to display within the login
       * dialog.
       *
       * @type TranslatableMessage
       */
      helpText: "=",

      /**
       * The login form or set of fields. This will be displayed to the user
       * to capture their credentials.
       *
       * @type Field[]
       */
      form: "=",

      /**
       * A map of all field name/value pairs that have already been provided.
       * If not null, the user will be prompted to continue their login
       * attempt using only the fields which remain.
       */
      values: "=",
    };

    // Controller for login directive
    directive.controller = [
      "$scope",
      "$injector",
      function loginController($scope, $injector) {
        // Required types
        var Error = $injector.get("Error");
        var Field = $injector.get("Field");

        // Required services
        var $rootScope = $injector.get("$rootScope");
        var $route = $injector.get("$route");
        var authenticationService = $injector.get("authenticationService");
        var requestService = $injector.get("requestService");

        /**
         * The initial value for all login fields. Note that this value must
         * not be null. If null, empty fields may not be submitted back to the
         * server at all, causing the request to misrepresent true login state.
         *
         * For example, if a user receives an insufficient credentials error
         * due to their password expiring, failing to provide that new password
         * should result in the user submitting their username, original
         * password, and empty new password. If only the username and original
         * password are sent, the invalid password reset request will be
         * indistinguishable from a normal login attempt.
         *
         * @constant
         * @type String
         */
        var DEFAULT_FIELD_VALUE = "";

        /**
         * A description of the error that occurred during login, if any.
         *
         * @type TranslatableMessage
         */
        $scope.loginError = null;

        /**
         * All form values entered by the user, as parameter name/value pairs.
         *
         * @type Object.<String, String>
         */
        $scope.enteredValues = {};

        /**
         * All form fields which have not yet been filled by the user.
         *
         * @type Field[]
         */
        $scope.remainingFields = [];

        /**
         * Whether an authentication attempt has been submitted. This will be
         * set to true once credentials have been submitted and will only be
         * reset to false once the attempt has been fully processed, including
         * rerouting the user to the requested page if the attempt succeeded.
         *
         * @type Boolean
         */
        $scope.submitted = false;

        /**
         * The field that is most relevant to the user.
         *
         * @type Field
         */
        $scope.relevantField = null;

        /**
         * Returns whether a previous login attempt is continuing.
         *
         * @return {Boolean}
         *     true if a previous login attempt is continuing, false otherwise.
         */
        $scope.isContinuation = function isContinuation() {
          // The login is continuing if any parameter values are provided
          for (var name in $scope.values) return true;

          return false;
        };

        // Ensure provided values are included within entered values, even if
        // they have no corresponding input fields
        $scope.$watch("values", function resetEnteredValues(values) {
          angular.extend($scope.enteredValues, values || {});
        });

        // Update field information when form is changed
        $scope.$watch("form", function resetRemainingFields(fields) {
          // If no fields are provided, then no fields remain
          if (!fields) {
            $scope.remainingFields = [];
            return;
          }

          // Filter provided fields against provided values
          $scope.remainingFields = fields.filter(function isRemaining(field) {
            return !(field.name in $scope.values);
          });

          // Set default values for all unset fields
          angular.forEach($scope.remainingFields, function setDefault(field) {
            if (!$scope.enteredValues[field.name])
              $scope.enteredValues[field.name] = DEFAULT_FIELD_VALUE;
          });

          $scope.relevantField = getRelevantField();
        });

        /**
         * Submits the currently-specified username and password to the
         * authentication service, redirecting to the main view if successful.
         */
        $scope.login = function login() {
          // Authentication is now in progress
          $scope.submitted = true;

          // Start with cleared status
          $scope.loginError = null;

          // Attempt login once existing session is destroyed
          authenticationService
            .authenticate($scope.enteredValues)

            // Retry route upon success (entered values will be cleared only
            // after route change has succeeded as this can take time)
            .then(function loginSuccessful() {
              $route.reload();
            })

            [
              // Reset upon failure
              "catch"
            ](
              requestService.createErrorCallback(function loginFailed(error) {
                // Initial submission is complete and has failed
                $scope.submitted = false;

                // Clear out passwords if the credentials were rejected for any reason
                if (error.type !== Error.Type.INSUFFICIENT_CREDENTIALS) {
                  // Flag generic error for invalid login
                  if (error.type === Error.Type.INVALID_CREDENTIALS)
                    $scope.loginError = {
                      key: "LOGIN.ERROR_INVALID_LOGIN",
                    };
                  // Display error if anything else goes wrong
                  else $scope.loginError = error.translatableMessage;

                  // Reset all remaining fields to default values, but
                  // preserve any usernames
                  angular.forEach(
                    $scope.remainingFields,
                    function clearEnteredValueIfPassword(field) {
                      if (
                        field.type !== Field.Type.USERNAME &&
                        field.name in $scope.enteredValues
                      )
                        $scope.enteredValues[field.name] = DEFAULT_FIELD_VALUE;
                    }
                  );
                }
              })
            );
        };

        /**
         * Returns the field most relevant to the user given the current state
         * of the login process. This will normally be the first empty field.
         *
         * @return {Field}
         *     The field most relevant, null if there is no single most relevant
         *     field.
         */
        var getRelevantField = function getRelevantField() {
          for (var i = 0; i < $scope.remainingFields.length; i++) {
            var field = $scope.remainingFields[i];
            if (!$scope.enteredValues[field.name]) return field;
          }

          return null;
        };

        // Reset state after authentication and routing have succeeded
        $rootScope.$on("$routeChangeSuccess", function routeChanged() {
          $scope.enteredValues = {};
          $scope.submitted = false;
        });
      },
    ];

    return directive;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The module for the login functionality.
 */
angular.module("login", ["element", "form", "navigation"]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The controller for editing or creating connections.
 */
angular.module("manage").controller("manageConnectionController", [
  "$scope",
  "$injector",
  function manageConnectionController($scope, $injector) {
    // Required types
    var Connection = $injector.get("Connection");
    var ConnectionGroup = $injector.get("ConnectionGroup");
    var HistoryEntryWrapper = $injector.get("HistoryEntryWrapper");
    var ManagementPermissions = $injector.get("ManagementPermissions");
    var PermissionSet = $injector.get("PermissionSet");
    var Protocol = $injector.get("Protocol");

    // Required services
    var $location = $injector.get("$location");
    var $q = $injector.get("$q");
    var $routeParams = $injector.get("$routeParams");
    var $translate = $injector.get("$translate");
    var authenticationService = $injector.get("authenticationService");
    var connectionService = $injector.get("connectionService");
    var connectionGroupService = $injector.get("connectionGroupService");
    var permissionService = $injector.get("permissionService");
    var requestService = $injector.get("requestService");
    var schemaService = $injector.get("schemaService");

    /**
     * The unique identifier of the data source containing the connection being
     * edited.
     *
     * @type String
     */
    $scope.selectedDataSource = $routeParams.dataSource;

    /**
     * The identifier of the original connection from which this connection is
     * being cloned. Only valid if this is a new connection.
     *
     * @type String
     */
    var cloneSourceIdentifier = $location.search().clone;

    /**
     * The identifier of the connection being edited. If a new connection is
     * being created, this will not be defined.
     *
     * @type String
     */
    var identifier = $routeParams.id;

    /**
     * All known protocols.
     *
     * @type Object.<String, Protocol>
     */
    $scope.protocols = null;

    /**
     * The root connection group of the connection group hierarchy.
     *
     * @type ConnectionGroup
     */
    $scope.rootGroup = null;

    /**
     * The connection being modified.
     *
     * @type Connection
     */
    $scope.connection = null;

    /**
     * The parameter name/value pairs associated with the connection being
     * modified.
     *
     * @type Object.<String, String>
     */
    $scope.parameters = null;

    /**
     * The date format for use within the connection history.
     *
     * @type String
     */
    $scope.historyDateFormat = null;

    /**
     * The usage history of the connection being modified.
     *
     * @type HistoryEntryWrapper[]
     */
    $scope.historyEntryWrappers = null;

    /**
     * The management-related actions that the current user may perform on the
     * connection currently being created/modified, or null if the current
     * user's permissions have not yet been loaded.
     *
     * @type ManagementPermissions
     */
    $scope.managementPermissions = null;

    /**
     * All available connection attributes. This is only the set of attribute
     * definitions, organized as logical groupings of attributes, not attribute
     * values.
     *
     * @type Form[]
     */
    $scope.attributes = null;

    /**
     * Returns whether critical data has completed being loaded.
     *
     * @returns {Boolean}
     *     true if enough data has been loaded for the user interface to be
     *     useful, false otherwise.
     */
    $scope.isLoaded = function isLoaded() {
      return (
        $scope.protocols !== null &&
        $scope.rootGroup !== null &&
        $scope.connection !== null &&
        $scope.parameters !== null &&
        $scope.historyDateFormat !== null &&
        $scope.historyEntryWrappers !== null &&
        $scope.managementPermissions !== null &&
        $scope.attributes !== null
      );
    };

    /**
     * Loads the data associated with the connection having the given
     * identifier, preparing the interface for making modifications to that
     * existing connection.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the connection to
     *     load.
     *
     * @param {String} identifier
     *     The identifier of the connection to load.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared for
     *     editing the given connection.
     */
    var loadExistingConnection = function loadExistingConnection(
      dataSource,
      identifier
    ) {
      return $q
        .all({
          connection: connectionService.getConnection(dataSource, identifier),
          historyEntries: connectionService.getConnectionHistory(
            dataSource,
            identifier
          ),
          parameters: connectionService.getConnectionParameters(
            dataSource,
            identifier
          ),
        })
        .then(function connectionDataRetrieved(values) {
          $scope.connection = values.connection;
          $scope.parameters = values.parameters;

          // Wrap all history entries for sake of display
          $scope.historyEntryWrappers = [];
          angular.forEach(
            values.historyEntries,
            function wrapHistoryEntry(historyEntry) {
              $scope.historyEntryWrappers.push(
                new HistoryEntryWrapper(historyEntry)
              );
            }
          );
        });
    };

    /**
     * Loads the data associated with the connection having the given
     * identifier, preparing the interface for cloning that existing
     * connection.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the connection
     *     to be cloned.
     *
     * @param {String} identifier
     *     The identifier of the connection being cloned.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared for
     *     cloning the given connection.
     */
    var loadClonedConnection = function loadClonedConnection(
      dataSource,
      identifier
    ) {
      return $q
        .all({
          connection: connectionService.getConnection(dataSource, identifier),
          parameters: connectionService.getConnectionParameters(
            dataSource,
            identifier
          ),
        })
        .then(function connectionDataRetrieved(values) {
          $scope.connection = values.connection;
          $scope.parameters = values.parameters;

          // Clear the identifier field because this connection is new
          delete $scope.connection.identifier;

          // Cloned connections have no history
          $scope.historyEntryWrappers = [];
        });
    };

    /**
     * Loads skeleton connection data, preparing the interface for creating a
     * new connection.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared for
     *     creating a new connection.
     */
    var loadSkeletonConnection = function loadSkeletonConnection() {
      // Use skeleton connection object with no associated permissions,
      // history, or parameters
      $scope.connection = new Connection({
        protocol: "vnc",
        parentIdentifier: $location.search().parent,
      });
      $scope.historyEntryWrappers = [];
      $scope.parameters = {};

      return $q.resolve();
    };

    /**
     * Loads the data required for performing the management task requested
     * through the route parameters given at load time, automatically preparing
     * the interface for editing an existing connection, cloning an existing
     * connection, or creating an entirely new connection.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared
     *     for performing the requested management task.
     */
    var loadRequestedConnection = function loadRequestedConnection() {
      // If we are editing an existing connection, pull its data
      if (identifier)
        return loadExistingConnection($scope.selectedDataSource, identifier);

      // If we are cloning an existing connection, pull its data instead
      if (cloneSourceIdentifier)
        return loadClonedConnection(
          $scope.selectedDataSource,
          cloneSourceIdentifier
        );

      // If we are creating a new connection, populate skeleton connection data
      return loadSkeletonConnection();
    };

    // Populate interface with requested data
    $q.all({
      connectionData: loadRequestedConnection(),
      attributes: schemaService.getConnectionAttributes(
        $scope.selectedDataSource
      ),
      permissions: permissionService.getEffectivePermissions(
        $scope.selectedDataSource,
        authenticationService.getCurrentUsername()
      ),
      protocols: schemaService.getProtocols($scope.selectedDataSource),
      rootGroup: connectionGroupService.getConnectionGroupTree(
        $scope.selectedDataSource,
        ConnectionGroup.ROOT_IDENTIFIER,
        [PermissionSet.ObjectPermissionType.ADMINISTER]
      ),
    }).then(function dataRetrieved(values) {
      $scope.attributes = values.attributes;
      $scope.protocols = values.protocols;
      $scope.rootGroup = values.rootGroup;

      $scope.managementPermissions = ManagementPermissions.fromPermissionSet(
        values.permissions,
        PermissionSet.SystemPermissionType.CREATE_CONNECTION,
        PermissionSet.hasConnectionPermission,
        identifier
      );
    }, requestService.DIE);

    // Get history date format
    $translate("MANAGE_CONNECTION.FORMAT_HISTORY_START").then(
      function historyDateFormatReceived(historyDateFormat) {
        $scope.historyDateFormat = historyDateFormat;
      },
      angular.noop
    );

    /**
     * @borrows Protocol.getNamespace
     */
    $scope.getNamespace = Protocol.getNamespace;

    /**
     * @borrows Protocol.getName
     */
    $scope.getProtocolName = Protocol.getName;

    /**
     * Cancels all pending edits, returning to the main list of connections
     * within the selected data source.
     */
    $scope.returnToConnectionList = function returnToConnectionList() {
      $location.url(
        "/settings/" +
          encodeURIComponent($scope.selectedDataSource) +
          "/connections"
      );
    };

    /**
     * Cancels all pending edits, opening an edit page for a new connection
     * which is prepopulated with the data from the connection currently being edited.
     */
    $scope.cloneConnection = function cloneConnection() {
      $location
        .path(
          "/manage/" +
            encodeURIComponent($scope.selectedDataSource) +
            "/connections"
        )
        .search("clone", identifier);
    };

    /**
     * Saves the current connection, creating a new connection or updating the
     * existing connection, returning a promise which is resolved if the save
     * operation succeeds and rejected if the save operation fails.
     *
     * @returns {Promise}
     *     A promise which is resolved if the save operation succeeds and is
     *     rejected with an {@link Error} if the save operation fails.
     */
    $scope.saveConnection = function saveConnection() {
      $scope.connection.parameters = $scope.parameters;

      // Save the connection
      return connectionService.saveConnection(
        $scope.selectedDataSource,
        $scope.connection
      );
    };

    /**
     * Deletes the current connection, returning a promise which is resolved if
     * the delete operation succeeds and rejected if the delete operation fails.
     *
     * @returns {Promise}
     *     A promise which is resolved if the delete operation succeeds and is
     *     rejected with an {@link Error} if the delete operation fails.
     */
    $scope.deleteConnection = function deleteConnection() {
      return connectionService.deleteConnection(
        $scope.selectedDataSource,
        $scope.connection
      );
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The controller for editing or creating connection groups.
 */
angular.module("manage").controller("manageConnectionGroupController", [
  "$scope",
  "$injector",
  function manageConnectionGroupController($scope, $injector) {
    // Required types
    var ConnectionGroup = $injector.get("ConnectionGroup");
    var ManagementPermissions = $injector.get("ManagementPermissions");
    var PermissionSet = $injector.get("PermissionSet");

    // Required services
    var $location = $injector.get("$location");
    var $q = $injector.get("$q");
    var $routeParams = $injector.get("$routeParams");
    var authenticationService = $injector.get("authenticationService");
    var connectionGroupService = $injector.get("connectionGroupService");
    var permissionService = $injector.get("permissionService");
    var requestService = $injector.get("requestService");
    var schemaService = $injector.get("schemaService");

    /**
     * The unique identifier of the data source containing the connection group
     * being edited.
     *
     * @type String
     */
    $scope.selectedDataSource = $routeParams.dataSource;

    /**
     * The identifier of the original connection group from which this
     * connection group is being cloned. Only valid if this is a new
     * connection group.
     *
     * @type String
     */
    var cloneSourceIdentifier = $location.search().clone;

    /**
     * The identifier of the connection group being edited. If a new connection
     * group is being created, this will not be defined.
     *
     * @type String
     */
    var identifier = $routeParams.id;

    /**
     * Available connection group types, as translation string / internal value
     * pairs.
     *
     * @type Object[]
     */
    $scope.types = [
      {
        label: "MANAGE_CONNECTION_GROUP.NAME_TYPE_ORGANIZATIONAL",
        value: ConnectionGroup.Type.ORGANIZATIONAL,
      },
      {
        label: "MANAGE_CONNECTION_GROUP.NAME_TYPE_BALANCING",
        value: ConnectionGroup.Type.BALANCING,
      },
    ];

    /**
     * The root connection group of the connection group hierarchy.
     *
     * @type ConnectionGroup
     */
    $scope.rootGroup = null;

    /**
     * The connection group being modified.
     *
     * @type ConnectionGroup
     */
    $scope.connectionGroup = null;

    /**
     * The management-related actions that the current user may perform on the
     * connection group currently being created/modified, or null if the current
     * user's permissions have not yet been loaded.
     *
     * @type ManagementPermissions
     */
    $scope.managementPermissions = null;

    /**
     * All available connection group attributes. This is only the set of
     * attribute definitions, organized as logical groupings of attributes, not
     * attribute values.
     *
     * @type Form[]
     */
    $scope.attributes = null;

    /**
     * Returns whether critical data has completed being loaded.
     *
     * @returns {Boolean}
     *     true if enough data has been loaded for the user interface to be
     *     useful, false otherwise.
     */
    $scope.isLoaded = function isLoaded() {
      return (
        $scope.rootGroup !== null &&
        $scope.connectionGroup !== null &&
        $scope.managementPermissions !== null &&
        $scope.attributes !== null
      );
    };

    /**
     * Loads the data associated with the connection group having the given
     * identifier, preparing the interface for making modifications to that
     * existing connection group.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the connection
     *     group to load.
     *
     * @param {String} identifier
     *     The identifier of the connection group to load.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared for
     *     editing the given connection group.
     */
    var loadExistingConnectionGroup = function loadExistingConnectionGroup(
      dataSource,
      identifier
    ) {
      return connectionGroupService
        .getConnectionGroup(dataSource, identifier)
        .then(function connectionGroupReceived(connectionGroup) {
          $scope.connectionGroup = connectionGroup;
        });
    };

    /**
     * Loads the data associated with the connection group having the given
     * identifier, preparing the interface for cloning that existing
     * connection group.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the connection
     *     group to be cloned.
     *
     * @param {String} identifier
     *     The identifier of the connection group being cloned.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared for
     *     cloning the given connection group.
     */
    var loadClonedConnectionGroup = function loadClonedConnectionGroup(
      dataSource,
      identifier
    ) {
      return connectionGroupService
        .getConnectionGroup(dataSource, identifier)
        .then(function connectionGroupReceived(connectionGroup) {
          $scope.connectionGroup = connectionGroup;
          delete $scope.connectionGroup.identifier;
        });
    };

    /**
     * Loads skeleton connection group data, preparing the interface for
     * creating a new connection group.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared for
     *     creating a new connection group.
     */
    var loadSkeletonConnectionGroup = function loadSkeletonConnectionGroup() {
      // Use skeleton connection group object with specified parent
      $scope.connectionGroup = new ConnectionGroup({
        parentIdentifier: $location.search().parent,
      });

      return $q.resolve();
    };

    /**
     * Loads the data required for performing the management task requested
     * through the route parameters given at load time, automatically preparing
     * the interface for editing an existing connection group, cloning an
     * existing connection group, or creating an entirely new connection group.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared
     *     for performing the requested management task.
     */
    var loadRequestedConnectionGroup = function loadRequestedConnectionGroup() {
      // If we are editing an existing connection group, pull its data
      if (identifier)
        return loadExistingConnectionGroup(
          $scope.selectedDataSource,
          identifier
        );

      // If we are cloning an existing connection group, pull its data
      // instead
      if (cloneSourceIdentifier)
        return loadClonedConnectionGroup(
          $scope.selectedDataSource,
          cloneSourceIdentifier
        );

      // If we are creating a new connection group, populate skeleton
      // connection group data
      return loadSkeletonConnectionGroup();
    };

    // Query the user's permissions for the current connection group
    $q.all({
      connectionGroupData: loadRequestedConnectionGroup(),
      attributes: schemaService.getConnectionGroupAttributes(
        $scope.selectedDataSource
      ),
      permissions: permissionService.getEffectivePermissions(
        $scope.selectedDataSource,
        authenticationService.getCurrentUsername()
      ),
      rootGroup: connectionGroupService.getConnectionGroupTree(
        $scope.selectedDataSource,
        ConnectionGroup.ROOT_IDENTIFIER,
        [PermissionSet.ObjectPermissionType.ADMINISTER]
      ),
    }).then(function connectionGroupDataRetrieved(values) {
      $scope.attributes = values.attributes;
      $scope.rootGroup = values.rootGroup;

      $scope.managementPermissions = ManagementPermissions.fromPermissionSet(
        values.permissions,
        PermissionSet.SystemPermissionType.CREATE_CONNECTION,
        PermissionSet.hasConnectionGroupPermission,
        identifier
      );
    }, requestService.DIE);

    /**
     * Cancels all pending edits, returning to the main list of connections
     * within the selected data source.
     */
    $scope.returnToConnectionList = function returnToConnectionList() {
      $location.path(
        "/settings/" +
          encodeURIComponent($scope.selectedDataSource) +
          "/connections"
      );
    };

    /**
     * Cancels all pending edits, opening an edit page for a new connection
     * group which is prepopulated with the data from the connection group
     * currently being edited.
     */
    $scope.cloneConnectionGroup = function cloneConnectionGRoup() {
      $location
        .path(
          "/manage/" +
            encodeURIComponent($scope.selectedDataSource) +
            "/connectionGroups"
        )
        .search("clone", identifier);
    };

    /**
     * Saves the current connection group, creating a new connection group or
     * updating the existing connection group, returning a promise which is
     * resolved if the save operation succeeds and rejected if the save
     * operation fails.
     *
     * @returns {Promise}
     *     A promise which is resolved if the save operation succeeds and is
     *     rejected with an {@link Error} if the save operation fails.
     */
    $scope.saveConnectionGroup = function saveConnectionGroup() {
      return connectionGroupService.saveConnectionGroup(
        $scope.selectedDataSource,
        $scope.connectionGroup
      );
    };

    /**
     * Deletes the current connection group, returning a promise which is
     * resolved if the delete operation succeeds and rejected if the delete
     * operation fails.
     *
     * @returns {Promise}
     *     A promise which is resolved if the delete operation succeeds and is
     *     rejected with an {@link Error} if the delete operation fails.
     */
    $scope.deleteConnectionGroup = function deleteConnectionGroup() {
      return connectionGroupService.deleteConnectionGroup(
        $scope.selectedDataSource,
        $scope.connectionGroup
      );
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The controller for editing or creating sharing profiles.
 */
angular.module("manage").controller("manageSharingProfileController", [
  "$scope",
  "$injector",
  function manageSharingProfileController($scope, $injector) {
    // Required types
    var ManagementPermissions = $injector.get("ManagementPermissions");
    var SharingProfile = $injector.get("SharingProfile");
    var PermissionSet = $injector.get("PermissionSet");
    var Protocol = $injector.get("Protocol");

    // Required services
    var $location = $injector.get("$location");
    var $q = $injector.get("$q");
    var $routeParams = $injector.get("$routeParams");
    var authenticationService = $injector.get("authenticationService");
    var connectionService = $injector.get("connectionService");
    var permissionService = $injector.get("permissionService");
    var requestService = $injector.get("requestService");
    var schemaService = $injector.get("schemaService");
    var sharingProfileService = $injector.get("sharingProfileService");

    /**
     * The unique identifier of the data source containing the sharing profile
     * being edited.
     *
     * @type String
     */
    $scope.selectedDataSource = $routeParams.dataSource;

    /**
     * The identifier of the original sharing profile from which this sharing
     * profile is being cloned. Only valid if this is a new sharing profile.
     *
     * @type String
     */
    var cloneSourceIdentifier = $location.search().clone;

    /**
     * The identifier of the sharing profile being edited. If a new sharing
     * profile is being created, this will not be defined.
     *
     * @type String
     */
    var identifier = $routeParams.id;

    /**
     * Map of protocol name to corresponding Protocol object.
     *
     * @type Object.<String, Protocol>
     */
    $scope.protocols = null;

    /**
     * The sharing profile being modified.
     *
     * @type SharingProfile
     */
    $scope.sharingProfile = null;

    /**
     * The parameter name/value pairs associated with the sharing profile being
     * modified.
     *
     * @type Object.<String, String>
     */
    $scope.parameters = null;

    /**
     * The management-related actions that the current user may perform on the
     * sharing profile currently being created/modified, or null if the current
     * user's permissions have not yet been loaded.
     *
     * @type ManagementPermissions
     */
    $scope.managementPermissions = null;

    /**
     * All available sharing profile attributes. This is only the set of
     * attribute definitions, organized as logical groupings of attributes, not
     * attribute values.
     *
     * @type Form[]
     */
    $scope.attributes = null;

    /**
     * Returns whether critical data has completed being loaded.
     *
     * @returns {Boolean}
     *     true if enough data has been loaded for the user interface to be
     *     useful, false otherwise.
     */
    $scope.isLoaded = function isLoaded() {
      return (
        $scope.protocols !== null &&
        $scope.sharingProfile !== null &&
        $scope.primaryConnection !== null &&
        $scope.parameters !== null &&
        $scope.managementPermissions !== null &&
        $scope.attributes !== null
      );
    };

    /**
     * Loads the data associated with the sharing profile having the given
     * identifier, preparing the interface for making modifications to that
     * existing sharing profile.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the sharing
     *     profile to load.
     *
     * @param {String} identifier
     *     The identifier of the sharing profile to load.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared for
     *     editing the given sharing profile.
     */
    var loadExistingSharingProfile = function loadExistingSharingProfile(
      dataSource,
      identifier
    ) {
      return $q
        .all({
          sharingProfile: sharingProfileService.getSharingProfile(
            dataSource,
            identifier
          ),
          parameters: sharingProfileService.getSharingProfileParameters(
            dataSource,
            identifier
          ),
        })
        .then(function sharingProfileDataRetrieved(values) {
          $scope.sharingProfile = values.sharingProfile;
          $scope.parameters = values.parameters;

          // Load connection object for associated primary connection
          return connectionService
            .getConnection(
              dataSource,
              values.sharingProfile.primaryConnectionIdentifier
            )
            .then(function connectionRetrieved(connection) {
              $scope.primaryConnection = connection;
            });
        });
    };

    /**
     * Loads the data associated with the sharing profile having the given
     * identifier, preparing the interface for cloning that existing
     * sharing profile.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the sharing
     *     profile to be cloned.
     *
     * @param {String} identifier
     *     The identifier of the sharing profile being cloned.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared for
     *     cloning the given sharing profile.
     */
    var loadClonedSharingProfile = function loadClonedSharingProfile(
      dataSource,
      identifier
    ) {
      return $q
        .all({
          sharingProfile: sharingProfileService.getSharingProfile(
            dataSource,
            identifier
          ),
          parameters: sharingProfileService.getSharingProfileParameters(
            dataSource,
            identifier
          ),
        })
        .then(function sharingProfileDataRetrieved(values) {
          $scope.sharingProfile = values.sharingProfile;
          $scope.parameters = values.parameters;

          // Clear the identifier field because this sharing profile is new
          delete $scope.sharingProfile.identifier;

          // Load connection object for associated primary connection
          return connectionService
            .getConnection(
              dataSource,
              values.sharingProfile.primaryConnectionIdentifier
            )
            .then(function connectionRetrieved(connection) {
              $scope.primaryConnection = connection;
            });
        });
    };

    /**
     * Loads skeleton sharing profile data, preparing the interface for
     * creating a new sharing profile.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the sharing
     *     profile to be created.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared for
     *     creating a new sharing profile.
     */
    var loadSkeletonSharingProfile = function loadSkeletonSharingProfile(
      dataSource
    ) {
      // Use skeleton sharing profile object with no associated parameters
      $scope.sharingProfile = new SharingProfile({
        primaryConnectionIdentifier: $location.search().parent,
      });
      $scope.parameters = {};

      // Load connection object for associated primary connection
      return connectionService
        .getConnection(
          dataSource,
          $scope.sharingProfile.primaryConnectionIdentifier
        )
        .then(function connectionRetrieved(connection) {
          $scope.primaryConnection = connection;
        });
    };

    /**
     * Loads the data required for performing the management task requested
     * through the route parameters given at load time, automatically preparing
     * the interface for editing an existing sharing profile, cloning an
     * existing sharing profile, or creating an entirely new sharing profile.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared
     *     for performing the requested management task.
     */
    var loadRequestedSharingProfile = function loadRequestedSharingProfile() {
      // If we are editing an existing sharing profile, pull its data
      if (identifier)
        return loadExistingSharingProfile(
          $scope.selectedDataSource,
          identifier
        );

      // If we are cloning an existing sharing profile, pull its data instead
      if (cloneSourceIdentifier)
        return loadClonedSharingProfile(
          $scope.selectedDataSource,
          cloneSourceIdentifier
        );

      // If we are creating a new sharing profile, populate skeleton sharing
      // profile data
      return loadSkeletonSharingProfile($scope.selectedDataSource);
    };

    // Query the user's permissions for the current sharing profile
    $q.all({
      sharingProfileData: loadRequestedSharingProfile(),
      attributes: schemaService.getSharingProfileAttributes(
        $scope.selectedDataSource
      ),
      protocols: schemaService.getProtocols($scope.selectedDataSource),
      permissions: permissionService.getEffectivePermissions(
        $scope.selectedDataSource,
        authenticationService.getCurrentUsername()
      ),
    }).then(function sharingProfileDataRetrieved(values) {
      $scope.attributes = values.attributes;
      $scope.protocols = values.protocols;

      $scope.managementPermissions = ManagementPermissions.fromPermissionSet(
        values.permissions,
        PermissionSet.SystemPermissionType.CREATE_CONNECTION,
        PermissionSet.hasConnectionPermission,
        identifier
      );
    }, requestService.DIE);

    /**
     * @borrows Protocol.getNamespace
     */
    $scope.getNamespace = Protocol.getNamespace;

    /**
     * Cancels all pending edits, returning to the main list of connections
     * within the selected data source.
     */
    $scope.returnToConnectionList = function returnToConnectionList() {
      $location.url(
        "/settings/" +
          encodeURIComponent($scope.selectedDataSource) +
          "/connections"
      );
    };

    /**
     * Cancels all pending edits, opening an edit page for a new sharing profile
     * which is prepopulated with the data from the sharing profile currently
     * being edited.
     */
    $scope.cloneSharingProfile = function cloneSharingProfile() {
      $location
        .path(
          "/manage/" +
            encodeURIComponent($scope.selectedDataSource) +
            "/sharingProfiles"
        )
        .search("clone", identifier);
    };

    /**
     * Saves the current sharing profile, creating a new sharing profile or
     * updating the existing sharing profile, returning a promise which is
     * resolved if the save operation succeeds and rejected if the save
     * operation fails.
     *
     * @returns {Promise}
     *     A promise which is resolved if the save operation succeeds and is
     *     rejected with an {@link Error} if the save operation fails.
     */
    $scope.saveSharingProfile = function saveSharingProfile() {
      $scope.sharingProfile.parameters = $scope.parameters;

      // Save the sharing profile
      return sharingProfileService.saveSharingProfile(
        $scope.selectedDataSource,
        $scope.sharingProfile
      );
    };

    /**
     * Deletes the current sharing profile, returning a promise which is
     * resolved if the delete operation succeeds and rejected if the delete
     * operation fails.
     *
     * @returns {Promise}
     *     A promise which is resolved if the delete operation succeeds and is
     *     rejected with an {@link Error} if the delete operation fails.
     */
    $scope.deleteSharingProfile = function deleteSharingProfile() {
      return sharingProfileService.deleteSharingProfile(
        $scope.selectedDataSource,
        $scope.sharingProfile
      );
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The controller for editing users.
 */
angular.module("manage").controller("manageUserController", [
  "$scope",
  "$injector",
  function manageUserController($scope, $injector) {
    // Required types
    var Error = $injector.get("Error");
    var ManagementPermissions = $injector.get("ManagementPermissions");
    var PermissionFlagSet = $injector.get("PermissionFlagSet");
    var PermissionSet = $injector.get("PermissionSet");
    var User = $injector.get("User");

    // Required services
    var $location = $injector.get("$location");
    var $routeParams = $injector.get("$routeParams");
    var $q = $injector.get("$q");
    var authenticationService = $injector.get("authenticationService");
    var dataSourceService = $injector.get("dataSourceService");
    var membershipService = $injector.get("membershipService");
    var permissionService = $injector.get("permissionService");
    var requestService = $injector.get("requestService");
    var schemaService = $injector.get("schemaService");
    var userGroupService = $injector.get("userGroupService");
    var userService = $injector.get("userService");

    /**
     * The identifiers of all data sources currently available to the
     * authenticated user.
     *
     * @type String[]
     */
    var dataSources = authenticationService.getAvailableDataSources();

    /**
     * The username of the current, authenticated user.
     *
     * @type String
     */
    var currentUsername = authenticationService.getCurrentUsername();

    /**
     * The username of the original user from which this user is
     * being cloned. Only valid if this is a new user.
     *
     * @type String
     */
    var cloneSourceUsername = $location.search().clone;

    /**
     * The username of the user being edited. If a new user is
     * being created, this will not be defined.
     *
     * @type String
     */
    var username = $routeParams.id;

    /**
     * The unique identifier of the data source containing the user being
     * edited.
     *
     * @type String
     */
    $scope.dataSource = $routeParams.dataSource;

    /**
     * The string value representing the user currently being edited within the
     * permission flag set. Note that his may not match the user's actual
     * username - it is a marker that is (1) guaranteed to be associated with
     * the current user's permissions in the permission set and (2) guaranteed
     * not to collide with any user that does not represent the current user
     * within the permission set.
     *
     * @type String
     */
    $scope.selfUsername = "";

    /**
     * All user accounts associated with the same username as the account being
     * created or edited, as a map of data source identifier to the User object
     * within that data source.
     *
     * @type Object.<String, User>
     */
    $scope.users = null;

    /**
     * The user being modified.
     *
     * @type User
     */
    $scope.user = null;

    /**
     * All permissions associated with the user being modified.
     *
     * @type PermissionFlagSet
     */
    $scope.permissionFlags = null;

    /**
     * The set of permissions that will be added to the user when the user is
     * saved. Permissions will only be present in this set if they are
     * manually added, and not later manually removed before saving.
     *
     * @type PermissionSet
     */
    $scope.permissionsAdded = new PermissionSet();

    /**
     * The set of permissions that will be removed from the user when the user
     * is saved. Permissions will only be present in this set if they are
     * manually removed, and not later manually added before saving.
     *
     * @type PermissionSet
     */
    $scope.permissionsRemoved = new PermissionSet();

    /**
     * The identifiers of all user groups which can be manipulated (all groups
     * for which the user accessing this interface has UPDATE permission),
     * either through adding the current user as a member or removing the
     * current user from that group. If this information has not yet been
     * retrieved, this will be null.
     *
     * @type String[]
     */
    $scope.availableGroups = null;

    /**
     * The identifiers of all user groups of which the user is a member,
     * taking into account any user groups which will be added/removed when
     * saved. If this information has not yet been retrieved, this will be
     * null.
     *
     * @type String[]
     */
    $scope.parentGroups = null;

    /**
     * The set of identifiers of all parent user groups to which the user will
     * be added when saved. Parent groups will only be present in this set if
     * they are manually added, and not later manually removed before saving.
     *
     * @type String[]
     */
    $scope.parentGroupsAdded = [];

    /**
     * The set of identifiers of all parent user groups from which the user
     * will be removed when saved. Parent groups will only be present in this
     * set if they are manually removed, and not later manually added before
     * saving.
     *
     * @type String[]
     */
    $scope.parentGroupsRemoved = [];

    /**
     * For each applicable data source, the management-related actions that the
     * current user may perform on the user account currently being created
     * or modified, as a map of data source identifier to the
     * {@link ManagementPermissions} object describing the actions available
     * within that data source, or null if the current user's permissions have
     * not yet been loaded.
     *
     * @type Object.<String, ManagementPermissions>
     */
    $scope.managementPermissions = null;

    /**
     * All available user attributes. This is only the set of attribute
     * definitions, organized as logical groupings of attributes, not attribute
     * values.
     *
     * @type Form[]
     */
    $scope.attributes = null;

    /**
     * Returns whether critical data has completed being loaded.
     *
     * @returns {Boolean}
     *     true if enough data has been loaded for the user interface to be
     *     useful, false otherwise.
     */
    $scope.isLoaded = function isLoaded() {
      return (
        $scope.users !== null &&
        $scope.permissionFlags !== null &&
        $scope.managementPermissions !== null &&
        $scope.availableGroups !== null &&
        $scope.parentGroups !== null &&
        $scope.attributes !== null
      );
    };

    /**
     * Returns whether the current user can edit the username of the user being
     * edited within the given data source.
     *
     * @param {String} [dataSource]
     *     The identifier of the data source to check. If omitted, this will
     *     default to the currently-selected data source.
     *
     * @returns {Boolean}
     *     true if the current user can edit the username of the user being
     *     edited, false otherwise.
     */
    $scope.canEditUsername = function canEditUsername(dataSource) {
      return !username;
    };

    /**
     * Loads the data associated with the user having the given username,
     * preparing the interface for making modifications to that existing user.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user to
     *     load.
     *
     * @param {String} username
     *     The username of the user to load.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared for
     *     editing the given user.
     */
    var loadExistingUser = function loadExistingUser(dataSource, username) {
      return $q
        .all({
          users: dataSourceService.apply(
            userService.getUser,
            dataSources,
            username
          ),

          // Use empty permission set if user cannot be found
          permissions: permissionService
            .getPermissions(dataSource, username)
            ["catch"](requestService.defaultValue(new PermissionSet())),

          // Assume no parent groups if user cannot be found
          parentGroups: membershipService
            .getUserGroups(dataSource, username)
            ["catch"](requestService.defaultValue([])),
        })
        .then(function userDataRetrieved(values) {
          $scope.users = values.users;
          $scope.parentGroups = values.parentGroups;

          // Create skeleton user if user does not exist
          $scope.user =
            values.users[dataSource] ||
            new User({
              username: username,
            });

          // The current user will be associated with username of the existing
          // user in the retrieved permission set
          $scope.selfUsername = username;
          $scope.permissionFlags = PermissionFlagSet.fromPermissionSet(
            values.permissions
          );
        });
    };

    /**
     * Loads the data associated with the user having the given username,
     * preparing the interface for cloning that existing user.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user to
     *     be cloned.
     *
     * @param {String} username
     *     The username of the user being cloned.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared for
     *     cloning the given user.
     */
    var loadClonedUser = function loadClonedUser(dataSource, username) {
      return $q
        .all({
          users: dataSourceService.apply(
            userService.getUser,
            [dataSource],
            username
          ),
          permissions: permissionService.getPermissions(dataSource, username),
          parentGroups: membershipService.getUserGroups(dataSource, username),
        })
        .then(function userDataRetrieved(values) {
          $scope.users = {};
          $scope.user = values.users[dataSource];
          $scope.parentGroups = values.parentGroups;
          $scope.parentGroupsAdded = values.parentGroups;

          // The current user will be associated with cloneSourceUsername in the
          // retrieved permission set
          $scope.selfUsername = username;
          $scope.permissionFlags = PermissionFlagSet.fromPermissionSet(
            values.permissions
          );
          $scope.permissionsAdded = values.permissions;
        });
    };

    /**
     * Loads skeleton user data, preparing the interface for creating a new
     * user.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared for
     *     creating a new user.
     */
    var loadSkeletonUser = function loadSkeletonUser() {
      // No users exist regardless of data source if there is no username
      $scope.users = {};

      // Use skeleton user object with no associated permissions
      $scope.user = new User();
      $scope.parentGroups = [];
      $scope.permissionFlags = new PermissionFlagSet();

      // As no permissions are yet associated with the user, it is safe to
      // use any non-empty username as a placeholder for self-referential
      // permissions
      $scope.selfUsername = "SELF";

      return $q.resolve();
    };

    /**
     * Loads the data required for performing the management task requested
     * through the route parameters given at load time, automatically preparing
     * the interface for editing an existing user, cloning an existing user, or
     * creating an entirely new user.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared
     *     for performing the requested management task.
     */
    var loadRequestedUser = function loadRequestedUser() {
      // Pull user data and permissions if we are editing an existing user
      if (username) return loadExistingUser($scope.dataSource, username);

      // If we are cloning an existing user, pull his/her data instead
      if (cloneSourceUsername)
        return loadClonedUser($scope.dataSource, cloneSourceUsername);

      // If we are creating a new user, populate skeleton user data
      return loadSkeletonUser();
    };

    // Populate interface with requested data
    $q.all({
      userData: loadRequestedUser(),
      permissions: dataSourceService.apply(
        permissionService.getEffectivePermissions,
        dataSources,
        currentUsername
      ),
      userGroups: userGroupService.getUserGroups($scope.dataSource, [
        PermissionSet.ObjectPermissionType.UPDATE,
      ]),
      attributes: schemaService.getUserAttributes($scope.dataSource),
    }).then(function dataReceived(values) {
      $scope.attributes = values.attributes;

      $scope.managementPermissions = {};
      angular.forEach(dataSources, function addAccountPage(dataSource) {
        // Determine whether data source contains this user
        var exists = dataSource in $scope.users;

        // Add the identifiers of all modifiable user groups
        $scope.availableGroups = [];
        angular.forEach(
          values.userGroups,
          function addUserGroupIdentifier(userGroup) {
            $scope.availableGroups.push(userGroup.identifier);
          }
        );

        // Calculate management actions available for this specific account
        $scope.managementPermissions[dataSource] =
          ManagementPermissions.fromPermissionSet(
            values.permissions[dataSource],
            PermissionSet.SystemPermissionType.CREATE_USER,
            PermissionSet.hasUserPermission,
            exists ? username : null
          );
      });
    }, requestService.DIE);

    /**
     * Returns the URL for the page which manages the user account currently
     * being edited under the given data source. The given data source need not
     * be the same as the data source currently selected.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source that the URL is being
     *     generated for.
     *
     * @returns {String}
     *     The URL for the page which manages the user account currently being
     *     edited under the given data source.
     */
    $scope.getUserURL = function getUserURL(dataSource) {
      return (
        "/manage/" +
        encodeURIComponent(dataSource) +
        "/users/" +
        encodeURIComponent(username || "")
      );
    };

    /**
     * Cancels all pending edits, returning to the main list of users.
     */
    $scope.returnToUserList = function returnToUserList() {
      $location.url("/settings/users");
    };

    /**
     * Cancels all pending edits, opening an edit page for a new user
     * which is prepopulated with the data from the user currently being edited.
     */
    $scope.cloneUser = function cloneUser() {
      $location
        .path("/manage/" + encodeURIComponent($scope.dataSource) + "/users")
        .search("clone", username);
    };

    /**
     * Saves the current user, creating a new user or updating the existing
     * user depending on context, returning a promise which is resolved if the
     * save operation succeeds and rejected if the save operation fails.
     *
     * @returns {Promise}
     *     A promise which is resolved if the save operation succeeds and is
     *     rejected with an {@link Error} if the save operation fails.
     */
    $scope.saveUser = function saveUser() {
      // Verify passwords match
      if ($scope.passwordMatch !== $scope.user.password) {
        return $q.reject(
          new Error({
            translatableMessage: {
              key: "MANAGE_USER.ERROR_PASSWORD_MISMATCH",
            },
          })
        );
      }

      // Save or create the user, depending on whether the user exists
      var saveUserPromise;
      if ($scope.dataSource in $scope.users)
        saveUserPromise = userService.saveUser($scope.dataSource, $scope.user);
      else
        saveUserPromise = userService.createUser(
          $scope.dataSource,
          $scope.user
        );

      return saveUserPromise.then(function savedUser() {
        // Move permission flags if username differs from marker
        if ($scope.selfUsername !== $scope.user.username) {
          // Rename added permission
          if ($scope.permissionsAdded.userPermissions[$scope.selfUsername]) {
            $scope.permissionsAdded.userPermissions[$scope.user.username] =
              $scope.permissionsAdded.userPermissions[$scope.selfUsername];
            delete $scope.permissionsAdded.userPermissions[$scope.selfUsername];
          }

          // Rename removed permission
          if ($scope.permissionsRemoved.userPermissions[$scope.selfUsername]) {
            $scope.permissionsRemoved.userPermissions[$scope.user.username] =
              $scope.permissionsRemoved.userPermissions[$scope.selfUsername];
            delete $scope.permissionsRemoved.userPermissions[
              $scope.selfUsername
            ];
          }
        }

        // Upon success, save any changed permissions/groups
        return $q.all([
          permissionService.patchPermissions(
            $scope.dataSource,
            $scope.user.username,
            $scope.permissionsAdded,
            $scope.permissionsRemoved
          ),
          membershipService.patchUserGroups(
            $scope.dataSource,
            $scope.user.username,
            $scope.parentGroupsAdded,
            $scope.parentGroupsRemoved
          ),
        ]);
      });
    };

    /**
     * Deletes the current user, returning a promise which is resolved if the
     * delete operation succeeds and rejected if the delete operation fails.
     *
     * @returns {Promise}
     *     A promise which is resolved if the delete operation succeeds and is
     *     rejected with an {@link Error} if the delete operation fails.
     */
    $scope.deleteUser = function deleteUser() {
      return userService.deleteUser($scope.dataSource, $scope.user);
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The controller for editing user groups.
 */
angular.module("manage").controller("manageUserGroupController", [
  "$scope",
  "$injector",
  function manageUserGroupController($scope, $injector) {
    // Required types
    var ManagementPermissions = $injector.get("ManagementPermissions");
    var PermissionFlagSet = $injector.get("PermissionFlagSet");
    var PermissionSet = $injector.get("PermissionSet");
    var UserGroup = $injector.get("UserGroup");

    // Required services
    var $location = $injector.get("$location");
    var $routeParams = $injector.get("$routeParams");
    var $q = $injector.get("$q");
    var authenticationService = $injector.get("authenticationService");
    var dataSourceService = $injector.get("dataSourceService");
    var membershipService = $injector.get("membershipService");
    var permissionService = $injector.get("permissionService");
    var requestService = $injector.get("requestService");
    var schemaService = $injector.get("schemaService");
    var userGroupService = $injector.get("userGroupService");
    var userService = $injector.get("userService");

    /**
     * The identifiers of all data sources currently available to the
     * authenticated user.
     *
     * @type String[]
     */
    var dataSources = authenticationService.getAvailableDataSources();

    /**
     * The username of the current, authenticated user.
     *
     * @type String
     */
    var currentUsername = authenticationService.getCurrentUsername();

    /**
     * The identifier of the original user group from which this user group is
     * being cloned. Only valid if this is a new user group.
     *
     * @type String
     */
    var cloneSourceIdentifier = $location.search().clone;

    /**
     * The identifier of the user group being edited. If a new user group is
     * being created, this will not be defined.
     *
     * @type String
     */
    var identifier = $routeParams.id;

    /**
     * The unique identifier of the data source containing the user group being
     * edited.
     *
     * @type String
     */
    $scope.dataSource = $routeParams.dataSource;

    /**
     * All user groups associated with the same identifier as the group being
     * created or edited, as a map of data source identifier to the UserGroup
     * object within that data source.
     *
     * @type Object.<String, UserGroup>
     */
    $scope.userGroups = null;

    /**
     * The user group being modified.
     *
     * @type UserGroup
     */
    $scope.userGroup = null;

    /**
     * All permissions associated with the user group being modified.
     *
     * @type PermissionFlagSet
     */
    $scope.permissionFlags = null;

    /**
     * The set of permissions that will be added to the user group when the
     * user group is saved. Permissions will only be present in this set if they
     * are manually added, and not later manually removed before saving.
     *
     * @type PermissionSet
     */
    $scope.permissionsAdded = new PermissionSet();

    /**
     * The set of permissions that will be removed from the user group when the
     * user group is saved. Permissions will only be present in this set if they
     * are manually removed, and not later manually added before saving.
     *
     * @type PermissionSet
     */
    $scope.permissionsRemoved = new PermissionSet();

    /**
     * The identifiers of all user groups which can be manipulated (all groups
     * for which the user accessing this interface has UPDATE permission),
     * whether that means changing the members of those groups or changing the
     * groups of which those groups are members. If this information has not
     * yet been retrieved, this will be null.
     *
     * @type String[]
     */
    $scope.availableGroups = null;

    /**
     * The identifiers of all users which can be manipulated (all users for
     * which the user accessing this interface has UPDATE permission), either
     * through adding those users as a member of the current group or removing
     * those users from the current group. If this information has not yet been
     * retrieved, this will be null.
     *
     * @type String[]
     */
    $scope.availableUsers = null;

    /**
     * The identifiers of all user groups of which this group is a member,
     * taking into account any user groups which will be added/removed when
     * saved. If this information has not yet been retrieved, this will be
     * null.
     *
     * @type String[]
     */
    $scope.parentGroups = null;

    /**
     * The set of identifiers of all parent user groups to which this group
     * will be added when saved. Parent groups will only be present in this set
     * if they are manually added, and not later manually removed before
     * saving.
     *
     * @type String[]
     */
    $scope.parentGroupsAdded = [];

    /**
     * The set of identifiers of all parent user groups from which this group
     * will be removed when saved. Parent groups will only be present in this
     * set if they are manually removed, and not later manually added before
     * saving.
     *
     * @type String[]
     */
    $scope.parentGroupsRemoved = [];

    /**
     * The identifiers of all user groups which are members of this group,
     * taking into account any user groups which will be added/removed when
     * saved. If this information has not yet been retrieved, this will be
     * null.
     *
     * @type String[]
     */
    $scope.memberGroups = null;

    /**
     * The set of identifiers of all member user groups which will be added to
     * this group when saved. Member groups will only be present in this set if
     * they are manually added, and not later manually removed before saving.
     *
     * @type String[]
     */
    $scope.memberGroupsAdded = [];

    /**
     * The set of identifiers of all member user groups which will be removed
     * from this group when saved. Member groups will only be present in this
     * set if they are manually removed, and not later manually added before
     * saving.
     *
     * @type String[]
     */
    $scope.memberGroupsRemoved = [];

    /**
     * The identifiers of all users which are members of this group, taking
     * into account any users which will be added/removed when saved. If this
     * information has not yet been retrieved, this will be null.
     *
     * @type String[]
     */
    $scope.memberUsers = null;

    /**
     * The set of identifiers of all member users which will be added to this
     * group when saved. Member users will only be present in this set if they
     * are manually added, and not later manually removed before saving.
     *
     * @type String[]
     */
    $scope.memberUsersAdded = [];

    /**
     * The set of identifiers of all member users which will be removed from
     * this group when saved. Member users will only be present in this set if
     * they are manually removed, and not later manually added before saving.
     *
     * @type String[]
     */
    $scope.memberUsersRemoved = [];

    /**
     * For each applicable data source, the management-related actions that the
     * current user may perform on the user group currently being created
     * or modified, as a map of data source identifier to the
     * {@link ManagementPermissions} object describing the actions available
     * within that data source, or null if the current user's permissions have
     * not yet been loaded.
     *
     * @type Object.<String, ManagementPermissions>
     */
    $scope.managementPermissions = null;

    /**
     * All available user group attributes. This is only the set of attribute
     * definitions, organized as logical groupings of attributes, not attribute
     * values.
     *
     * @type Form[]
     */
    $scope.attributes = null;

    /**
     * Returns whether critical data has completed being loaded.
     *
     * @returns {Boolean}
     *     true if enough data has been loaded for the user group interface to
     *     be useful, false otherwise.
     */
    $scope.isLoaded = function isLoaded() {
      return (
        $scope.userGroups !== null &&
        $scope.permissionFlags !== null &&
        $scope.managementPermissions !== null &&
        $scope.availableGroups !== null &&
        $scope.availableUsers !== null &&
        $scope.parentGroups !== null &&
        $scope.memberGroups !== null &&
        $scope.memberUsers !== null &&
        $scope.attributes !== null
      );
    };

    /**
     * Returns whether the current user can edit the identifier of the user
     * group being edited.
     *
     * @returns {Boolean}
     *     true if the current user can edit the identifier of the user group
     *     being edited, false otherwise.
     */
    $scope.canEditIdentifier = function canEditIdentifier() {
      return !identifier;
    };

    /**
     * Loads the data associated with the user group having the given
     * identifier, preparing the interface for making modifications to that
     * existing user group.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user group
     *     to load.
     *
     * @param {String} identifier
     *     The unique identifier of the user group to load.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared for
     *     editing the given user group.
     */
    var loadExistingUserGroup = function loadExistingGroup(
      dataSource,
      identifier
    ) {
      return $q
        .all({
          userGroups: dataSourceService.apply(
            userGroupService.getUserGroup,
            dataSources,
            identifier
          ),

          // Use empty permission set if group cannot be found
          permissions: permissionService
            .getPermissions(dataSource, identifier, true)
            ["catch"](requestService.defaultValue(new PermissionSet())),

          // Assume no parent groups if group cannot be found
          parentGroups: membershipService
            .getUserGroups(dataSource, identifier, true)
            ["catch"](requestService.defaultValue([])),

          // Assume no member groups if group cannot be found
          memberGroups: membershipService
            .getMemberUserGroups(dataSource, identifier)
            ["catch"](requestService.defaultValue([])),

          // Assume no member users if group cannot be found
          memberUsers: membershipService
            .getMemberUsers(dataSource, identifier)
            ["catch"](requestService.defaultValue([])),
        })
        .then(function userGroupDataRetrieved(values) {
          $scope.userGroups = values.userGroups;
          $scope.parentGroups = values.parentGroups;
          $scope.memberGroups = values.memberGroups;
          $scope.memberUsers = values.memberUsers;

          // Create skeleton user group if user group does not exist
          $scope.userGroup =
            values.userGroups[dataSource] ||
            new UserGroup({
              identifier: identifier,
            });

          $scope.permissionFlags = PermissionFlagSet.fromPermissionSet(
            values.permissions
          );
        });
    };

    /**
     * Loads the data associated with the user group having the given
     * identifier, preparing the interface for cloning that existing user
     * group.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user group to
     *     be cloned.
     *
     * @param {String} identifier
     *     The unique identifier of the user group being cloned.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared for
     *     cloning the given user group.
     */
    var loadClonedUserGroup = function loadClonedUserGroup(
      dataSource,
      identifier
    ) {
      return $q
        .all({
          userGroups: dataSourceService.apply(
            userGroupService.getUserGroup,
            [dataSource],
            identifier
          ),
          permissions: permissionService.getPermissions(
            dataSource,
            identifier,
            true
          ),
          parentGroups: membershipService.getUserGroups(
            dataSource,
            identifier,
            true
          ),
          memberGroups: membershipService.getMemberUserGroups(
            dataSource,
            identifier
          ),
          memberUsers: membershipService.getMemberUsers(dataSource, identifier),
        })
        .then(function userGroupDataRetrieved(values) {
          $scope.userGroups = {};
          $scope.userGroup = values.userGroups[dataSource];
          $scope.parentGroups = values.parentGroups;
          $scope.parentGroupsAdded = values.parentGroups;
          $scope.memberGroups = values.memberGroups;
          $scope.memberGroupsAdded = values.memberGroups;
          $scope.memberUsers = values.memberUsers;
          $scope.memberUsersAdded = values.memberUsers;

          $scope.permissionFlags = PermissionFlagSet.fromPermissionSet(
            values.permissions
          );
          $scope.permissionsAdded = values.permissions;
        });
    };

    /**
     * Loads skeleton user group data, preparing the interface for creating a
     * new user group.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared for
     *     creating a new user group.
     */
    var loadSkeletonUserGroup = function loadSkeletonUserGroup() {
      // No user groups exist regardless of data source if the user group is
      // being created
      $scope.userGroups = {};

      // Use skeleton user group object with no associated permissions
      $scope.userGroup = new UserGroup();
      $scope.parentGroups = [];
      $scope.memberGroups = [];
      $scope.memberUsers = [];
      $scope.permissionFlags = new PermissionFlagSet();

      return $q.resolve();
    };

    /**
     * Loads the data required for performing the management task requested
     * through the route parameters given at load time, automatically preparing
     * the interface for editing an existing user group, cloning an existing
     * user group, or creating an entirely new user group.
     *
     * @returns {Promise}
     *     A promise which is resolved when the interface has been prepared
     *     for performing the requested management task.
     */
    var loadRequestedUserGroup = function loadRequestedUserGroup() {
      // Pull user group data and permissions if we are editing an existing
      // user group
      if (identifier)
        return loadExistingUserGroup($scope.dataSource, identifier);

      // If we are cloning an existing user group, pull its data instead
      if (cloneSourceIdentifier)
        return loadClonedUserGroup($scope.dataSource, cloneSourceIdentifier);

      // If we are creating a new user group, populate skeleton user group data
      return loadSkeletonUserGroup();
    };

    // Populate interface with requested data
    $q.all({
      userGroupData: loadRequestedUserGroup(),
      permissions: dataSourceService.apply(
        permissionService.getEffectivePermissions,
        dataSources,
        currentUsername
      ),
      userGroups: userGroupService.getUserGroups($scope.dataSource, [
        PermissionSet.ObjectPermissionType.UPDATE,
      ]),
      users: userService.getUsers($scope.dataSource, [
        PermissionSet.ObjectPermissionType.UPDATE,
      ]),
      attributes: schemaService.getUserGroupAttributes($scope.dataSource),
    }).then(function dataReceived(values) {
      $scope.attributes = values.attributes;

      $scope.managementPermissions = {};
      angular.forEach(
        dataSources,
        function deriveManagementPermissions(dataSource) {
          // Determine whether data source contains this user group
          var exists = dataSource in $scope.userGroups;

          // Add the identifiers of all modifiable user groups
          $scope.availableGroups = [];
          angular.forEach(
            values.userGroups,
            function addUserGroupIdentifier(userGroup) {
              $scope.availableGroups.push(userGroup.identifier);
            }
          );

          // Add the identifiers of all modifiable users
          $scope.availableUsers = [];
          angular.forEach(values.users, function addUserIdentifier(user) {
            $scope.availableUsers.push(user.username);
          });

          // Calculate management actions available for this specific group
          $scope.managementPermissions[dataSource] =
            ManagementPermissions.fromPermissionSet(
              values.permissions[dataSource],
              PermissionSet.SystemPermissionType.CREATE_USER_GROUP,
              PermissionSet.hasUserGroupPermission,
              exists ? identifier : null
            );
        }
      );
    }, requestService.WARN);

    /**
     * Returns the URL for the page which manages the user group currently
     * being edited under the given data source. The given data source need not
     * be the same as the data source currently selected.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source that the URL is being
     *     generated for.
     *
     * @returns {String}
     *     The URL for the page which manages the user group currently being
     *     edited under the given data source.
     */
    $scope.getUserGroupURL = function getUserGroupURL(dataSource) {
      return (
        "/manage/" +
        encodeURIComponent(dataSource) +
        "/userGroups/" +
        encodeURIComponent(identifier || "")
      );
    };

    /**
     * Cancels all pending edits, returning to the main list of user groups.
     */
    $scope.returnToUserGroupList = function returnToUserGroupList() {
      $location.url("/settings/userGroups");
    };

    /**
     * Cancels all pending edits, opening an edit page for a new user group
     * which is prepopulated with the data from the user currently being edited.
     */
    $scope.cloneUserGroup = function cloneUserGroup() {
      $location
        .path(
          "/manage/" + encodeURIComponent($scope.dataSource) + "/userGroups"
        )
        .search("clone", identifier);
    };

    /**
     * Saves the current user group, creating a new user group or updating the
     * existing user group depending on context, returning a promise which is
     * resolved if the save operation succeeds and rejected if the save
     * operation fails.
     *
     * @returns {Promise}
     *     A promise which is resolved if the save operation succeeds and is
     *     rejected with an {@link Error} if the save operation fails.
     */
    $scope.saveUserGroup = function saveUserGroup() {
      // Save or create the user group, depending on whether the user group exists
      var saveUserGroupPromise;
      if ($scope.dataSource in $scope.userGroups)
        saveUserGroupPromise = userGroupService.saveUserGroup(
          $scope.dataSource,
          $scope.userGroup
        );
      else
        saveUserGroupPromise = userGroupService.createUserGroup(
          $scope.dataSource,
          $scope.userGroup
        );

      return saveUserGroupPromise.then(function savedUserGroup() {
        return $q.all([
          permissionService.patchPermissions(
            $scope.dataSource,
            $scope.userGroup.identifier,
            $scope.permissionsAdded,
            $scope.permissionsRemoved,
            true
          ),
          membershipService.patchUserGroups(
            $scope.dataSource,
            $scope.userGroup.identifier,
            $scope.parentGroupsAdded,
            $scope.parentGroupsRemoved,
            true
          ),
          membershipService.patchMemberUserGroups(
            $scope.dataSource,
            $scope.userGroup.identifier,
            $scope.memberGroupsAdded,
            $scope.memberGroupsRemoved
          ),
          membershipService.patchMemberUsers(
            $scope.dataSource,
            $scope.userGroup.identifier,
            $scope.memberUsersAdded,
            $scope.memberUsersRemoved
          ),
        ]);
      });
    };

    /**
     * Deletes the current user group, returning a promise which is resolved if
     * the delete operation succeeds and rejected if the delete operation
     * fails.
     *
     * @returns {Promise}
     *     A promise which is resolved if the delete operation succeeds and is
     *     rejected with an {@link Error} if the delete operation fails.
     */
    $scope.deleteUserGroup = function deleteUserGroup() {
      return userGroupService.deleteUserGroup(
        $scope.dataSource,
        $scope.userGroup
      );
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive for manipulating the connection permissions granted within a
 * given {@link PermissionFlagSet}, tracking the specific permissions added or
 * removed within a separate pair of {@link PermissionSet} objects.
 */
angular.module("manage").directive("connectionPermissionEditor", [
  "$injector",
  function connectionPermissionEditor($injector) {
    // Required types
    var ConnectionGroup = $injector.get("ConnectionGroup");
    var GroupListItem = $injector.get("GroupListItem");
    var PermissionSet = $injector.get("PermissionSet");

    // Required services
    var connectionGroupService = $injector.get("connectionGroupService");
    var dataSourceService = $injector.get("dataSourceService");
    var requestService = $injector.get("requestService");

    var directive = {
      // Element only
      restrict: "E",
      replace: true,

      scope: {
        /**
         * The unique identifier of the data source associated with the
         * permissions being manipulated.
         *
         * @type String
         */
        dataSource: "=",

        /**
         * The current state of the permissions being manipulated. This
         * {@link PemissionFlagSet} will be modified as changes are made
         * through this permission editor.
         *
         * @type PermissionFlagSet
         */
        permissionFlags: "=",

        /**
         * The set of permissions that have been added, relative to the
         * initial state of the permissions being manipulated.
         *
         * @type PermissionSet
         */
        permissionsAdded: "=",

        /**
         * The set of permissions that have been removed, relative to the
         * initial state of the permissions being manipulated.
         *
         * @type PermissionSet
         */
        permissionsRemoved: "=",
      },

      templateUrl: "app/manage/templates/connectionPermissionEditor.html",
    };

    directive.controller = [
      "$scope",
      function connectionPermissionEditorController($scope) {
        /**
         * A map of data source identifiers to all root connection groups
         * within those data sources, regardless of the permissions granted for
         * the items within those groups. As only one data source is applicable
         * to any particular permission set being edited/created, this will only
         * contain a single key. If the data necessary to produce this map has
         * not yet been loaded, this will be null.
         *
         * @type Object.<String, GroupListItem>
         */
        var allRootGroups = null;

        /**
         * A map of data source identifiers to the root connection groups within
         * those data sources, excluding all items which are not explicitly
         * readable according to $scope.permissionFlags. As only one data
         * source is applicable to any particular permission set being
         * edited/created, this will only contain a single key. If the data
         * necessary to produce this map has not yet been loaded, this will be
         * null.
         *
         * @type Object.<String, GroupListItem>
         */
        var readableRootGroups = null;

        /**
         * The name of the tab within the connection permission editor which
         * displays currently selected (readable) connections only.
         *
         * @constant
         * @type String
         */
        var CURRENT_CONNECTIONS = "CURRENT_CONNECTIONS";

        /**
         * The name of the tab within the connection permission editor which
         * displays all connections, regardless of whether they are readable.
         *
         * @constant
         * @type String
         */
        var ALL_CONNECTIONS = "ALL_CONNECTIONS";

        /**
         * The names of all tabs which should be available within the
         * connection permission editor, in display order.
         *
         * @type String[]
         */
        $scope.tabs = [CURRENT_CONNECTIONS, ALL_CONNECTIONS];

        /**
         * The name of the currently selected tab.
         *
         * @type String
         */
        $scope.currentTab = ALL_CONNECTIONS;

        /**
         * Array of all connection properties that are filterable.
         *
         * @type String[]
         */
        $scope.filteredConnectionProperties = ["name", "protocol"];

        /**
         * Array of all connection group properties that are filterable.
         *
         * @type String[]
         */
        $scope.filteredConnectionGroupProperties = ["name"];

        /**
         * Returns the root groups which should be displayed within the
         * connection permission editor.
         *
         * @returns {Object.<String, GroupListItem>}
         *     The root groups which should be displayed within the connection
         *     permission editor as a map of data source identifiers to the
         *     root connection groups within those data sources.
         */
        $scope.getRootGroups = function getRootGroups() {
          return $scope.currentTab === CURRENT_CONNECTIONS
            ? readableRootGroups
            : allRootGroups;
        };

        /**
         * Returns whether the given PermissionFlagSet declares explicit READ
         * permission for the connection, connection group, or sharing profile
         * represented by the given GroupListItem.
         *
         * @param {GroupListItem} item
         *     The GroupListItem which should be checked against the
         *     PermissionFlagSet.
         *
         * @param {PemissionFlagSet} flags
         *     The set of permissions which should be used to determine whether
         *     explicit READ permission is granted for the given item.
         *
         * @returns {Boolean}
         *     true if explicit READ permission is granted for the given item
         *     according to the given permission set, false otherwise.
         */
        var isReadable = function isReadable(item, flags) {
          switch (item.type) {
            case GroupListItem.Type.CONNECTION:
              return flags.connectionPermissions.READ[item.identifier];

            case GroupListItem.Type.CONNECTION_GROUP:
              return flags.connectionGroupPermissions.READ[item.identifier];

            case GroupListItem.Type.SHARING_PROFILE:
              return flags.sharingProfilePermissions.READ[item.identifier];
          }

          return false;
        };

        /**
         * Expands all items within the tree descending from the given
         * GroupListItem which have at least one descendant for which explicit
         * READ permission is granted. The expanded state of all other items is
         * left untouched.
         *
         * @param {GroupListItem} item
         *     The GroupListItem which should be conditionally expanded
         *     depending on whether READ permission is granted for any of its
         *     descendants.
         *
         * @param {PemissionFlagSet} flags
         *     The set of permissions which should be used to determine whether
         *     the given item and its descendants are expanded.
         *
         * @returns {Boolean}
         *     true if the given item has been expanded, false otherwise.
         */
        var expandReadable = function expandReadable(item, flags) {
          // If the current item is expandable and has defined children,
          // determine whether it should be expanded
          if (item.expandable && item.children) {
            angular.forEach(item.children, function expandReadableChild(child) {
              // The parent should be expanded by default if the child is
              // expanded by default OR the permission set contains READ
              // permission on the child
              item.expanded |=
                expandReadable(child, flags) || isReadable(child, flags);
            });
          }

          return item.expanded;
        };

        /**
         * Creates a deep copy of all items within the tree descending from the
         * given GroupListItem which have at least one descendant for which
         * explicit READ permission is granted. Items which lack explicit READ
         * permission and which have no descendants having explicit READ
         * permission are omitted from the copy.
         *
         * @param {GroupListItem} item
         *     The GroupListItem which should be conditionally copied
         *     depending on whether READ permission is granted for any of its
         *     descendants.
         *
         * @param {PemissionFlagSet} flags
         *     The set of permissions which should be used to determine whether
         *     the given item or any of its descendants are copied.
         *
         * @returns {GroupListItem}
         *     A new GroupListItem containing a deep copy of the given item,
         *     omitting any items which lack explicit READ permission and whose
         *     descendants also lack explicit READ permission, or null if even
         *     the given item would not be copied.
         */
        var copyReadable = function copyReadable(item, flags) {
          // Produce initial shallow copy of given item
          item = new GroupListItem(item);

          // Replace children array with an array containing only readable
          // children (or children with at least one readable descendant),
          // flagging the current item for copying if any such children exist
          if (item.children) {
            var children = [];
            angular.forEach(
              item.children,
              function copyReadableChildren(child) {
                // Reduce child tree to only explicitly readable items and
                // their parents
                child = copyReadable(child, flags);

                // Include child only if they are explicitly readable, they
                // have explicitly readable descendants, or their parent is
                // readable (and thus all children are relevant)
                if (
                  (child.children && child.children.length) ||
                  isReadable(item, flags) ||
                  isReadable(child, flags)
                )
                  children.push(child);
              }
            );

            item.children = children;
          }

          return item;
        };

        // Retrieve all connections for which we have ADMINISTER permission
        dataSourceService
          .apply(
            connectionGroupService.getConnectionGroupTree,
            [$scope.dataSource],
            ConnectionGroup.ROOT_IDENTIFIER,
            [PermissionSet.ObjectPermissionType.ADMINISTER]
          )
          .then(function connectionGroupReceived(rootGroups) {
            // Update default expanded state and the all / readable-only views
            // when associated permissions change
            $scope.$watchGroup(
              ["permissionFlags"],
              function updateDefaultExpandedStates() {
                if (!$scope.permissionFlags) return;

                allRootGroups = {};
                readableRootGroups = {};

                angular.forEach(
                  rootGroups,
                  function addGroupListItem(rootGroup, dataSource) {
                    // Convert all received ConnectionGroup objects into GroupListItems
                    var item = GroupListItem.fromConnectionGroup(
                      dataSource,
                      rootGroup
                    );
                    allRootGroups[dataSource] = item;

                    // Automatically expand all objects with any descendants for
                    // which the permission set contains READ permission
                    expandReadable(item, $scope.permissionFlags);

                    // Create a duplicate view which contains only readable
                    // items
                    readableRootGroups[dataSource] = copyReadable(
                      item,
                      $scope.permissionFlags
                    );
                  }
                );

                // Display only readable connections by default if at least one
                // readable connection exists
                $scope.currentTab = !!readableRootGroups[$scope.dataSource]
                  .children.length
                  ? CURRENT_CONNECTIONS
                  : ALL_CONNECTIONS;
              }
            );
          }, requestService.DIE);

        /**
         * Updates the permissionsAdded and permissionsRemoved permission sets
         * to reflect the addition of the given connection permission.
         *
         * @param {String} identifier
         *     The identifier of the connection to add READ permission for.
         */
        var addConnectionPermission = function addConnectionPermission(
          identifier
        ) {
          // If permission was previously removed, simply un-remove it
          if (
            PermissionSet.hasConnectionPermission(
              $scope.permissionsRemoved,
              PermissionSet.ObjectPermissionType.READ,
              identifier
            )
          )
            PermissionSet.removeConnectionPermission(
              $scope.permissionsRemoved,
              PermissionSet.ObjectPermissionType.READ,
              identifier
            );
          // Otherwise, explicitly add the permission
          else
            PermissionSet.addConnectionPermission(
              $scope.permissionsAdded,
              PermissionSet.ObjectPermissionType.READ,
              identifier
            );
        };

        /**
         * Updates the permissionsAdded and permissionsRemoved permission sets
         * to reflect the removal of the given connection permission.
         *
         * @param {String} identifier
         *     The identifier of the connection to remove READ permission for.
         */
        var removeConnectionPermission = function removeConnectionPermission(
          identifier
        ) {
          // If permission was previously added, simply un-add it
          if (
            PermissionSet.hasConnectionPermission(
              $scope.permissionsAdded,
              PermissionSet.ObjectPermissionType.READ,
              identifier
            )
          )
            PermissionSet.removeConnectionPermission(
              $scope.permissionsAdded,
              PermissionSet.ObjectPermissionType.READ,
              identifier
            );
          // Otherwise, explicitly remove the permission
          else
            PermissionSet.addConnectionPermission(
              $scope.permissionsRemoved,
              PermissionSet.ObjectPermissionType.READ,
              identifier
            );
        };

        /**
         * Updates the permissionsAdded and permissionsRemoved permission sets
         * to reflect the addition of the given connection group permission.
         *
         * @param {String} identifier
         *     The identifier of the connection group to add READ permission
         *     for.
         */
        var addConnectionGroupPermission =
          function addConnectionGroupPermission(identifier) {
            // If permission was previously removed, simply un-remove it
            if (
              PermissionSet.hasConnectionGroupPermission(
                $scope.permissionsRemoved,
                PermissionSet.ObjectPermissionType.READ,
                identifier
              )
            )
              PermissionSet.removeConnectionGroupPermission(
                $scope.permissionsRemoved,
                PermissionSet.ObjectPermissionType.READ,
                identifier
              );
            // Otherwise, explicitly add the permission
            else
              PermissionSet.addConnectionGroupPermission(
                $scope.permissionsAdded,
                PermissionSet.ObjectPermissionType.READ,
                identifier
              );
          };

        /**
         * Updates the permissionsAdded and permissionsRemoved permission sets
         * to reflect the removal of the given connection group permission.
         *
         * @param {String} identifier
         *     The identifier of the connection group to remove READ permission
         *     for.
         */
        var removeConnectionGroupPermission =
          function removeConnectionGroupPermission(identifier) {
            // If permission was previously added, simply un-add it
            if (
              PermissionSet.hasConnectionGroupPermission(
                $scope.permissionsAdded,
                PermissionSet.ObjectPermissionType.READ,
                identifier
              )
            )
              PermissionSet.removeConnectionGroupPermission(
                $scope.permissionsAdded,
                PermissionSet.ObjectPermissionType.READ,
                identifier
              );
            // Otherwise, explicitly remove the permission
            else
              PermissionSet.addConnectionGroupPermission(
                $scope.permissionsRemoved,
                PermissionSet.ObjectPermissionType.READ,
                identifier
              );
          };

        /**
         * Updates the permissionsAdded and permissionsRemoved permission sets
         * to reflect the addition of the given sharing profile permission.
         *
         * @param {String} identifier
         *     The identifier of the sharing profile to add READ permission for.
         */
        var addSharingProfilePermission = function addSharingProfilePermission(
          identifier
        ) {
          // If permission was previously removed, simply un-remove it
          if (
            PermissionSet.hasSharingProfilePermission(
              $scope.permissionsRemoved,
              PermissionSet.ObjectPermissionType.READ,
              identifier
            )
          )
            PermissionSet.removeSharingProfilePermission(
              $scope.permissionsRemoved,
              PermissionSet.ObjectPermissionType.READ,
              identifier
            );
          // Otherwise, explicitly add the permission
          else
            PermissionSet.addSharingProfilePermission(
              $scope.permissionsAdded,
              PermissionSet.ObjectPermissionType.READ,
              identifier
            );
        };

        /**
         * Updates the permissionsAdded and permissionsRemoved permission sets
         * to reflect the removal of the given sharing profile permission.
         *
         * @param {String} identifier
         *     The identifier of the sharing profile to remove READ permission
         *     for.
         */
        var removeSharingProfilePermission =
          function removeSharingProfilePermission(identifier) {
            // If permission was previously added, simply un-add it
            if (
              PermissionSet.hasSharingProfilePermission(
                $scope.permissionsAdded,
                PermissionSet.ObjectPermissionType.READ,
                identifier
              )
            )
              PermissionSet.removeSharingProfilePermission(
                $scope.permissionsAdded,
                PermissionSet.ObjectPermissionType.READ,
                identifier
              );
            // Otherwise, explicitly remove the permission
            else
              PermissionSet.addSharingProfilePermission(
                $scope.permissionsRemoved,
                PermissionSet.ObjectPermissionType.READ,
                identifier
              );
          };

        // Expose permission query and modification functions to group list template
        $scope.groupListContext = {
          /**
           * Returns the PermissionFlagSet that contains the current state of
           * granted permissions.
           *
           * @returns {PermissionFlagSet}
           *     The PermissionFlagSet describing the current state of granted
           *     permissions for the permission set being edited.
           */
          getPermissionFlags: function getPermissionFlags() {
            return $scope.permissionFlags;
          },

          /**
           * Notifies the controller that a change has been made to the given
           * connection permission for the permission set being edited. This
           * only applies to READ permissions.
           *
           * @param {String} identifier
           *     The identifier of the connection affected by the changed
           *     permission.
           */
          connectionPermissionChanged: function connectionPermissionChanged(
            identifier
          ) {
            // Determine current permission setting
            var granted =
              $scope.permissionFlags.connectionPermissions.READ[identifier];

            // Add/remove permission depending on flag state
            if (granted) addConnectionPermission(identifier);
            else removeConnectionPermission(identifier);
          },

          /**
           * Notifies the controller that a change has been made to the given
           * connection group permission for the permission set being edited.
           * This only applies to READ permissions.
           *
           * @param {String} identifier
           *     The identifier of the connection group affected by the
           *     changed permission.
           */
          connectionGroupPermissionChanged:
            function connectionGroupPermissionChanged(identifier) {
              // Determine current permission setting
              var granted =
                $scope.permissionFlags.connectionGroupPermissions.READ[
                  identifier
                ];

              // Add/remove permission depending on flag state
              if (granted) addConnectionGroupPermission(identifier);
              else removeConnectionGroupPermission(identifier);
            },

          /**
           * Notifies the controller that a change has been made to the given
           * sharing profile permission for the permission set being edited.
           * This only applies to READ permissions.
           *
           * @param {String} identifier
           *     The identifier of the sharing profile affected by the changed
           *     permission.
           */
          sharingProfilePermissionChanged:
            function sharingProfilePermissionChanged(identifier) {
              // Determine current permission setting
              var granted =
                $scope.permissionFlags.sharingProfilePermissions.READ[
                  identifier
                ];

              // Add/remove permission depending on flag state
              if (granted) addSharingProfilePermission(identifier);
              else removeSharingProfilePermission(identifier);
            },
        };
      },
    ];

    return directive;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Directive which displays a set of tabs pointing to the same object within
 * different data sources, such as user accounts which span multiple data
 * sources.
 */
angular.module("manage").directive("dataSourceTabs", [
  "$injector",
  function dataSourceTabs($injector) {
    // Required types
    var PageDefinition = $injector.get("PageDefinition");

    // Required services
    var translationStringService = $injector.get("translationStringService");

    var directive = {
      restrict: "E",
      replace: true,
      templateUrl: "app/manage/templates/dataSourceTabs.html",

      scope: {
        /**
         * The permissions which dictate the management actions available
         * to the current user.
         *
         * @type Object.<String, ManagementPermissions>
         */
        permissions: "=",

        /**
         * A function which returns the URL of the object within a given
         * data source. The relevant data source will be made available to
         * the Angular expression defining this function as the
         * "dataSource" variable. No other values will be made available,
         * including values from the scope.
         *
         * @type Function
         */
        url: "&",
      },
    };

    directive.controller = [
      "$scope",
      function dataSourceTabsController($scope) {
        /**
         * The set of pages which each manage the same object within different
         * data sources.
         *
         * @type PageDefinition[]
         */
        $scope.pages = null;

        // Keep pages synchronized with permissions
        $scope.$watch("permissions", function permissionsChanged(permissions) {
          $scope.pages = [];

          var dataSources = _.keys($scope.permissions).sort();
          angular.forEach(dataSources, function addDataSourcePage(dataSource) {
            // Determine whether data source contains this object
            var managementPermissions = permissions[dataSource];
            var exists = !!managementPermissions.identifier;

            // Data source is not relevant if the associated object does not
            // exist and cannot be created
            var readOnly = !managementPermissions.canSaveObject;
            if (!exists && readOnly) return;

            // Determine class name based on read-only / linked status
            var className;
            if (readOnly) className = "read-only";
            else if (exists) className = "linked";
            else className = "unlinked";

            // Add page entry
            $scope.pages.push(
              new PageDefinition({
                name:
                  translationStringService.canonicalize(
                    "DATA_SOURCE_" + dataSource
                  ) + ".NAME",
                url: $scope.url({ dataSource: dataSource }),
                className: className,
              })
            );
          });
        });
      },
    ];

    return directive;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive for manipulating a set of objects sharing some common relation
 * and represented by an array of their identifiers. The specific objects
 * added or removed are tracked within a separate pair of arrays of
 * identifiers.
 */
angular.module("manage").directive("identifierSetEditor", [
  "$injector",
  function identifierSetEditor($injector) {
    var directive = {
      // Element only
      restrict: "E",
      replace: true,

      scope: {
        /**
         * The translation key of the text which should be displayed within
         * the main header of the identifier set editor.
         *
         * @type String
         */
        header: "@",

        /**
         * The translation key of the text which should be displayed if no
         * identifiers are currently present within the set.
         *
         * @type String
         */
        emptyPlaceholder: "@",

        /**
         * The translation key of the text which should be displayed if no
         * identifiers are available to be added within the set.
         *
         * @type String
         */
        unavailablePlaceholder: "@",

        /**
         * All identifiers which are available to be added to or removed
         * from the identifier set being edited.
         *
         * @type String[]
         */
        identifiersAvailable: "=",

        /**
         * The current state of the identifier set being manipulated. This
         * array will be modified as changes are made through this
         * identifier set editor.
         *
         * @type String[]
         */
        identifiers: "=",

        /**
         * The set of identifiers that have been added, relative to the
         * initial state of the identifier set being manipulated.
         *
         * @type String[]
         */
        identifiersAdded: "=",

        /**
         * The set of identifiers that have been removed, relative to the
         * initial state of the identifier set being manipulated.
         *
         * @type String[]
         */
        identifiersRemoved: "=",
      },

      templateUrl: "app/manage/templates/identifierSetEditor.html",
    };

    directive.controller = [
      "$scope",
      function identifierSetEditorController($scope) {
        /**
         * Whether the full list of available identifiers should be displayed.
         * Initially, only an abbreviated list of identifiers currently present
         * is shown.
         *
         * @type Boolean
         */
        $scope.expanded = false;

        /**
         * Map of identifiers to boolean flags indicating whether that
         * identifier is currently present (true) or absent (false). If an
         * identifier is absent, it may also be absent from this map.
         *
         * @type Object.<String, Boolean>
         */
        $scope.identifierFlags = {};

        /**
         * Map of identifiers to boolean flags indicating whether that
         * identifier is editable. If an identifier is not editable, it will be
         * absent from this map.
         *
         * @type Object.<String, Boolean>
         */
        $scope.isEditable = {};

        /**
         * Adds the given identifier to the given sorted array of identifiers,
         * preserving the sorted order of the array. If the identifier is
         * already present, no change is made to the array. The given array
         * must already be sorted in ascending order.
         *
         * @param {String[]} arr
         *     The sorted array of identifiers to add the given identifier to.
         *
         * @param {String} identifier
         *     The identifier to add to the given array.
         */
        var addIdentifier = function addIdentifier(arr, identifier) {
          // Determine location that the identifier should be added to
          // maintain sorted order
          var index = _.sortedIndex(arr, identifier);

          // Do not add if already present
          if (arr[index] === identifier) return;

          // Insert identifier at determined location
          arr.splice(index, 0, identifier);
        };

        /**
         * Removes the given identifier from the given sorted array of
         * identifiers, preserving the sorted order of the array. If the
         * identifier is already absent, no change is made to the array. The
         * given array must already be sorted in ascending order.
         *
         * @param {String[]} arr
         *     The sorted array of identifiers to remove the given identifier
         *     from.
         *
         * @param {String} identifier
         *     The identifier to remove from the given array.
         *
         * @returns {Boolean}
         *     true if the identifier was present in the given array and has
         *     been removed, false otherwise.
         */
        var removeIdentifier = function removeIdentifier(arr, identifier) {
          // Search for identifier in sorted array
          var index = _.sortedIndexOf(arr, identifier);

          // Nothing to do if already absent
          if (index === -1) return false;

          // Remove identifier
          arr.splice(index, 1);
          return true;
        };

        // Keep identifierFlags up to date when identifiers array is replaced
        // or initially assigned
        $scope.$watch("identifiers", function identifiersChanged(identifiers) {
          // Maintain identifiers in sorted order so additions and removals
          // can be made more efficiently
          if (identifiers) identifiers.sort();

          // Convert array of identifiers into set of boolean
          // presence/absence flags
          $scope.identifierFlags = {};
          angular.forEach(
            identifiers,
            function storeIdentifierFlag(identifier) {
              $scope.identifierFlags[identifier] = true;
            }
          );
        });

        // An identifier is editable iff it is available to be added or removed
        // from the identifier set being edited (iff it is within the
        // identifiersAvailable array)
        $scope.$watch(
          "identifiersAvailable",
          function availableIdentifiersChanged(identifiers) {
            $scope.isEditable = {};
            angular.forEach(
              identifiers,
              function storeEditableIdentifier(identifier) {
                $scope.isEditable[identifier] = true;
              }
            );
          }
        );

        /**
         * Notifies the controller that a change has been made to the flag
         * denoting presence/absence of a particular identifier within the
         * <code>identifierFlags</code> map. The <code>identifiers</code>,
         * <code>identifiersAdded</code>, and <code>identifiersRemoved</code>
         * arrays are updated accordingly.
         *
         * @param {String} identifier
         *     The identifier which has been added or removed through modifying
         *     its boolean flag within <code>identifierFlags</code>.
         */
        $scope.identifierChanged = function identifierChanged(identifier) {
          // Determine status of modified identifier
          var present = !!$scope.identifierFlags[identifier];

          // Add/remove identifier from added/removed sets depending on
          // change in flag state
          if (present) {
            addIdentifier($scope.identifiers, identifier);

            if (!removeIdentifier($scope.identifiersRemoved, identifier))
              addIdentifier($scope.identifiersAdded, identifier);
          } else {
            removeIdentifier($scope.identifiers, identifier);

            if (!removeIdentifier($scope.identifiersAdded, identifier))
              addIdentifier($scope.identifiersRemoved, identifier);
          }
        };

        /**
         * Removes the given identifier, updating <code>identifierFlags</code>,
         * <code>identifiers</code>, <code>identifiersAdded</code>, and
         * <code>identifiersRemoved</code> accordingly.
         *
         * @param {String} identifier
         *     The identifier to remove.
         */
        $scope.removeIdentifier = function removeIdentifier(identifier) {
          $scope.identifierFlags[identifier] = false;
          $scope.identifierChanged(identifier);
        };

        /**
         * Shows the full list of available identifiers. If the full list is
         * already shown, this function has no effect.
         */
        $scope.expand = function expand() {
          $scope.expanded = true;
        };

        /**
         * Hides the full list of available identifiers. If the full list is
         * already hidden, this function has no effect.
         */
        $scope.collapse = function collapse() {
          $scope.expanded = false;
        };

        /**
         * Returns whether there are absolutely no identifiers that can be
         * managed using this editor. If true, the editor is effectively
         * useless, as there is nothing whatsoever to display.
         *
         * @returns {Boolean}
         *     true if there are no identifiers that can be managed using this
         *     editor, false otherwise.
         */
        $scope.isEmpty = function isEmpty() {
          return (
            _.isEmpty($scope.identifiers) &&
            _.isEmpty($scope.identifiersAvailable)
          );
        };
      },
    ];

    return directive;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive for choosing the location of a connection or connection group.
 */
angular.module("manage").directive("locationChooser", [
  function locationChooser() {
    return {
      // Element only
      restrict: "E",
      replace: true,

      scope: {
        /**
         * The identifier of the data source from which the given root
         * connection group was retrieved.
         *
         * @type String
         */
        dataSource: "=",

        /**
         * The root connection group of the connection group hierarchy to
         * display.
         *
         * @type ConnectionGroup
         */
        rootGroup: "=",

        /**
         * The unique identifier of the currently-selected connection
         * group. If not specified, the root group will be used.
         *
         * @type String
         */
        value: "=",
      },

      templateUrl: "app/manage/templates/locationChooser.html",
      controller: [
        "$scope",
        function locationChooserController($scope) {
          /**
           * Map of unique identifiers to their corresponding connection
           * groups.
           *
           * @type Object.<String, GroupListItem>
           */
          var connectionGroups = {};

          /**
           * Recursively traverses the given connection group and all
           * children, storing each encountered connection group within the
           * connectionGroups map by its identifier.
           *
           * @param {GroupListItem} group
           *     The connection group to traverse.
           */
          var mapConnectionGroups = function mapConnectionGroups(group) {
            // Map given group
            connectionGroups[group.identifier] = group;

            // Map all child groups
            if (group.childConnectionGroups)
              group.childConnectionGroups.forEach(mapConnectionGroups);
          };

          /**
           * Whether the group list menu is currently open.
           *
           * @type Boolean
           */
          $scope.menuOpen = false;

          /**
           * The human-readable name of the currently-chosen connection
           * group.
           *
           * @type String
           */
          $scope.chosenConnectionGroupName = null;

          /**
           * Toggle the current state of the menu listing connection groups.
           * If the menu is currently open, it will be closed. If currently
           * closed, it will be opened.
           */
          $scope.toggleMenu = function toggleMenu() {
            $scope.menuOpen = !$scope.menuOpen;
          };

          // Update the root group map when data source or root group change
          $scope.$watchGroup(
            ["dataSource", "rootGroup"],
            function updateRootGroups() {
              // Abort if the root group is not set
              if (!$scope.dataSource || !$scope.rootGroup) return null;

              // Wrap root group in map
              $scope.rootGroups = {};
              $scope.rootGroups[$scope.dataSource] = $scope.rootGroup;
            }
          );

          // Expose selection function to group list template
          $scope.groupListContext = {
            /**
             * Selects the given group item.
             *
             * @param {GroupListItem} item
             *     The chosen item.
             */
            chooseGroup: function chooseGroup(item) {
              // Record new parent
              $scope.value = item.identifier;
              $scope.chosenConnectionGroupName = item.name;

              // Close menu
              $scope.menuOpen = false;
            },
          };

          $scope.$watch("rootGroup", function setRootGroup(rootGroup) {
            connectionGroups = {};

            if (!rootGroup) return;

            // Map all known groups
            mapConnectionGroups(rootGroup);

            // If no value is specified, default to the root identifier
            if (!$scope.value || !($scope.value in connectionGroups))
              $scope.value = rootGroup.identifier;

            $scope.chosenConnectionGroupName =
              connectionGroups[$scope.value].name;
          });
        },
      ],
    };
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Directive which displays a set of object management buttons (save, delete,
 * clone, etc.) representing the actions available to the current user in
 * context of the object being edited/created.
 */
angular.module("manage").directive("managementButtons", [
  "$injector",
  function managementButtons($injector) {
    // Required services
    var guacNotification = $injector.get("guacNotification");

    var directive = {
      restrict: "E",
      replace: true,
      templateUrl: "app/manage/templates/managementButtons.html",

      scope: {
        /**
         * The translation namespace associated with all applicable
         * translation strings. This directive requires at least the
         * following translation strings within the given namespace:
         *
         *     - ACTION_CANCEL
         *     - ACTION_CLONE
         *     - ACTION_DELETE
         *     - ACTION_SAVE
         *     - DIALOG_HEADER_CONFIRM_DELETE
         *     - TEXT_CONFIRM_DELETE
         *
         * @type String
         */
        namespace: "@",

        /**
         * The permissions which dictate the management actions available
         * to the current user.
         *
         * @type ManagementPermissions
         */
        permissions: "=",

        /**
         * The function to invoke to save the arbitrary object being edited
         * if the current user has permission to do so. The provided
         * function MUST return a promise which is resolved if the save
         * operation succeeds and is rejected with an {@link Error} if the
         * save operation fails.
         *
         * @type Function
         */
        save: "&",

        /**
         * The function to invoke when the current user chooses to clone
         * the object being edited. The provided function MUST perform the
         * actions necessary to produce an interface which will clone the
         * object.
         *
         * @type Function
         */
        clone: "&",

        /**
         * The function to invoke to delete the arbitrary object being edited
         * if the current user has permission to do so. The provided
         * function MUST return a promise which is resolved if the delete
         * operation succeeds and is rejected with an {@link Error} if the
         * delete operation fails.
         *
         * @type Function
         */
        delete: "&",

        /**
         * The function to invoke when the current user chooses to cancel
         * the edit in progress, or when a save/delete operation has
         * succeeded. The provided function MUST perform the actions
         * necessary to return the user to a reasonable starting point.
         *
         * @type Function
         */
        return: "&",
      },
    };

    directive.controller = [
      "$scope",
      function managementButtonsController($scope) {
        /**
         * An action to be provided along with the object sent to showStatus which
         * immediately deletes the current connection.
         */
        var DELETE_ACTION = {
          name: $scope.namespace + ".ACTION_DELETE",
          className: "danger",
          callback: function deleteCallback() {
            deleteObjectImmediately();
            guacNotification.showStatus(false);
          },
        };

        /**
         * An action to be provided along with the object sent to showStatus which
         * closes the currently-shown status dialog.
         */
        var CANCEL_ACTION = {
          name: $scope.namespace + ".ACTION_CANCEL",
          callback: function cancelCallback() {
            guacNotification.showStatus(false);
          },
        };

        /**
         * Invokes the provided return function to navigate the user back to
         * the page they started from.
         */
        var navigateBack = function navigateBack() {
          $scope["return"]($scope.$parent);
        };

        /**
         * Invokes the provided delete function, immediately deleting the
         * current object without prompting the user for confirmation. If
         * deletion is successful, the user is navigated back to the page they
         * started from. If the deletion fails, an error notification is
         * displayed.
         */
        var deleteObjectImmediately = function deleteObjectImmediately() {
          $scope["delete"]($scope.$parent).then(
            navigateBack,
            guacNotification.SHOW_REQUEST_ERROR
          );
        };

        /**
         * Cancels all pending edits, returning to the page the user started
         * from.
         */
        $scope.cancel = navigateBack;

        /**
         * Cancels all pending edits, invoking the provided clone function to
         * open an edit page for a new object which is prepopulated with the
         * data from the current object.
         */
        $scope.cloneObject = function cloneObject() {
          $scope.clone($scope.$parent);
        };

        /**
         * Invokes the provided save function to save the current object. If
         * saving is successful, the user is navigated back to the page they
         * started from. If saving fails, an error notification is displayed.
         */
        $scope.saveObject = function saveObject() {
          $scope
            .save($scope.$parent)
            .then(navigateBack, guacNotification.SHOW_REQUEST_ERROR);
        };

        /**
         * Deletes the current object, prompting the user first to confirm that
         * deletion is desired. If the user confirms that deletion is desired,
         * the object is deleted through invoking the provided delete function.
         * The user is automatically navigated back to the page they started
         * from or given an error notification depending on whether deletion
         * succeeds.
         */
        $scope.deleteObject = function deleteObject() {
          // Confirm deletion request
          guacNotification.showStatus({
            title: $scope.namespace + ".DIALOG_HEADER_CONFIRM_DELETE",
            text: { key: $scope.namespace + ".TEXT_CONFIRM_DELETE" },
            actions: [DELETE_ACTION, CANCEL_ACTION],
          });
        };
      },
    ];

    return directive;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive for manipulating the system permissions granted within a given
 * {@link PermissionFlagSet}, tracking the specific permissions added or
 * removed within a separate pair of {@link PermissionSet} objects. Optionally,
 * the permission for a particular user to update themselves (change their own
 * password/attributes) may also be manipulated.
 */
angular.module("manage").directive("systemPermissionEditor", [
  "$injector",
  function systemPermissionEditor($injector) {
    // Required services
    var authenticationService = $injector.get("authenticationService");
    var dataSourceService = $injector.get("dataSourceService");
    var permissionService = $injector.get("permissionService");
    var requestService = $injector.get("requestService");

    // Required types
    var PermissionSet = $injector.get("PermissionSet");

    var directive = {
      // Element only
      restrict: "E",
      replace: true,

      scope: {
        /**
         * The unique identifier of the data source associated with the
         * permissions being manipulated.
         *
         * @type String
         */
        dataSource: "=",

        /**
         * The username of the user whose self-update permission (whether
         * the user has permission to update their own user account) should
         * be additionally controlled by this editor. If no such user
         * permissions should be controlled, this should be left undefined.
         *
         * @type String
         */
        username: "=",

        /**
         * The current state of the permissions being manipulated. This
         * {@link PemissionFlagSet} will be modified as changes are made
         * through this permission editor.
         *
         * @type PermissionFlagSet
         */
        permissionFlags: "=",

        /**
         * The set of permissions that have been added, relative to the
         * initial state of the permissions being manipulated.
         *
         * @type PermissionSet
         */
        permissionsAdded: "=",

        /**
         * The set of permissions that have been removed, relative to the
         * initial state of the permissions being manipulated.
         *
         * @type PermissionSet
         */
        permissionsRemoved: "=",
      },

      templateUrl: "app/manage/templates/systemPermissionEditor.html",
    };

    directive.controller = [
      "$scope",
      function systemPermissionEditorController($scope) {
        /**
         * The identifiers of all data sources currently available to the
         * authenticated user.
         *
         * @type String[]
         */
        var dataSources = authenticationService.getAvailableDataSources();

        /**
         * The username of the current, authenticated user.
         *
         * @type String
         */
        var currentUsername = authenticationService.getCurrentUsername();

        /**
         * Available system permission types, as translation string / internal
         * value pairs.
         *
         * @type Object[]
         */
        $scope.systemPermissionTypes = [
          {
            label: "MANAGE_USER.FIELD_HEADER_ADMINISTER_SYSTEM",
            value: PermissionSet.SystemPermissionType.ADMINISTER,
          },
          {
            label: "MANAGE_USER.FIELD_HEADER_CREATE_NEW_USERS",
            value: PermissionSet.SystemPermissionType.CREATE_USER,
          },
          {
            label: "MANAGE_USER.FIELD_HEADER_CREATE_NEW_USER_GROUPS",
            value: PermissionSet.SystemPermissionType.CREATE_USER_GROUP,
          },
          {
            label: "MANAGE_USER.FIELD_HEADER_CREATE_NEW_CONNECTIONS",
            value: PermissionSet.SystemPermissionType.CREATE_CONNECTION,
          },
          {
            label: "MANAGE_USER.FIELD_HEADER_CREATE_NEW_CONNECTION_GROUPS",
            value: PermissionSet.SystemPermissionType.CREATE_CONNECTION_GROUP,
          },
          {
            label: "MANAGE_USER.FIELD_HEADER_CREATE_NEW_SHARING_PROFILES",
            value: PermissionSet.SystemPermissionType.CREATE_SHARING_PROFILE,
          },
        ];

        // Query the permissions granted to the currently-authenticated user
        dataSourceService
          .apply(
            permissionService.getEffectivePermissions,
            dataSources,
            currentUsername
          )
          .then(function permissionsReceived(permissions) {
            $scope.permissions = permissions;
          }, requestService.DIE);

        /**
         * Returns whether the current user has permission to change the system
         * permissions granted to users.
         *
         * @returns {Boolean}
         *     true if the current user can grant or revoke system permissions
         *     to the permission set being edited, false otherwise.
         */
        $scope.canChangeSystemPermissions =
          function canChangeSystemPermissions() {
            // Do not check if permissions are not yet loaded
            if (!$scope.permissions) return false;

            // Only the administrator can modify system permissions
            return PermissionSet.hasSystemPermission(
              $scope.permissions[$scope.dataSource],
              PermissionSet.SystemPermissionType.ADMINISTER
            );
          };

        /**
         * Updates the permissionsAdded and permissionsRemoved permission sets
         * to reflect the addition of the given system permission.
         *
         * @param {String} type
         *     The system permission to add, as defined by
         *     PermissionSet.SystemPermissionType.
         */
        var addSystemPermission = function addSystemPermission(type) {
          // If permission was previously removed, simply un-remove it
          if (
            PermissionSet.hasSystemPermission($scope.permissionsRemoved, type)
          )
            PermissionSet.removeSystemPermission(
              $scope.permissionsRemoved,
              type
            );
          // Otherwise, explicitly add the permission
          else PermissionSet.addSystemPermission($scope.permissionsAdded, type);
        };

        /**
         * Updates the permissionsAdded and permissionsRemoved permission sets
         * to reflect the removal of the given system permission.
         *
         * @param {String} type
         *     The system permission to remove, as defined by
         *     PermissionSet.SystemPermissionType.
         */
        var removeSystemPermission = function removeSystemPermission(type) {
          // If permission was previously added, simply un-add it
          if (PermissionSet.hasSystemPermission($scope.permissionsAdded, type))
            PermissionSet.removeSystemPermission($scope.permissionsAdded, type);
          // Otherwise, explicitly remove the permission
          else
            PermissionSet.addSystemPermission($scope.permissionsRemoved, type);
        };

        /**
         * Notifies the controller that a change has been made to the given
         * system permission for the permission set being edited.
         *
         * @param {String} type
         *     The system permission that was changed, as defined by
         *     PermissionSet.SystemPermissionType.
         */
        $scope.systemPermissionChanged = function systemPermissionChanged(
          type
        ) {
          // Determine current permission setting
          var granted = $scope.permissionFlags.systemPermissions[type];

          // Add/remove permission depending on flag state
          if (granted) addSystemPermission(type);
          else removeSystemPermission(type);
        };

        /**
         * Updates the permissionsAdded and permissionsRemoved permission sets
         * to reflect the addition of the given user permission.
         *
         * @param {String} type
         *     The user permission to add, as defined by
         *     PermissionSet.ObjectPermissionType.
         *
         * @param {String} identifier
         *     The identifier of the user affected by the permission being added.
         */
        var addUserPermission = function addUserPermission(type, identifier) {
          // If permission was previously removed, simply un-remove it
          if (
            PermissionSet.hasUserPermission(
              $scope.permissionsRemoved,
              type,
              identifier
            )
          )
            PermissionSet.removeUserPermission(
              $scope.permissionsRemoved,
              type,
              identifier
            );
          // Otherwise, explicitly add the permission
          else
            PermissionSet.addUserPermission(
              $scope.permissionsAdded,
              type,
              identifier
            );
        };

        /**
         * Updates the permissionsAdded and permissionsRemoved permission sets
         * to reflect the removal of the given user permission.
         *
         * @param {String} type
         *     The user permission to remove, as defined by
         *     PermissionSet.ObjectPermissionType.
         *
         * @param {String} identifier
         *     The identifier of the user affected by the permission being
         *     removed.
         */
        var removeUserPermission = function removeUserPermission(
          type,
          identifier
        ) {
          // If permission was previously added, simply un-add it
          if (
            PermissionSet.hasUserPermission(
              $scope.permissionsAdded,
              type,
              identifier
            )
          )
            PermissionSet.removeUserPermission(
              $scope.permissionsAdded,
              type,
              identifier
            );
          // Otherwise, explicitly remove the permission
          else
            PermissionSet.addUserPermission(
              $scope.permissionsRemoved,
              type,
              identifier
            );
        };

        /**
         * Notifies the controller that a change has been made to the given user
         * permission for the permission set being edited.
         *
         * @param {String} type
         *     The user permission that was changed, as defined by
         *     PermissionSet.ObjectPermissionType.
         *
         * @param {String} identifier
         *     The identifier of the user affected by the changed permission.
         */
        $scope.userPermissionChanged = function userPermissionChanged(
          type,
          identifier
        ) {
          // Determine current permission setting
          var granted =
            $scope.permissionFlags.userPermissions[type][identifier];

          // Add/remove permission depending on flag state
          if (granted) addUserPermission(type, identifier);
          else removeUserPermission(type, identifier);
        };
      },
    ];

    return directive;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The module for the administration functionality.
 */
angular.module("manage", [
  "form",
  "groupList",
  "list",
  "locale",
  "navigation",
  "notification",
  "rest",
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for defining the HistoryEntryWrapper class.
 */
angular.module("manage").factory("HistoryEntryWrapper", [
  "$injector",
  function defineHistoryEntryWrapper($injector) {
    // Required types
    var ConnectionHistoryEntry = $injector.get("ConnectionHistoryEntry");

    /**
     * Wrapper for ConnectionHistoryEntry which adds display-specific
     * properties, such as the connection duration.
     *
     * @constructor
     * @param {ConnectionHistoryEntry} historyEntry
     *     The history entry to wrap.
     */
    var HistoryEntryWrapper = function HistoryEntryWrapper(historyEntry) {
      /**
       * The wrapped ConnectionHistoryEntry.
       *
       * @type ConnectionHistoryEntry
       */
      this.entry = historyEntry;

      /**
       * An object providing value and unit properties, denoting the duration
       * and its corresponding units.
       *
       * @type ConnectionHistoryEntry.Duration
       */
      this.duration = null;

      /**
       * The string to display as the duration of this history entry. If a
       * duration is available, its value and unit will be exposed to any
       * given translation string as the VALUE and UNIT substitution
       * variables respectively.
       *
       * @type String
       */
      this.durationText = "MANAGE_CONNECTION.TEXT_HISTORY_DURATION";

      // Notify if connection is active right now
      if (historyEntry.active)
        this.durationText = "MANAGE_CONNECTION.INFO_CONNECTION_ACTIVE_NOW";
      // If connection is not active, inform user if end date is not known
      else if (!historyEntry.endDate)
        this.durationText =
          "MANAGE_CONNECTION.INFO_CONNECTION_DURATION_UNKNOWN";

      // Set the duration if the necessary information is present
      if (historyEntry.endDate && historyEntry.startDate)
        this.duration = new ConnectionHistoryEntry.Duration(
          historyEntry.endDate - historyEntry.startDate
        );
    };

    return HistoryEntryWrapper;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for defining the ManageableUser class.
 */
angular.module("manage").factory("ManageableUser", [
  function defineManageableUser() {
    /**
     * A pairing of an @link{User} with the identifier of its corresponding
     * data source.
     *
     * @constructor
     * @param {Object|ManageableUser} template
     */
    var ManageableUser = function ManageableUser(template) {
      /**
       * The unique identifier of the data source containing this user.
       *
       * @type String
       */
      this.dataSource = template.dataSource;

      /**
       * The @link{User} object represented by this ManageableUser and
       * contained within the associated data source.
       *
       * @type User
       */
      this.user = template.user;
    };

    return ManageableUser;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for defining the ManageableUserGroup class.
 */
angular.module("manage").factory("ManageableUserGroup", [
  function defineManageableUserGroup() {
    /**
     * A pairing of an @link{UserGroup} with the identifier of its corresponding
     * data source.
     *
     * @constructor
     * @param {Object|ManageableUserGroup} template
     */
    var ManageableUserGroup = function ManageableUserGroup(template) {
      /**
       * The unique identifier of the data source containing this user.
       *
       * @type String
       */
      this.dataSource = template.dataSource;

      /**
       * The @link{UserGroup} object represented by this ManageableUserGroup
       * and contained within the associated data source.
       *
       * @type UserGroup
       */
      this.userGroup = template.userGroup;
    };

    return ManageableUserGroup;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for defining the ManagementPermissions class.
 */
angular.module("manage").factory("ManagementPermissions", [
  "$injector",
  function defineManagementPermissions($injector) {
    // Required types
    var PermissionSet = $injector.get("PermissionSet");

    /**
     * Higher-level representation of the management-related permissions
     * available to the current user on a particular, arbitrary object.
     *
     * @constructor
     * @param {ManagementPermissions|Object} template
     *     An object whose properties should be copied into the new
     *     ManagementPermissions object.
     */
    var ManagementPermissions = function ManagementPermissions(template) {
      /**
       * The identifier of the associated object, or null if the object does
       * not yet exist.
       *
       * @type String
       */
      this.identifier = template.identifier || null;

      /**
       * Whether the user can save the associated object. This could be
       * updating an existing object, or creating a new object.
       *
       * @type Boolean
       */
      this.canSaveObject = template.canSaveObject;

      /**
       * Whether the user can clone the associated object.
       *
       * @type Boolean
       */
      this.canCloneObject = template.canCloneObject;

      /**
       * Whether the user can delete the associated object.
       *
       * @type Boolean
       */
      this.canDeleteObject = template.canDeleteObject;

      /**
       * Whether the user can change attributes which are currently
       * associated with the object.
       *
       * @type Boolean
       */
      this.canChangeAttributes = template.canChangeAttributes;

      /**
       * Whether the user can change absolutely all attributes associated
       * with the object, including those which are not already present.
       *
       * @type Boolean
       */
      this.canChangeAllAttributes = template.canChangeAllAttributes;

      /**
       * Whether the user can change permissions which are assigned to the
       * associated object, if the object is capable of being assigned
       * permissions.
       *
       * @type Boolean
       */
      this.canChangePermissions = template.canChangePermissions;
    };

    /**
     * Creates a new {@link ManagementPermissions} which defines the high-level
     * actions the current user may take for the given object.
     *
     * @param {PermissionSet} permissions
     *     The effective permissions granted to the current user within the
     *     data source associated with the object being managed.
     *
     * @param {String} createPermission
     *     The system permission required to create objects of the same type as
     *     the object being managed, as defined by
     *     {@link PermissionSet.SystemPermissionTypes}.
     *
     * @param {Function} hasObjectPermission
     *     The function to invoke to test whether a {@link PermissionSet}
     *     contains a particular object permission. The parameters accepted
     *     by this function must be identical to those accepted by
     *     {@link PermissionSet.hasUserPermission()},
     *     {@link PermissionSet.hasConnectionPermission()}, etc.
     *
     * @param {String} [identifier]
     *     The identifier of the object being managed. If the object does not
     *     yet exist, this parameter should be omitted or set to null.
     *
     * @returns {ManagementPermissions}
     *     A new {@link ManagementPermissions} which defines the high-level
     *     actions the current user may take for the given object.
     */
    ManagementPermissions.fromPermissionSet = function fromPermissionSet(
      permissions,
      createPermission,
      hasObjectPermission,
      identifier
    ) {
      var isAdmin = PermissionSet.hasSystemPermission(
        permissions,
        PermissionSet.SystemPermissionType.ADMINISTER
      );

      var canCreate = PermissionSet.hasSystemPermission(
        permissions,
        createPermission
      );
      var canAdminister = hasObjectPermission(
        permissions,
        PermissionSet.ObjectPermissionType.ADMINISTER,
        identifier
      );
      var canUpdate = hasObjectPermission(
        permissions,
        PermissionSet.ObjectPermissionType.UPDATE,
        identifier
      );
      var canDelete = hasObjectPermission(
        permissions,
        PermissionSet.ObjectPermissionType.DELETE,
        identifier
      );

      var exists = !!identifier;

      return new ManagementPermissions({
        identifier: identifier,

        // A user can save (create or update) an object if they are a
        // system-level administrator, OR the object does not yet exist and
        // the user has explicit permission to create such objects, OR the
        // object does already exist and the user has explicit UPDATE
        // permission on the object
        canSaveObject: isAdmin || (!exists && canCreate) || canUpdate,

        // A user can clone an object only if the object exists, and
        // only if they are a system-level administrator OR they have
        // explicit permission to create such objects
        canCloneObject: exists && (isAdmin || canCreate),

        // A user can delete an object only if the object exists, and
        // only if they are a system-level administrator OR they have
        // explicit DELETE permission on the object
        canDeleteObject: exists && (isAdmin || canDelete),

        // Attributes in general (with or without existing values) can only
        // be changed if the object is being created, OR the user is a
        // system-level administrator, OR the user has explicit UPDATE
        // permission on the object
        canChangeAttributes: !exists || isAdmin || canUpdate,

        // A user can change the attributes of an object which are not
        // explicitly defined on that object when the object is being
        // created
        canChangeAllAttributes: !exists,

        // A user can change the system permissions related to an object
        // if they are a system-level admin, OR they are creating the
        // object, OR they have explicit ADMINISTER permission on the
        // existing object
        canChangePermissions: isAdmin || !exists || canAdminister,
      });
    };

    return ManagementPermissions;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which provides an arbitrary menu-style container. The contents
 * of the directive are displayed only when the menu is open.
 */
angular.module("navigation").directive("guacMenu", [
  function guacMenu() {
    return {
      restrict: "E",
      transclude: true,
      replace: true,
      scope: {
        /**
         * The string which should be rendered as the menu title.
         *
         * @type String
         */
        menuTitle: "=",

        /**
         * Whether the menu should remain open while the user interacts
         * with the contents of the menu. By default, the menu will close
         * if the user clicks within the menu contents.
         *
         * @type Boolean
         */
        interactive: "=",
      },

      templateUrl: "app/navigation/templates/guacMenu.html",
      controller: [
        "$scope",
        "$injector",
        "$element",
        function guacMenuController($scope, $injector, $element) {
          // Get required services
          var $document = $injector.get("$document");

          /**
           * The outermost element of the guacMenu directive.
           *
           * @type Element
           */
          var element = $element[0];

          /**
           * The element containing the menu contents that display when the
           * menu is open.
           *
           * @type Element
           */
          var contents = $element.find(".menu-contents")[0];

          /**
           * The main document object.
           *
           * @type Document
           */
          var document = $document[0];

          /**
           * Whether the contents of the menu are currently shown.
           *
           * @type Boolean
           */
          $scope.menuShown = false;

          /**
           * Toggles visibility of the menu contents.
           */
          $scope.toggleMenu = function toggleMenu() {
            $scope.menuShown = !$scope.menuShown;
          };

          // Close menu when user clicks anywhere outside this specific menu
          document.body.addEventListener(
            "click",
            function clickOutsideMenu(e) {
              $scope.$apply(function closeMenu() {
                if (e.target !== element && !element.contains(e.target))
                  $scope.menuShown = false;
              });
            },
            false
          );

          // Prevent clicks within menu contents from toggling menu visibility
          // if the menu contents are intended to be interactive
          contents.addEventListener(
            "click",
            function clickInsideMenuContents(e) {
              if ($scope.interactive) e.stopPropagation();
            },
            false
          );
        },
      ], // end controller
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which provides a list of links to specific pages.
 */
angular.module("navigation").directive("guacPageList", [
  function guacPageList() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The array of pages to display.
         *
         * @type PageDefinition[]
         */
        pages: "=",
      },

      templateUrl: "app/navigation/templates/guacPageList.html",
      controller: [
        "$scope",
        "$injector",
        function guacPageListController($scope, $injector) {
          // Required types
          var PageDefinition = $injector.get("PageDefinition");

          // Required services
          var $location = $injector.get("$location");

          /**
           * The URL of the currently-displayed page.
           *
           * @type String
           */
          var currentURL = $location.url();

          /**
           * The names associated with the current page, if the current page
           * is known. The value of this property corresponds to the value of
           * PageDefinition.name. Though PageDefinition.name may be a String,
           * this will always be an Array.
           *
           * @type String[]
           */
          var currentPageName = [];

          /**
           * Array of each level of the page list, where a level is defined
           * by a mapping of names (translation strings) to the
           * PageDefinitions corresponding to those names.
           *
           * @type Object.<String, PageDefinition>[]
           */
          $scope.levels = [];

          /**
           * Returns the names associated with the given page, in
           * hierarchical order. If the page is only associated with a single
           * name, and that name is not stored as an array, it will be still
           * be returned as an array containing a single item.
           *
           * @param {PageDefinition} page
           *     The page to return the names of.
           *
           * @return {String[]}
           *     An array of all names associated with the given page, in
           *     hierarchical order.
           */
          var getPageNames = function getPageNames(page) {
            // If already an array, simply return the name
            if (angular.isArray(page.name)) return page.name;

            // Otherwise, transform into array
            return [page.name];
          };

          /**
           * Adds the given PageDefinition to the overall set of pages
           * displayed by this guacPageList, automatically updating the
           * available levels ($scope.levels) and the contents of those
           * levels.
           *
           * @param {PageDefinition} page
           *     The PageDefinition to add.
           *
           * @param {Number} weight
           *     The sorting weight to use for the page if it does not
           *     already have an associated weight.
           */
          var addPage = function addPage(page, weight) {
            // Pull all names for page
            var names = getPageNames(page);

            // Copy the hierarchy of this page into the displayed levels
            // as far as is relevant for the currently-displayed page
            for (var i = 0; i < names.length; i++) {
              // Create current level, if it doesn't yet exist
              var pages = $scope.levels[i];
              if (!pages) pages = $scope.levels[i] = {};

              // Get the name at the current level
              var name = names[i];

              // Determine whether this page definition is part of the
              // hierarchy containing the current page
              var isCurrentPage = currentPageName[i] === name;

              // Store new page if it doesn't yet exist at this level
              if (!pages[name]) {
                pages[name] = new PageDefinition({
                  name: name,
                  url: isCurrentPage ? currentURL : page.url,
                  className: page.className,
                  weight: page.weight || weight + i,
                });
              }

              // If the name at this level no longer matches the
              // hierarchy of the current page, do not go any deeper
              if (currentPageName[i] !== name) break;
            }
          };

          /**
           * Navigate to the given page.
           *
           * @param {PageDefinition} page
           *     The page to navigate to.
           */
          $scope.navigateToPage = function navigateToPage(page) {
            $location.path(page.url);
          };

          /**
           * Tests whether the given page is the page currently being viewed.
           *
           * @param {PageDefinition} page
           *     The page to test.
           *
           * @returns {Boolean}
           *     true if the given page is the current page, false otherwise.
           */
          $scope.isCurrentPage = function isCurrentPage(page) {
            return currentURL === page.url;
          };

          /**
           * Given an arbitrary map of PageDefinitions, returns an array of
           * those PageDefinitions, sorted by weight.
           *
           * @param {Object.<*, PageDefinition>} level
           *     A map of PageDefinitions with arbitrary keys. The value of
           *     each key is ignored.
           *
           * @returns {PageDefinition[]}
           *     An array of all PageDefinitions in the given map, sorted by
           *     weight.
           */
          $scope.getPages = function getPages(level) {
            var pages = [];

            // Convert contents of level to a flat array of pages
            angular.forEach(level, function addPageFromLevel(page) {
              pages.push(page);
            });

            // Sort page array by weight
            pages.sort(function comparePages(a, b) {
              return a.weight - b.weight;
            });

            return pages;
          };

          // Update page levels whenever pages changes
          $scope.$watch("pages", function setPages(pages) {
            // Determine current page name
            currentPageName = [];
            angular.forEach(pages, function findCurrentPageName(page) {
              // If page is current page, store its names
              if ($scope.isCurrentPage(page))
                currentPageName = getPageNames(page);
            });

            // Reset contents of levels
            $scope.levels = [];

            // Add all page definitions
            angular.forEach(pages, addPage);

            // Filter to only relevant levels
            $scope.levels = $scope.levels.filter(function isRelevant(level) {
              // Determine relevancy by counting the number of pages
              var pageCount = 0;
              for (var name in level) {
                // Level is relevant if it has two or more pages
                if (++pageCount === 2) return true;
              }

              // Otherwise, the level is not relevant
              return false;
            });
          });
        },
      ], // end controller
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Directive which displays a set of tabs dividing a section of a page into
 * logical subsections or views. The currently selected tab is communicated
 * through assignment to the variable bound to the <code>current</code>
 * attribute. No navigation occurs as a result of selecting a tab.
 */
angular.module("navigation").directive("guacSectionTabs", [
  "$injector",
  function guacSectionTabs($injector) {
    // Required services
    var translationStringService = $injector.get("translationStringService");

    var directive = {
      restrict: "E",
      replace: true,
      templateUrl: "app/navigation/templates/guacSectionTabs.html",

      scope: {
        /**
         * The translation namespace to use when producing translation
         * strings for each tab. Tab translation strings will be of the
         * form:
         *
         * <code>NAMESPACE.SECTION_HEADER_NAME<code>
         *
         * where <code>NAMESPACE</code> is the namespace provided to this
         * attribute and <code>NAME</code> is one of the names within the
         * array provided to the <code>tabs</code> attribute and
         * transformed via translationStringService.canonicalize().
         */
        namespace: "@",

        /**
         * The name of the currently selected tab. This name MUST be one of
         * the names present in the array given via the <code>tabs</code>
         * attribute. This directive will not automatically choose an
         * initially selected tab, and a default value should be manually
         * assigned to <code>current</code> to ensure a tab is initially
         * selected.
         *
         * @type String
         */
        current: "=",

        /**
         * The unique names of all tabs which should be made available, in
         * display order. These names will be assigned to the variable
         * bound to the <code>current</code> attribute when the current
         * tab changes.
         *
         * @type String[]
         */
        tabs: "=",
      },
    };

    directive.controller = [
      "$scope",
      function dataSourceTabsController($scope) {
        /**
         * Produces the translation string for the section header representing
         * the tab having the given name. The translation string will be of the
         * form:
         *
         * <code>NAMESPACE.SECTION_HEADER_NAME<code>
         *
         * where <code>NAMESPACE</code> is the namespace provided to the
         * directive and <code>NAME</code> is the given name transformed
         * via translationStringService.canonicalize().
         *
         * @param {String} name
         *     The name of the tab.
         *
         * @returns {String}
         *     The translation string which produces the translated header
         *     of the tab having the given name.
         */
        $scope.getSectionHeader = function getSectionHeader(name) {
          // If no name, then no header
          if (!name) return "";

          return (
            translationStringService.canonicalize(
              $scope.namespace || "MISSING_NAMESPACE"
            ) +
            ".SECTION_HEADER_" +
            translationStringService.canonicalize(name)
          );
        };

        /**
         * Selects the tab having the given name. The name of the currently
         * selected tab will be communicated outside the directive through
         * $scope.current.
         *
         * @param {String} name
         *     The name of the tab to select.
         */
        $scope.selectTab = function selectTab(name) {
          $scope.current = name;
        };

        /**
         * Returns whether the tab having the given name is currently
         * selected. A tab is currently selected if its name is stored within
         * $scope.current, as assigned externally or by selectTab().
         *
         * @param {String} name
         *     The name of the tab to test.
         *
         * @returns {Boolean}
         *     true if the tab having the given name is currently selected,
         *     false otherwise.
         */
        $scope.isSelected = function isSelected(name) {
          return $scope.current === name;
        };
      },
    ];

    return directive;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which provides a user-oriented menu containing options for
 * navigation and configuration.
 */
angular.module("navigation").directive("guacUserMenu", [
  function guacUserMenu() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        /**
         * Optional array of actions which are specific to this particular
         * location, as these actions may not be appropriate for other
         * locations which contain the user menu.
         *
         * @type MenuAction[]
         */
        localActions: "=",
      },

      templateUrl: "app/navigation/templates/guacUserMenu.html",
      controller: [
        "$scope",
        "$injector",
        function guacUserMenuController($scope, $injector) {
          // Required types
          var User = $injector.get("User");

          // Get required services
          var $location = $injector.get("$location");
          var $route = $injector.get("$route");
          var authenticationService = $injector.get("authenticationService");
          var requestService = $injector.get("requestService");
          var userService = $injector.get("userService");
          var userPageService = $injector.get("userPageService");

          /**
           * The username of the current user.
           *
           * @type String
           */
          $scope.username = authenticationService.getCurrentUsername();

          /**
           * The user's full name. If not yet available, or if not defined,
           * this will be null.
           *
           * @type String
           */
          $scope.fullName = null;

          /**
           * A URL pointing to relevant user information such as the user's
           * email address. If not yet available, or if no such URL can be
           * determined, this will be null.
           *
           * @type String
           */
          $scope.userURL = null;

          /**
           * The organization, company, group, etc. that the user belongs to.
           * If not yet available, or if not defined, this will be null.
           *
           * @type String
           */
          $scope.organization = null;

          /**
           * The role that the user has at the organization, company, group,
           * etc. they belong to. If not yet available, or if not defined,
           * this will be null.
           *
           * @type String
           */
          $scope.role = null;

          // Display user profile attributes if available
          userService
            .getUser(authenticationService.getDataSource(), $scope.username)
            .then(function userRetrieved(user) {
              // Pull basic profile information
              $scope.fullName = user.attributes[User.Attributes.FULL_NAME];
              $scope.organization =
                user.attributes[User.Attributes.ORGANIZATION];
              $scope.role =
                user.attributes[User.Attributes.ORGANIZATIONAL_ROLE];

              // Link to email address if available
              var email = user.attributes[User.Attributes.EMAIL_ADDRESS];
              $scope.userURL = email ? "mailto:" + email : null;
            }, requestService.IGNORE);

          /**
           * The available main pages for the current user.
           *
           * @type Page[]
           */
          $scope.pages = null;

          // Retrieve the main pages from the user page service
          userPageService
            .getMainPages()
            .then(function retrievedMainPages(pages) {
              $scope.pages = pages;
            });

          /**
           * Returns whether the current user has authenticated anonymously.
           *
           * @returns {Boolean}
           *     true if the current user has authenticated anonymously, false
           *     otherwise.
           */
          $scope.isAnonymous = function isAnonymous() {
            return authenticationService.isAnonymous();
          };

          /**
           * Logs out the current user, redirecting them to back to the root
           * after logout completes.
           */
          $scope.logout = function logout() {
            authenticationService
              .logout()
              ["catch"](requestService.IGNORE)
              ["finally"](function logoutComplete() {
                if ($location.path() !== "/") $location.url("/");
                else $route.reload();
              });
          };

          /**
           * Action which logs out the current user, redirecting them to back
           * to the login screen after logout completes.
           */
          var LOGOUT_ACTION = {
            name: "USER_MENU.ACTION_LOGOUT",
            className: "logout",
            callback: $scope.logout,
          };

          /**
           * All available actions for the current user.
           */
          $scope.actions = [LOGOUT_ACTION];
        },
      ], // end controller
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Module for generating and implementing user navigation options.
 */
angular.module("navigation", ["auth", "form", "notification", "rest"]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for generating all the important pages a user can visit.
 */
angular.module("navigation").factory("userPageService", [
  "$injector",
  function userPageService($injector) {
    // Get required types
    var ClientIdentifier = $injector.get("ClientIdentifier");
    var ConnectionGroup = $injector.get("ConnectionGroup");
    var PageDefinition = $injector.get("PageDefinition");
    var PermissionSet = $injector.get("PermissionSet");

    // Get required services
    var $q = $injector.get("$q");
    var authenticationService = $injector.get("authenticationService");
    var connectionGroupService = $injector.get("connectionGroupService");
    var dataSourceService = $injector.get("dataSourceService");
    var permissionService = $injector.get("permissionService");
    var requestService = $injector.get("requestService");
    var translationStringService = $injector.get("translationStringService");

    var service = {};

    /**
     * The home page to assign to a user if they can navigate to more than one
     * page.
     *
     * @type PageDefinition
     */
    var SYSTEM_HOME_PAGE = new PageDefinition({
      name: "USER_MENU.ACTION_NAVIGATE_HOME",
      url: "/",
    });

    /**
     * Returns an appropriate home page for the current user.
     *
     * @param {Object.<String, ConnectionGroup>} rootGroups
     *     A map of all root connection groups visible to the current user,
     *     where each key is the identifier of the corresponding data source.
     *
     * @param {Object.<String, PermissionSet>} permissions
     *     A map of all permissions granted to the current user, where each
     *     key is the identifier of the corresponding data source.
     *
     * @returns {PageDefinition}
     *     The user's home page.
     */
    var generateHomePage = function generateHomePage(rootGroups, permissions) {
      var settingsPages = generateSettingsPages(permissions);

      // If user has access to settings pages, return home page and skip
      // evaluation for automatic connections.  The Preferences page is
      // a Settings page and is always visible, and the Session management
      // page is also available to all users so that they can kill their
      // own session.  We look for more than those two pages to determine
      // if we should go to the home page.
      if (settingsPages.length > 2) return SYSTEM_HOME_PAGE;

      // If exactly one connection or balancing group is available, use
      // that as the home page
      var clientPages = service.getClientPages(rootGroups);
      return clientPages.length === 1 ? clientPages[0] : SYSTEM_HOME_PAGE;
    };

    /**
     * Adds to the given array all pages that the current user may use to
     * access connections or balancing groups that are descendants of the given
     * connection group.
     *
     * @param {PageDefinition[]} clientPages
     *     The array that pages should be added to.
     *
     * @param {String} dataSource
     *     The data source containing the given connection group.
     *
     * @param {ConnectionGroup} connectionGroup
     *     The connection group ancestor of the connection or balancing group
     *     descendants whose pages should be added to the given array.
     */
    var addClientPages = function addClientPages(
      clientPages,
      dataSource,
      connectionGroup
    ) {
      // Add pages for all child connections
      angular.forEach(
        connectionGroup.childConnections,
        function addConnectionPage(connection) {
          clientPages.push(
            new PageDefinition({
              name: connection.name,
              url:
                "/client/" +
                ClientIdentifier.toString({
                  dataSource: dataSource,
                  type: ClientIdentifier.Types.CONNECTION,
                  id: connection.identifier,
                }),
            })
          );
        }
      );

      // Add pages for all child balancing groups, as well as the connectable
      // descendants of all balancing groups of any type
      angular.forEach(
        connectionGroup.childConnectionGroups,
        function addConnectionGroupPage(connectionGroup) {
          if (connectionGroup.type === ConnectionGroup.Type.BALANCING) {
            clientPages.push(
              new PageDefinition({
                name: connectionGroup.name,
                url:
                  "/client/" +
                  ClientIdentifier.toString({
                    dataSource: dataSource,
                    type: ClientIdentifier.Types.CONNECTION_GROUP,
                    id: connectionGroup.identifier,
                  }),
              })
            );
          }

          addClientPages(clientPages, dataSource, connectionGroup);
        }
      );
    };

    /**
     * Returns a full list of all pages that the current user may use to access
     * a connection or balancing group, regardless of the depth of those
     * connections/groups within the connection hierarchy.
     *
     * @param {Object.<String, ConnectionGroup>} rootGroups
     *     A map of all root connection groups visible to the current user,
     *     where each key is the identifier of the corresponding data source.
     *
     * @returns {PageDefinition[]}
     *     A list of all pages that the current user may use to access a
     *     connection or balancing group.
     */
    service.getClientPages = function getClientPages(rootGroups) {
      var clientPages = [];

      // Determine whether a connection or balancing group should serve as
      // the home page
      for (var dataSource in rootGroups) {
        addClientPages(clientPages, dataSource, rootGroups[dataSource]);
      }

      return clientPages;
    };

    /**
     * Returns a promise which resolves with an appropriate home page for the
     * current user. The promise will not be rejected.
     *
     * @returns {Promise.<Page>}
     *     A promise which resolves with the user's default home page.
     */
    service.getHomePage = function getHomePage() {
      var deferred = $q.defer();

      // Resolve promise using home page derived from root connection groups
      var getRootGroups = dataSourceService.apply(
        connectionGroupService.getConnectionGroupTree,
        authenticationService.getAvailableDataSources(),
        ConnectionGroup.ROOT_IDENTIFIER
      );
      var getPermissionSets = dataSourceService.apply(
        permissionService.getPermissions,
        authenticationService.getAvailableDataSources(),
        authenticationService.getCurrentUsername()
      );

      $q.all({
        rootGroups: getRootGroups,
        permissionsSets: getPermissionSets,
      }).then(function rootConnectionGroupsPermissionsRetrieved(data) {
        deferred.resolve(
          generateHomePage(data.rootGroups, data.permissionsSets)
        );
      }, requestService.DIE);

      return deferred.promise;
    };

    /**
     * Returns all settings pages that the current user can visit. This can
     * include any of the various manage pages.
     *
     * @param {Object.<String, PermissionSet>} permissionSets
     *     A map of all permissions granted to the current user, where each
     *     key is the identifier of the corresponding data source.
     *
     * @returns {Page[]}
     *     An array of all settings pages that the current user can visit.
     */
    var generateSettingsPages = function generateSettingsPages(permissionSets) {
      var pages = [];

      var canManageUsers = [];
      var canManageUserGroups = [];
      var canManageConnections = [];
      var canViewConnectionRecords = [];

      // Inspect the contents of each provided permission set
      angular.forEach(
        authenticationService.getAvailableDataSources(),
        function inspectPermissions(dataSource) {
          // Get permissions for current data source, skipping if non-existent
          var permissions = permissionSets[dataSource];
          if (!permissions) return;

          // Do not modify original object
          permissions = angular.copy(permissions);

          // Ignore permission to update root group
          PermissionSet.removeConnectionGroupPermission(
            permissions,
            PermissionSet.ObjectPermissionType.UPDATE,
            ConnectionGroup.ROOT_IDENTIFIER
          );

          // Ignore permission to update self
          PermissionSet.removeUserPermission(
            permissions,
            PermissionSet.ObjectPermissionType.UPDATE,
            authenticationService.getCurrentUsername()
          );

          // Determine whether the current user needs access to the user management UI
          if (
            // System permissions
            PermissionSet.hasSystemPermission(
              permissions,
              PermissionSet.SystemPermissionType.ADMINISTER
            ) ||
            PermissionSet.hasSystemPermission(
              permissions,
              PermissionSet.SystemPermissionType.CREATE_USER
            ) ||
            // Permission to update users
            PermissionSet.hasUserPermission(
              permissions,
              PermissionSet.ObjectPermissionType.UPDATE
            ) ||
            // Permission to delete users
            PermissionSet.hasUserPermission(
              permissions,
              PermissionSet.ObjectPermissionType.DELETE
            ) ||
            // Permission to administer users
            PermissionSet.hasUserPermission(
              permissions,
              PermissionSet.ObjectPermissionType.ADMINISTER
            )
          ) {
            canManageUsers.push(dataSource);
          }

          // Determine whether the current user needs access to the group management UI
          if (
            // System permissions
            PermissionSet.hasSystemPermission(
              permissions,
              PermissionSet.SystemPermissionType.ADMINISTER
            ) ||
            PermissionSet.hasSystemPermission(
              permissions,
              PermissionSet.SystemPermissionType.CREATE_USER_GROUP
            ) ||
            // Permission to update user groups
            PermissionSet.hasUserGroupPermission(
              permissions,
              PermissionSet.ObjectPermissionType.UPDATE
            ) ||
            // Permission to delete user groups
            PermissionSet.hasUserGroupPermission(
              permissions,
              PermissionSet.ObjectPermissionType.DELETE
            ) ||
            // Permission to administer user groups
            PermissionSet.hasUserGroupPermission(
              permissions,
              PermissionSet.ObjectPermissionType.ADMINISTER
            )
          ) {
            canManageUserGroups.push(dataSource);
          }

          // Determine whether the current user needs access to the connection management UI
          if (
            // System permissions
            PermissionSet.hasSystemPermission(
              permissions,
              PermissionSet.SystemPermissionType.ADMINISTER
            ) ||
            PermissionSet.hasSystemPermission(
              permissions,
              PermissionSet.SystemPermissionType.CREATE_CONNECTION
            ) ||
            PermissionSet.hasSystemPermission(
              permissions,
              PermissionSet.SystemPermissionType.CREATE_CONNECTION_GROUP
            ) ||
            // Permission to update connections or connection groups
            PermissionSet.hasConnectionPermission(
              permissions,
              PermissionSet.ObjectPermissionType.UPDATE
            ) ||
            PermissionSet.hasConnectionGroupPermission(
              permissions,
              PermissionSet.ObjectPermissionType.UPDATE
            ) ||
            // Permission to delete connections or connection groups
            PermissionSet.hasConnectionPermission(
              permissions,
              PermissionSet.ObjectPermissionType.DELETE
            ) ||
            PermissionSet.hasConnectionGroupPermission(
              permissions,
              PermissionSet.ObjectPermissionType.DELETE
            ) ||
            // Permission to administer connections or connection groups
            PermissionSet.hasConnectionPermission(
              permissions,
              PermissionSet.ObjectPermissionType.ADMINISTER
            ) ||
            PermissionSet.hasConnectionGroupPermission(
              permissions,
              PermissionSet.ObjectPermissionType.ADMINISTER
            )
          ) {
            canManageConnections.push(dataSource);
          }

          // Determine whether the current user needs access to view connection history
          if (
            // A user must be a system administrator to view connection records
            PermissionSet.hasSystemPermission(
              permissions,
              PermissionSet.SystemPermissionType.ADMINISTER
            )
          ) {
            canViewConnectionRecords.push(dataSource);
          }
        }
      );

      // Add link to Session management (always accessible)
      pages.push(
        new PageDefinition({
          name: "USER_MENU.ACTION_MANAGE_SESSIONS",
          url: "/settings/sessions",
        })
      );

      // If user can manage connections, add links for connection management pages
      angular.forEach(
        canViewConnectionRecords,
        function addConnectionHistoryLink(dataSource) {
          pages.push(
            new PageDefinition({
              name: [
                "USER_MENU.ACTION_VIEW_HISTORY",
                translationStringService.canonicalize(
                  "DATA_SOURCE_" + dataSource
                ) + ".NAME",
              ],
              url: "/settings/" + encodeURIComponent(dataSource) + "/history",
            })
          );
        }
      );

      // If user can manage users, add link to user management page
      if (canManageUsers.length) {
        pages.push(
          new PageDefinition({
            name: "USER_MENU.ACTION_MANAGE_USERS",
            url: "/settings/users",
          })
        );
      }

      // If user can manage user groups, add link to group management page
      if (canManageUserGroups.length) {
        pages.push(
          new PageDefinition({
            name: "USER_MENU.ACTION_MANAGE_USER_GROUPS",
            url: "/settings/userGroups",
          })
        );
      }

      // If user can manage connections, add links for connection management pages
      angular.forEach(
        canManageConnections,
        function addConnectionManagementLink(dataSource) {
          pages.push(
            new PageDefinition({
              name: [
                "USER_MENU.ACTION_MANAGE_CONNECTIONS",
                translationStringService.canonicalize(
                  "DATA_SOURCE_" + dataSource
                ) + ".NAME",
              ],
              url:
                "/settings/" + encodeURIComponent(dataSource) + "/connections",
            })
          );
        }
      );

      // Add link to user preferences (always accessible)
      pages.push(
        new PageDefinition({
          name: "USER_MENU.ACTION_MANAGE_PREFERENCES",
          url: "/settings/preferences",
        })
      );

      return pages;
    };

    /**
     * Returns a promise which resolves to an array of all settings pages that
     * the current user can visit. This can include any of the various manage
     * pages. The promise will not be rejected.
     *
     * @returns {Promise.<Page[]>}
     *     A promise which resolves to an array of all settings pages that the
     *     current user can visit.
     */
    service.getSettingsPages = function getSettingsPages() {
      var deferred = $q.defer();

      // Retrieve current permissions
      dataSourceService
        .apply(
          permissionService.getEffectivePermissions,
          authenticationService.getAvailableDataSources(),
          authenticationService.getCurrentUsername()
        )

        // Resolve promise using settings pages derived from permissions
        .then(function permissionsRetrieved(permissions) {
          deferred.resolve(generateSettingsPages(permissions));
        }, requestService.DIE);

      return deferred.promise;
    };

    /**
     * Returns all the main pages that the current user can visit. This can
     * include the home page, manage pages, etc. In the case that there are no
     * applicable pages of this sort, it may return a client page.
     *
     * @param {Object.<String, ConnectionGroup>} rootGroups
     *     A map of all root connection groups visible to the current user,
     *     where each key is the identifier of the corresponding data source.
     *
     * @param {Object.<String, PermissionSet>} permissions
     *     A map of all permissions granted to the current user, where each
     *     key is the identifier of the corresponding data source.
     *
     * @returns {Page[]}
     *     An array of all main pages that the current user can visit.
     */
    var generateMainPages = function generateMainPages(
      rootGroups,
      permissions
    ) {
      var pages = [];

      // Get home page and settings pages
      var homePage = generateHomePage(rootGroups, permissions);
      var settingsPages = generateSettingsPages(permissions);

      // Only include the home page in the list of main pages if the user
      // can navigate elsewhere.
      if (homePage === SYSTEM_HOME_PAGE || settingsPages.length)
        pages.push(homePage);

      // Add generic link to the first-available settings page
      if (settingsPages.length) {
        pages.push(
          new PageDefinition({
            name: "USER_MENU.ACTION_MANAGE_SETTINGS",
            url: settingsPages[0].url,
          })
        );
      }

      return pages;
    };

    /**
     * Returns a promise which resolves to an array of all main pages that the
     * current user can visit. This can include the home page, manage pages,
     * etc. In the case that there are no applicable pages of this sort, it may
     * return a client page. The promise will not be rejected.
     *
     * @returns {Promise.<Page[]>}
     *     A promise which resolves to an array of all main pages that the
     *     current user can visit.
     */
    service.getMainPages = function getMainPages() {
      var deferred = $q.defer();

      var rootGroups = null;
      var permissions = null;

      /**
       * Resolves the main pages retrieval promise, if possible. If
       * insufficient data is available, this function does nothing.
       */
      var resolveMainPages = function resolveMainPages() {
        if (rootGroups && permissions)
          deferred.resolve(generateMainPages(rootGroups, permissions));
      };

      // Retrieve root group, resolving main pages if possible
      dataSourceService
        .apply(
          connectionGroupService.getConnectionGroupTree,
          authenticationService.getAvailableDataSources(),
          ConnectionGroup.ROOT_IDENTIFIER
        )
        .then(function rootConnectionGroupsRetrieved(retrievedRootGroups) {
          rootGroups = retrievedRootGroups;
          resolveMainPages();
        }, requestService.DIE);

      // Retrieve current permissions
      dataSourceService
        .apply(
          permissionService.getEffectivePermissions,
          authenticationService.getAvailableDataSources(),
          authenticationService.getCurrentUsername()
        )

        // Resolving main pages if possible
        .then(function permissionsRetrieved(retrievedPermissions) {
          permissions = retrievedPermissions;
          resolveMainPages();
        }, requestService.DIE);

      return deferred.promise;
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the ClientIdentifier class definition.
 */
angular.module("client").factory("ClientIdentifier", [
  "$injector",
  function defineClientIdentifier($injector) {
    // Required services
    var authenticationService = $injector.get("authenticationService");
    var $window = $injector.get("$window");

    /**
     * Object which uniquely identifies a particular connection or connection
     * group within Guacamole. This object can be converted to/from a string to
     * generate a guaranteed-unique, deterministic identifier for client URLs.
     *
     * @constructor
     * @param {ClientIdentifier|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ClientIdentifier.
     */
    var ClientIdentifier = function ClientIdentifier(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The identifier of the data source associated with the object to
       * which the client will connect. This identifier will be the
       * identifier of an AuthenticationProvider within the Guacamole web
       * application.
       *
       * @type String
       */
      this.dataSource = template.dataSource;

      /**
       * The type of object to which the client will connect. Possible values
       * are defined within ClientIdentifier.Types.
       *
       * @type String
       */
      this.type = template.type;

      /**
       * The unique identifier of the object to which the client will
       * connect.
       *
       * @type String
       */
      this.id = template.id;
    };

    /**
     * All possible ClientIdentifier types.
     *
     * @type Object.<String, String>
     */
    ClientIdentifier.Types = {
      /**
       * The type string for a Guacamole connection.
       *
       * @type String
       */
      CONNECTION: "c",

      /**
       * The type string for a Guacamole connection group.
       *
       * @type String
       */
      CONNECTION_GROUP: "g",

      /**
       * The type string for an active Guacamole connection.
       *
       * @type String
       */
      ACTIVE_CONNECTION: "a",
    };

    /**
     * Converts the given ClientIdentifier or ClientIdentifier-like object to
     * a String representation. Any object having the same properties as
     * ClientIdentifier may be used, but only those properties will be taken
     * into account when producing the resulting String.
     *
     * @param {ClientIdentifier|Object} id
     *     The ClientIdentifier or ClientIdentifier-like object to convert to
     *     a String representation.
     *
     * @returns {String}
     *     A deterministic String representation of the given ClientIdentifier
     *     or ClientIdentifier-like object.
     */
    ClientIdentifier.toString = function toString(id) {
      return $window.btoa([id.id, id.type, id.dataSource].join("\0"));
    };

    /**
     * Converts the given String into the corresponding ClientIdentifier. If
     * the provided String is not a valid identifier, it will be interpreted
     * as the identifier of a connection within the data source that
     * authenticated the current user.
     *
     * @param {String} str
     *     The String to convert to a ClientIdentifier.
     *
     * @returns {ClientIdentifier}
     *     The ClientIdentifier represented by the given String.
     */
    ClientIdentifier.fromString = function fromString(str) {
      try {
        var values = $window.atob(str).split("\0");
        return new ClientIdentifier({
          id: values[0],
          type: values[1],
          dataSource: values[2],
        });
      } catch (e) {
        // If the provided string is invalid, transform into a reasonable guess
        return new ClientIdentifier({
          id: str,
          type: ClientIdentifier.Types.CONNECTION,
          dataSource: authenticationService.getDataSource() || "default",
        });
      }
    };

    return ClientIdentifier;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the MenuAction class definition.
 */
angular.module("navigation").factory("MenuAction", [
  function defineMenuAction() {
    /**
     * Creates a new MenuAction, which pairs an arbitrary callback with
     * an action name. The name of this action will ultimately be presented to
     * the user when the user when this action's associated menu is open.
     *
     * @constructor
     * @param {String} name
     *     The name of this action.
     *
     * @param {Function} callback
     *     The callback to call when the user elects to perform this action.
     *
     * @param {String} className
     *     The CSS class to associate with this action, if any.
     */
    var MenuAction = function MenuAction(name, callback, className) {
      /**
       * Reference to this MenuAction.
       *
       * @type MenuAction
       */
      var action = this;

      /**
       * The CSS class associated with this action.
       *
       * @type String
       */
      this.className = className;

      /**
       * The name of this action.
       *
       * @type String
       */
      this.name = name;

      /**
       * The callback to call when this action is performed.
       *
       * @type Function
       */
      this.callback = callback;
    };

    return MenuAction;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the PageDefinition class definition.
 */
angular.module("navigation").factory("PageDefinition", [
  function definePageDefinition() {
    /**
     * Creates a new PageDefinition object which pairs the URL of a page with
     * an arbitrary, human-readable name.
     *
     * @constructor
     * @param {PageDefinition|Object} template
     *     The object whose properties should be copied within the new
     *     PageDefinition.
     */
    var PageDefinition = function PageDefinition(template) {
      /**
       * The the name of the page, which should be a translation table key.
       * Alternatively, this may also be a list of names, where the final
       * name represents the page and earlier names represent categorization.
       * Those categorical names may be rendered hierarchically as a system
       * of menus, tabs, etc.
       *
       * @type String|String[]
       */
      this.name = template.name;

      /**
       * The URL of the page.
       *
       * @type String
       */
      this.url = template.url;

      /**
       * The CSS class name to associate with this page, if any. This will be
       * an empty string by default.
       *
       * @type String
       */
      this.className = template.className || "";

      /**
       * A numeric value denoting the relative sort order when compared to
       * other sibling PageDefinitions. If unspecified, sort order is
       * determined by the system using the PageDefinition.
       *
       * @type Number
       */
      this.weight = template.weight;
    };

    return PageDefinition;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive for the guacamole client.
 */
angular.module("notification").directive("guacNotification", [
  function guacNotification() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The notification to display.
         *
         * @type Notification|Object
         */
        notification: "=",
      },

      templateUrl: "app/notification/templates/guacNotification.html",
      controller: [
        "$scope",
        "$interval",
        function guacNotificationController($scope, $interval) {
          // // Update progress bar if end known
          // $scope.$watch("notification.progress.ratio", function updateProgress(ratio) {
          //     $scope.progressPercent = ratio * 100;
          // });
          // $scope.$watch("notification", function resetTimeRemaining(notification) {
          //     var countdown = notification.countdown;
          //     // Clean up any existing interval
          //     if ($scope.interval)
          //         $interval.cancel($scope.interval);
          //     // Update and handle countdown, if provided
          //     if (countdown) {
          //         $scope.timeRemaining = countdown.remaining;
          //         $scope.interval = $interval(function updateTimeRemaining() {
          //             // Update time remaining
          //             $scope.timeRemaining--;
          //             // Call countdown callback when time remaining expires
          //             if ($scope.timeRemaining === 0 && countdown.callback)
          //                 countdown.callback();
          //         }, 1000, $scope.timeRemaining);
          //     }
          // });
          // // Clean up interval upon destruction
          // $scope.$on("$destroy", function destroyNotification() {
          //     if ($scope.interval)
          //         $interval.cancel($scope.interval);
          // });
        },
      ],
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The module for code used to display arbitrary notifications.
 */
angular.module("notification", ["rest", "storage"]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for displaying notifications and modal status dialogs.
 */
angular.module("notification").factory("guacNotification", [
  "$injector",
  function guacNotification($injector) {
    // Required services
    var $rootScope = $injector.get("$rootScope");
    var requestService = $injector.get("requestService");
    var sessionStorageFactory = $injector.get("sessionStorageFactory");

    var service = {};

    /**
     * Getter/setter which retrieves or sets the current status notification,
     * which may simply be false if no status is currently shown.
     *
     * @type Function
     */
    var storedStatus = sessionStorageFactory.create(false);

    /**
     * An action to be provided along with the object sent to showStatus which
     * closes the currently-shown status dialog.
     *
     * @type NotificationAction
     */
    service.ACKNOWLEDGE_ACTION = {
      name: "APP.ACTION_ACKNOWLEDGE",
      callback: function acknowledgeCallback() {
        service.showStatus(false);
      },
    };

    /**
     * Retrieves the current status notification, which may simply be false if
     * no status is currently shown.
     *
     * @type Notification|Boolean
     */
    service.getStatus = function getStatus() {
      return storedStatus();
    };

    /**
     * Shows or hides the given notification as a modal status. If a status
     * notification is currently shown, no further statuses will be shown
     * until the current status is hidden.
     *
     * @param {Notification|Boolean|Object} status
     *     The status notification to show.
     *
     * @example
     *
     * // To show a status message with actions
     * guacNotification.showStatus({
     *     'title'      : 'Disconnected',
     *     'text'       : {
     *         'key' : 'NAMESPACE.SOME_TRANSLATION_KEY'
     *     },
     *     'actions'    : {
     *         'name'       : 'reconnect',
     *         'callback'   : function () {
     *             // Reconnection code goes here
     *         }
     *     }
     * });
     *
     * // To hide the status message
     * guacNotification.showStatus(false);
     */
    service.showStatus = function showStatus(status) {
      if (!storedStatus() || !status) storedStatus(status);
    };

    /**
     * Promise error callback which displays a modal notification for all
     * rejections due to REST errors. The message displayed to the user within
     * the notification is provided by the contents of the @link{Error} object
     * within the REST response. All other rejections, such as those due to
     * JavaScript errors, are logged to the browser console without displaying
     * any notification.
     *
     * @constant
     * @type Function
     */
    service.SHOW_REQUEST_ERROR = requestService.createErrorCallback(
      function showRequestError(error) {
        service.showStatus({
          className: "error",
          title: "APP.DIALOG_HEADER_ERROR",
          text: error.translatableMessage,
          actions: [service.ACKNOWLEDGE_ACTION],
        });
      }
    );

    // Hide status upon navigation
    $rootScope.$on("$routeChangeSuccess", function () {
      service.showStatus(false);
    });

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the Notification class definition.
 */
angular.module("notification").factory("Notification", [
  function defineNotification() {
    /**
     * Creates a new Notification, initializing the properties of that
     * Notification with the corresponding properties of the given template.
     *
     * @constructor
     * @param {Notification|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     Notification.
     */
    var Notification = function Notification(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The CSS class to associate with the notification, if any.
       *
       * @type String
       */
      this.className = template.className;

      /**
       * The title of the notification.
       *
       * @type String
       */
      this.title = template.title;

      /**
       * The body text of the notification.
       *
       * @type TranslatableMessage
       */
      this.text = template.text;

      /**
       * The translation namespace of the translation strings that will
       * be generated for all fields within the notification. This namespace
       * is absolutely required if form fields will be included in the
       * notification.
       *
       * @type String
       */
      this.formNamespace = template.formNamespace;

      /**
       * Optional form content to display. This may be a form, an array of
       * forms, or a simple array of fields.
       *
       * @type Form[]|Form|Field[]|Field
       */
      this.forms = template.forms;

      /**
       * The object which will receive all field values. Each field value
       * will be assigned to the property of this object having the same
       * name.
       *
       * @type Object.<String, String>
       */
      this.formModel = template.model;

      /**
       * The function to invoke when the form is submitted, if form fields
       * are present within the notification.
       *
       * @type Function
       */
      this.formSubmitCallback = template.formSubmitCallback;

      /**
       * An array of all actions available to the user in response to this
       * notification.
       *
       * @type NotificationAction[]
       */
      this.actions = template.actions || [];

      /**
       * The current progress state of the ongoing action associated with this
       * notification.
       *
       * @type NotificationProgress
       */
      this.progress = template.progress;

      /**
       * The countdown and corresponding default action which applies to
       * this notification, if any.
       *
       * @type NotificationCountdown
       */
      this.countdown = template.countdown;
    };

    return Notification;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the NotificationAction class definition.
 */
angular.module("notification").factory("NotificationAction", [
  function defineNotificationAction() {
    /**
     * Creates a new NotificationAction, which pairs an arbitrary callback with
     * an action name. The name of this action will ultimately be presented to
     * the user when the user is prompted to choose among available actions.
     *
     * @constructor
     * @param {String} name The name of this action.
     *
     * @param {Function} callback
     *     The callback to call when the user elects to perform this action.
     *
     * @param {String} className
     *     The CSS class to associate with this action, if any.
     */
    var NotificationAction = function NotificationAction(
      name,
      callback,
      className
    ) {
      /**
       * Reference to this NotificationAction.
       *
       * @type NotificationAction
       */
      var action = this;

      /**
       * The CSS class associated with this action.
       *
       * @type String
       */
      this.className = className;

      /**
       * The name of this action.
       *
       * @type String
       */
      this.name = name;

      /**
       * The callback to call when this action is performed.
       *
       * @type Function
       */
      this.callback = callback;
    };

    return NotificationAction;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the NotificationCountdown class definition.
 */
angular.module("notification").factory("NotificationCountdown", [
  function defineNotificationCountdown() {
    /**
     * Creates a new NotificationCountdown which describes an action that
     * should be performed after a specific number of seconds has elapsed.
     *
     * @constructor
     * @param {String} text The body text of the notification countdown.
     *
     * @param {Number} remaining
     *     The number of seconds remaining in the countdown.
     *
     * @param {Function} [callback]
     *     The callback to call when the countdown elapses.
     */
    var NotificationCountdown = function NotificationCountdown(
      text,
      remaining,
      callback
    ) {
      /**
       * Reference to this NotificationCountdown.
       *
       * @type NotificationCountdown
       */
      var countdown = this;

      /**
       * The body text of the notification countdown. For the sake of i18n,
       * the variable REMAINING should be applied within the translation
       * string for formatting plurals, etc.
       *
       * @type String
       */
      this.text = text;

      /**
       * The number of seconds remaining in the countdown. After this number
       * of seconds elapses, the callback associated with this
       * NotificationCountdown will be called.
       *
       * @type Number
       */
      this.remaining = remaining;

      /**
       * The callback to call when this countdown expires.
       *
       * @type Function
       */
      this.callback = callback;
    };

    return NotificationCountdown;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Provides the NotificationProgress class definition.
 */
angular.module("notification").factory("NotificationProgress", [
  function defineNotificationProgress() {
    /**
     * Creates a new NotificationProgress which describes the current status
     * of an operation, and how much of that operation remains to be performed.
     *
     * @constructor
     * @param {String} text The text describing the operation progress.
     *
     * @param {Number} value
     *     The current state of operation progress, as an arbitrary number
     *     which increases as the operation continues.
     *
     * @param {String} [unit]
     *     The unit of the arbitrary value, if that value has an associated
     *     unit.
     *
     * @param {Number} [ratio]
     *     If known, the current status of the operation as a value between 0
     *     and 1 inclusive, where 0 is not yet started, and 1 is complete.
     */
    var NotificationProgress = function NotificationProgress(
      text,
      value,
      unit,
      ratio
    ) {
      /**
       * The text describing the operation progress. For the sake of i18n,
       * the variable PROGRESS should be applied within the translation
       * string for formatting plurals, etc., while UNIT should be used
       * for the progress unit, if any.
       *
       * @type String
       */
      this.text = text;

      /**
       * The current state of operation progress, as an arbitrary number which
       * increases as the operation continues.
       *
       * @type Number
       */
      this.value = value;

      /**
       * The unit of the arbitrary value, if that value has an associated
       * unit.
       *
       * @type String
       */
      this.unit = unit;

      /**
       * If known, the current status of the operation as a value between 0
       * and 1 inclusive, where 0 is not yet started, and 1 is complete.
       *
       * @type String
       */
      this.ratio = ratio;
    };

    return NotificationProgress;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which displays the Guacamole on-screen keyboard.
 */
angular.module("osk").directive("guacOsk", [
  function guacOsk() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The URL for the Guacamole on-screen keyboard layout to use.
         *
         * @type String
         */
        layout: "=",
      },

      templateUrl: "app/osk/templates/guacOsk.html",
      controller: [
        "$scope",
        "$injector",
        "$element",
        function guacOsk($scope, $injector, $element) {
          // Required services
          var $http = $injector.get("$http");
          var $rootScope = $injector.get("$rootScope");
          var cacheService = $injector.get("cacheService");

          /**
           * The current on-screen keyboard, if any.
           *
           * @type Guacamole.OnScreenKeyboard
           */
          var keyboard = null;

          /**
           * The main containing element for the entire directive.
           *
           * @type Element
           */
          var main = $element[0];

          // Size keyboard to same size as main element
          $scope.keyboardResized = function keyboardResized() {
            // Resize keyboard, if defined
            if (keyboard) keyboard.resize(main.offsetWidth);
          };

          // Set layout whenever URL changes
          $scope.$watch("layout", function setLayout(url) {
            // Remove current keyboard
            if (keyboard) {
              main.removeChild(keyboard.getElement());
              keyboard = null;
            }

            // Load new keyboard
            if (url) {
              // Retrieve layout JSON
              $http({
                cache: cacheService.languages,
                method: "GET",
                url: url,
              })
                // Build OSK with retrieved layout
                .then(function layoutRetrieved(request) {
                  var layout = request.data;

                  // Abort if the layout changed while we were waiting for a response
                  if ($scope.layout !== url) return;

                  // Add OSK element
                  keyboard = new Guacamole.OnScreenKeyboard(layout);
                  main.appendChild(keyboard.getElement());

                  // Init size
                  keyboard.resize(main.offsetWidth);

                  // Broadcast keydown for each key pressed
                  keyboard.onkeydown = function (keysym) {
                    $rootScope.$broadcast("guacSyntheticKeydown", keysym);
                  };

                  // Broadcast keydown for each key released
                  keyboard.onkeyup = function (keysym) {
                    $rootScope.$broadcast("guacSyntheticKeyup", keysym);
                  };
                }, angular.noop);
            }
          }); // end layout scope watch
        },
      ],
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Module for displaying the Guacamole on-screen keyboard.
 */
angular.module("osk", []);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The module for code relating to communication with the REST API of the
 * Guacamole web application.
 */
angular.module("rest", ["auth", "locale"]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for operating on active connections via the REST API.
 */
angular.module("rest").factory("activeConnectionService", [
  "$injector",
  function activeConnectionService($injector) {
    // Required services
    var requestService = $injector.get("requestService");
    var authenticationService = $injector.get("authenticationService");

    var service = {};

    /**
     * Makes a request to the REST API to get a single active connection,
     * returning a promise that provides the corresponding
     * @link{ActiveConnection} if successful.
     *
     * @param {String} dataSource
     *     The identifier of the data source to retrieve the active connection
     *     from.
     *
     * @param {String} id
     *     The identifier of the active connection.
     *
     * @returns {Promise.<ActiveConnection>}
     *     A promise which will resolve with a @link{ActiveConnection} upon
     *     success.
     */
    service.getActiveConnection = function getActiveConnection(dataSource, id) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve active connection
      return requestService({
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/activeConnections/" +
          encodeURIComponent(id),
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to get the list of active tunnels,
     * returning a promise that provides a map of @link{ActiveConnection}
     * objects if successful.
     *
     * @param {String[]} [permissionTypes]
     *     The set of permissions to filter with. A user must have one or more
     *     of these permissions for an active connection to appear in the
     *     result.  If null, no filtering will be performed. Valid values are
     *     listed within PermissionSet.ObjectType.
     *
     * @returns {Promise.<Object.<String, ActiveConnection>>}
     *     A promise which will resolve with a map of @link{ActiveConnection}
     *     objects, where each key is the identifier of the corresponding
     *     active connection.
     */
    service.getActiveConnections = function getActiveConnections(
      dataSource,
      permissionTypes
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Add permission filter if specified
      if (permissionTypes) httpParameters.permission = permissionTypes;

      // Retrieve tunnels
      return requestService({
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/activeConnections",
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to delete the active connections having
     * the given identifiers, effectively disconnecting them, returning a
     * promise that can be used for processing the results of the call.
     *
     * @param {String[]} identifiers
     *     The identifiers of the active connections to delete.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     delete operation is successful.
     */
    service.deleteActiveConnections = function deleteActiveConnections(
      dataSource,
      identifiers
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Convert provided array of identifiers to a patch
      var activeConnectionPatch = [];
      identifiers.forEach(function addActiveConnectionPatch(identifier) {
        activeConnectionPatch.push({
          op: "remove",
          path: "/" + identifier,
        });
      });

      // Perform active connection deletion via PATCH
      return requestService({
        method: "PATCH",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/activeConnections",
        params: httpParameters,
        data: activeConnectionPatch,
      });
    };

    /**
     * Makes a request to the REST API to generate credentials which have
     * access strictly to the given active connection, using the restrictions
     * defined by the given sharing profile, returning a promise that provides
     * the resulting @link{UserCredentials} object if successful.
     *
     * @param {String} id
     *     The identifier of the active connection being shared.
     *
     * @param {String} sharingProfile
     *     The identifier of the sharing profile dictating the
     *     semantics/restrictions which apply to the shared session.
     *
     * @returns {Promise.<UserCredentials>}
     *     A promise which will resolve with a @link{UserCredentials} object
     *     upon success.
     */
    service.getSharingCredentials = function getSharingCredentials(
      dataSource,
      id,
      sharingProfile
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Generate sharing credentials
      return requestService({
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/activeConnections/" +
          encodeURIComponent(id) +
          "/sharingCredentials/" +
          encodeURIComponent(sharingProfile),
        params: httpParameters,
      });
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which contains all REST API response caches.
 */
angular.module("rest").factory("cacheService", [
  "$injector",
  function cacheService($injector) {
    // Required services
    var $cacheFactory = $injector.get("$cacheFactory");
    var $rootScope = $injector.get("$rootScope");

    // Service containing all caches
    var service = {};

    /**
     * Shared cache used by both connectionGroupService and
     * connectionService.
     *
     * @type $cacheFactory.Cache
     */
    service.connections = $cacheFactory("API-CONNECTIONS");

    /**
     * Cache used by languageService.
     *
     * @type $cacheFactory.Cache
     */
    service.languages = $cacheFactory("API-LANGUAGES");

    /**
     * Cache used by patchService.
     *
     * @type $cacheFactory.Cache
     */
    service.patches = $cacheFactory("API-PATCHES");

    /**
     * Cache used by schemaService.
     *
     * @type $cacheFactory.Cache
     */
    service.schema = $cacheFactory("API-SCHEMA");

    /**
     * Shared cache used by userService, userGroupService, permissionService,
     * and membershipService.
     *
     * @type $cacheFactory.Cache
     */
    service.users = $cacheFactory("API-USERS");

    /**
     * Clear all caches defined in this service.
     */
    service.clearCaches = function clearCaches() {
      service.connections.removeAll();
      service.languages.removeAll();
      service.schema.removeAll();
      service.users.removeAll();
    };

    // Clear caches on logout
    $rootScope.$on("guacLogout", function handleLogout() {
      service.clearCaches();
    });

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for operating on connection groups via the REST API.
 */
angular.module("rest").factory("connectionGroupService", [
  "$injector",
  function connectionGroupService($injector) {
    // Required services
    var requestService = $injector.get("requestService");
    var authenticationService = $injector.get("authenticationService");
    var cacheService = $injector.get("cacheService");

    // Required types
    var ConnectionGroup = $injector.get("ConnectionGroup");

    var service = {};

    /**
     * Makes a request to the REST API to get an individual connection group
     * and all descendants, returning a promise that provides the corresponding
     * @link{ConnectionGroup} if successful. Descendant groups and connections
     * will be stored as children of that connection group. If a permission
     * type is specified, the result will be filtering by that permission.
     *
     * @param {String} [connectionGroupID=ConnectionGroup.ROOT_IDENTIFIER]
     *     The ID of the connection group to retrieve. If not provided, the
     *     root connection group will be retrieved by default.
     *
     * @param {String[]} [permissionTypes]
     *     The set of permissions to filter with. A user must have one or more
     *     of these permissions for a connection to appear in the result.
     *     If null, no filtering will be performed. Valid values are listed
     *     within PermissionSet.ObjectType.
     *
     * @returns {Promise.ConnectionGroup}
     *     A promise which will resolve with a @link{ConnectionGroup} upon
     *     success.
     */
    service.getConnectionGroupTree = function getConnectionGroupTree(
      dataSource,
      connectionGroupID,
      permissionTypes
    ) {
      // PATCHED BY IAAS
      return Promise.resolve({
        name: "ROOT",
        identifier: "ROOT",
        type: "ORGANIZATIONAL",
        activeConnections: 0,
        childConnections: [
          {
            name: "DEFAULT",
            identifier: "DEFAULT",
            parentIdentifier: "ROOT",
            protocol: "vnc",
            attributes: {},
            activeConnections: 0,
          },
        ],
        attributes: {},
      });

      // Use the root connection group ID if no ID is passed in
      connectionGroupID = connectionGroupID || ConnectionGroup.ROOT_IDENTIFIER;

      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Add permission filter if specified
      if (permissionTypes) httpParameters.permission = permissionTypes;
      // Retrieve connection group
      return requestService({
        cache: cacheService.connections,
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/connectionGroups/" +
          encodeURIComponent(connectionGroupID) +
          "/tree",
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to get an individual connection group,
     * returning a promise that provides the corresponding
     * @link{ConnectionGroup} if successful.
     *
     * @param {String} [connectionGroupID=ConnectionGroup.ROOT_IDENTIFIER]
     *     The ID of the connection group to retrieve. If not provided, the
     *     root connection group will be retrieved by default.
     *
     * @returns {Promise.<ConnectionGroup>} A promise for the HTTP call.
     *     A promise which will resolve with a @link{ConnectionGroup} upon
     *     success.
     */
    service.getConnectionGroup = function getConnectionGroup(
      dataSource,
      connectionGroupID
    ) {
      // Use the root connection group ID if no ID is passed in
      connectionGroupID = connectionGroupID || ConnectionGroup.ROOT_IDENTIFIER;

      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve connection group
      return requestService({
        cache: cacheService.connections,
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/connectionGroups/" +
          encodeURIComponent(connectionGroupID),
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to save a connection group, returning a
     * promise that can be used for processing the results of the call. If the
     * connection group is new, and thus does not yet have an associated
     * identifier, the identifier will be automatically set in the provided
     * connection group upon success.
     *
     * @param {ConnectionGroup} connectionGroup The connection group to update.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     save operation is successful.
     */
    service.saveConnectionGroup = function saveConnectionGroup(
      dataSource,
      connectionGroup
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // If connection group is new, add it and set the identifier automatically
      if (!connectionGroup.identifier) {
        return (
          requestService({
            method: "POST",
            url:
              "api/session/data/" +
              encodeURIComponent(dataSource) +
              "/connectionGroups",
            params: httpParameters,
            data: connectionGroup,
          })
            // Set the identifier on the new connection group and clear the cache
            .then(function connectionGroupCreated(newConnectionGroup) {
              connectionGroup.identifier = newConnectionGroup.identifier;
              cacheService.connections.removeAll();

              // Clear users cache to force reload of permissions for this
              // newly created connection group
              cacheService.users.removeAll();
            })
        );
      }

      // Otherwise, update the existing connection group
      else {
        return (
          requestService({
            method: "PUT",
            url:
              "api/session/data/" +
              encodeURIComponent(dataSource) +
              "/connectionGroups/" +
              encodeURIComponent(connectionGroup.identifier),
            params: httpParameters,
            data: connectionGroup,
          })
            // Clear the cache
            .then(function connectionGroupUpdated() {
              cacheService.connections.removeAll();

              // Clear users cache to force reload of permissions for this
              // newly updated connection group
              cacheService.users.removeAll();
            })
        );
      }
    };

    /**
     * Makes a request to the REST API to delete a connection group, returning
     * a promise that can be used for processing the results of the call.
     *
     * @param {ConnectionGroup} connectionGroup The connection group to delete.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     delete operation is successful.
     */
    service.deleteConnectionGroup = function deleteConnectionGroup(
      dataSource,
      connectionGroup
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Delete connection group
      return (
        requestService({
          method: "DELETE",
          url:
            "api/session/data/" +
            encodeURIComponent(dataSource) +
            "/connectionGroups/" +
            encodeURIComponent(connectionGroup.identifier),
          params: httpParameters,
        })
          // Clear the cache
          .then(function connectionGroupDeleted() {
            cacheService.connections.removeAll();
          })
      );
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for operating on connections via the REST API.
 */
angular.module("rest").factory("connectionService", [
  "$injector",
  function connectionService($injector) {
    // Required services
    var requestService = $injector.get("requestService");
    var authenticationService = $injector.get("authenticationService");
    var cacheService = $injector.get("cacheService");

    var service = {};

    /**
     * Makes a request to the REST API to get a single connection, returning a
     * promise that provides the corresponding @link{Connection} if successful.
     *
     * @param {String} id The ID of the connection.
     *
     * @returns {Promise.<Connection>}
     *     A promise which will resolve with a @link{Connection} upon success.
     *
     * @example
     *
     * connectionService.getConnection('myConnection').then(function(connection) {
     *     // Do something with the connection
     * });
     */
    service.getConnection = function getConnection(dataSource, id) {
      // PATCHED BY IAAS
      return Promise.resolve({
        name: "DEFAULT",
        identifier: "DEFAULT",
        parentIdentifier: "ROOT",
        protocol: "vnc",
        attributes: {},
        activeConnections: 0,
      });
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };
      // PATCHED BY IAAS
      // Retrieve connection
      return requestService({
        cache: cacheService.connections,
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/connections/" +
          encodeURIComponent(id),
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to get the usage history of a single
     * connection, returning a promise that provides the corresponding
     * array of @link{ConnectionHistoryEntry} objects if successful.
     *
     * @param {String} id
     *     The identifier of the connection.
     *
     * @returns {Promise.<ConnectionHistoryEntry[]>}
     *     A promise which will resolve with an array of
     *     @link{ConnectionHistoryEntry} objects upon success.
     */
    service.getConnectionHistory = function getConnectionHistory(
      dataSource,
      id
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve connection history
      return requestService({
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/connections/" +
          encodeURIComponent(id) +
          "/history",
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to get the parameters of a single
     * connection, returning a promise that provides the corresponding
     * map of parameter name/value pairs if successful.
     *
     * @param {String} id
     *     The identifier of the connection.
     *
     * @returns {Promise.<Object.<String, String>>}
     *     A promise which will resolve with an map of parameter name/value
     *     pairs upon success.
     */
    service.getConnectionParameters = function getConnectionParameters(
      dataSource,
      id
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve connection parameters
      return requestService({
        cache: cacheService.connections,
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/connections/" +
          encodeURIComponent(id) +
          "/parameters",
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to save a connection, returning a
     * promise that can be used for processing the results of the call. If the
     * connection is new, and thus does not yet have an associated identifier,
     * the identifier will be automatically set in the provided connection
     * upon success.
     *
     * @param {Connection} connection The connection to update.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     save operation is successful.
     */
    service.saveConnection = function saveConnection(dataSource, connection) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // If connection is new, add it and set the identifier automatically
      if (!connection.identifier) {
        return (
          requestService({
            method: "POST",
            url:
              "api/session/data/" +
              encodeURIComponent(dataSource) +
              "/connections",
            params: httpParameters,
            data: connection,
          })
            // Set the identifier on the new connection and clear the cache
            .then(function connectionCreated(newConnection) {
              connection.identifier = newConnection.identifier;
              cacheService.connections.removeAll();

              // Clear users cache to force reload of permissions for this
              // newly created connection
              cacheService.users.removeAll();
            })
        );
      }

      // Otherwise, update the existing connection
      else {
        return (
          requestService({
            method: "PUT",
            url:
              "api/session/data/" +
              encodeURIComponent(dataSource) +
              "/connections/" +
              encodeURIComponent(connection.identifier),
            params: httpParameters,
            data: connection,
          })
            // Clear the cache
            .then(function connectionUpdated() {
              cacheService.connections.removeAll();

              // Clear users cache to force reload of permissions for this
              // newly updated connection
              cacheService.users.removeAll();
            })
        );
      }
    };

    /**
     * Makes a request to the REST API to delete a connection,
     * returning a promise that can be used for processing the results of the call.
     *
     * @param {Connection} connection The connection to delete.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     delete operation is successful.
     */
    service.deleteConnection = function deleteConnection(
      dataSource,
      connection
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Delete connection
      return (
        requestService({
          method: "DELETE",
          url:
            "api/session/data/" +
            encodeURIComponent(dataSource) +
            "/connections/" +
            encodeURIComponent(connection.identifier),
          params: httpParameters,
        })
          // Clear the cache
          .then(function connectionDeleted() {
            cacheService.connections.removeAll();
          })
      );
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which contains all REST API response caches.
 */
angular.module("rest").factory("dataSourceService", [
  "$injector",
  function dataSourceService($injector) {
    // Required types
    var Error = $injector.get("Error");

    // Required services
    var $q = $injector.get("$q");
    var requestService = $injector.get("requestService");

    // Service containing all caches
    var service = {};

    /**
     * Invokes the given function once for each of the given data sources,
     * passing that data source as the first argument to each invocation,
     * followed by any additional arguments passed to apply(). The results of
     * each invocation are aggregated into a map by data source identifier,
     * and handled through a single promise which is resolved or rejected
     * depending on the success/failure of each resulting REST call. Any error
     * results in rejection of the entire apply() operation, except 404 ("NOT
     * FOUND") errors, which are ignored.
     *
     * @param {Function} fn
     *     The function to call for each of the given data sources. The data
     *     source identifier will be given as the first argument, followed by
     *     the rest of the arguments given to apply(), in order. The function
     *     must return a Promise which is resolved or rejected depending on the
     *     result of the REST call.
     *
     * @param {String[]} dataSources
     *     The array or data source identifiers against which the given
     *     function should be called.
     *
     * @param {...*} args
     *     Any additional arguments to pass to the given function each time it
     *     is called.
     *
     * @returns {Promise.<Object.<String, *>>}
     *     A Promise which resolves with a map of data source identifier to
     *     corresponding result. The result will be the exact object or value
     *     provided as the resolution to the Promise returned by calls to the
     *     given function.
     */
    service.apply = function apply(fn, dataSources) {
      var deferred = $q.defer();

      var requests = [];
      var results = {};

      // Build array of arguments to pass to the given function
      var args = [];
      for (var i = 2; i < arguments.length; i++) args.push(arguments[i]);

      // Retrieve the root group from all data sources
      angular.forEach(
        dataSources,
        function invokeAgainstDataSource(dataSource) {
          // Add promise to list of pending requests
          var deferredRequest = $q.defer();
          requests.push(deferredRequest.promise);

          // Retrieve root group from data source
          fn.apply(this, [dataSource].concat(args))

            // Store result on success
            .then(
              function immediateRequestSucceeded(data) {
                results[dataSource] = data;
                deferredRequest.resolve();
              },

              // Fail on any errors (except "NOT FOUND")
              requestService.createErrorCallback(
                function immediateRequestFailed(error) {
                  if (error.type === Error.Type.NOT_FOUND)
                    deferredRequest.resolve();
                  // Explicitly abort for all other errors
                  else deferredRequest.reject(error);
                }
              )
            );
        }
      );

      // Resolve if all requests succeed
      $q.all(requests).then(
        function requestsSucceeded() {
          deferred.resolve(results);
        },

        // Reject if at least one request fails
        requestService.createErrorCallback(function requestFailed(error) {
          deferred.reject(error);
        })
      );

      return deferred.promise;
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for operating on history records via the REST API.
 */
angular.module("rest").factory("historyService", [
  "$injector",
  function historyService($injector) {
    // Required services
    var requestService = $injector.get("requestService");
    var authenticationService = $injector.get("authenticationService");

    var service = {};

    /**
     * Makes a request to the REST API to get the usage history of all
     * accessible connections, returning a promise that provides the
     * corresponding array of @link{ConnectionHistoryEntry} objects if
     * successful.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the connection
     *     history records to be retrieved. This identifier corresponds to an
     *     AuthenticationProvider within the Guacamole web application.
     *
     * @param {String[]} [requiredContents]
     *     The set of arbitrary strings to filter with. A ConnectionHistoryEntry
     *     must contain each of these values within the associated username,
     *     connection name, start date, or end date to appear in the result. If
     *     null, no filtering will be performed.
     *
     * @param {String[]} [sortPredicates]
     *     The set of predicates to sort against. The resulting array of
     *     ConnectionHistoryEntry objects will be sorted according to the
     *     properties and sort orders defined by each predicate. If null, the
     *     order of the resulting entries is undefined. Valid values are listed
     *     within ConnectionHistoryEntry.SortPredicate.
     *
     * @returns {Promise.<ConnectionHistoryEntry[]>}
     *     A promise which will resolve with an array of
     *     @link{ConnectionHistoryEntry} objects upon success.
     */
    service.getConnectionHistory = function getConnectionHistory(
      dataSource,
      requiredContents,
      sortPredicates
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Filter according to contents if restrictions are specified
      if (requiredContents) httpParameters.contains = requiredContents;

      // Sort according to provided predicates, if any
      if (sortPredicates) httpParameters.order = sortPredicates;

      // Retrieve connection history
      return requestService({
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/history/connections",
        params: httpParameters,
      });
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for operating on language metadata via the REST API.
 */
angular.module("rest").factory("languageService", [
  "$injector",
  function languageService($injector) {
    // Required services
    var requestService = $injector.get("requestService");
    var authenticationService = $injector.get("authenticationService");
    var cacheService = $injector.get("cacheService");

    var service = {};

    /**
     * Makes a request to the REST API to get the list of languages, returning
     * a promise that provides a map of language names by language key if
     * successful.
     *
     * @returns {Promise.<Object.<String, String>>}
     *     A promise which will resolve with a map of language names by
     *     language key upon success.
     */
    service.getLanguages = function getLanguages() {
      // PATCHED BY IAAS
      return Promise.resolve({ zh: "", en: "English" });
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };
      // Retrieve available languages
      return requestService({
        cache: cacheService.languages,
        method: "GET",
        url: "api/languages",
        params: httpParameters,
      });
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for operating on user group memberships via the REST API.
 */
angular.module("rest").factory("membershipService", [
  "$injector",
  function membershipService($injector) {
    // Required services
    var requestService = $injector.get("requestService");
    var authenticationService = $injector.get("authenticationService");
    var cacheService = $injector.get("cacheService");

    // Required types
    var RelatedObjectPatch = $injector.get("RelatedObjectPatch");

    var service = {};

    /**
     * Creates a new array of patches which represents the given changes to an
     * arbitrary set of objects sharing some common relation.
     *
     * @param {String[]} [identifiersToAdd]
     *     The identifiers of all objects which should be added to the
     *     relation, if any.
     *
     * @param {String[]} [identifiersToRemove]
     *     The identifiers of all objects which should be removed from the
     *     relation, if any.
     *
     * @returns {RelatedObjectPatch[]}
     *     A new array of patches which represents the given changes.
     */
    var getRelatedObjectPatch = function getRelatedObjectPatch(
      identifiersToAdd,
      identifiersToRemove
    ) {
      var patch = [];

      angular.forEach(identifiersToAdd, function addIdentifier(identifier) {
        patch.push(
          new RelatedObjectPatch({
            op: RelatedObjectPatch.Operation.ADD,
            value: identifier,
          })
        );
      });

      angular.forEach(
        identifiersToRemove,
        function removeIdentifier(identifier) {
          patch.push(
            new RelatedObjectPatch({
              op: RelatedObjectPatch.Operation.REMOVE,
              value: identifier,
            })
          );
        }
      );

      return patch;
    };

    /**
     * Returns the URL for the REST resource most appropriate for accessing
     * the parent user groups of the user or group having the given identifier.
     *
     * It is important to note that a particular data source can authenticate
     * and provide user groups for a user, even if that user does not exist
     * within that data source (and thus cannot be found beneath
     * "api/session/data/{dataSource}/users")
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user or
     *     group whose parent user groups should be retrieved. This identifier
     *     corresponds to an AuthenticationProvider within the Guacamole web
     *     application.
     *
     * @param {String} identifier
     *     The identifier of the user or group for which the URL of the proper
     *     REST resource should be derived.
     *
     * @param {Boolean} [group]
     *     Whether the provided identifier refers to a user group. If false or
     *     omitted, the identifier given is assumed to refer to a user.
     *
     * @returns {String}
     *     The URL for the REST resource representing the parent user groups of
     *     the user or group having the given identifier.
     */
    var getUserGroupsResourceURL = function getUserGroupsResourceURL(
      dataSource,
      identifier,
      group
    ) {
      // Create base URL for data source
      var base = "api/session/data/" + encodeURIComponent(dataSource);

      // Access parent groups directly (there is no "self" for user groups
      // as there is for users)
      if (group)
        return (
          base + "/userGroups/" + encodeURIComponent(identifier) + "/userGroups"
        );

      // If the username is that of the current user, do not rely on the
      // user actually existing (they may not). Access their parent groups via
      // "self" rather than the collection of defined users.
      if (identifier === authenticationService.getCurrentUsername())
        return base + "/self/userGroups";

      // Otherwise, the user must exist for their parent groups to be
      // accessible. Use the collection of defined users.
      return base + "/users/" + encodeURIComponent(identifier) + "/userGroups";
    };

    /**
     * Makes a request to the REST API to retrieve the identifiers of all
     * parent user groups of which a given user or group is a member, returning
     * a promise that can be used for processing the results of the call.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user or
     *     group whose parent user groups should be retrieved. This identifier
     *     corresponds to an AuthenticationProvider within the Guacamole web
     *     application.
     *
     * @param {String} identifier
     *     The identifier of the user or group to retrieve the parent user
     *     groups of.
     *
     * @param {Boolean} [group]
     *     Whether the provided identifier refers to a user group. If false or
     *     omitted, the identifier given is assumed to refer to a user.
     *
     * @returns {Promise.<String[]>}
     *     A promise for the HTTP call which will resolve with an array
     *     containing the requested identifiers upon success.
     */
    service.getUserGroups = function getUserGroups(
      dataSource,
      identifier,
      group
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve parent groups
      return requestService({
        cache: cacheService.users,
        method: "GET",
        url: getUserGroupsResourceURL(dataSource, identifier, group),
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to modify the parent user groups of
     * which a given user or group is a member, returning a promise that can be
     * used for processing the results of the call.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user or
     *     group whose parent user groups should be modified. This identifier
     *     corresponds to an AuthenticationProvider within the Guacamole web
     *     application.
     *
     * @param {String} identifier
     *     The identifier of the user or group to modify the parent user
     *     groups of.
     *
     * @param {String[]} [addToUserGroups]
     *     The identifier of all parent user groups to which the given user or
     *     group should be added as a member, if any.
     *
     * @param {String[]} [removeFromUserGroups]
     *     The identifier of all parent user groups from which the given member
     *     user or group should be removed, if any.
     *
     * @param {Boolean} [group]
     *     Whether the provided identifier refers to a user group. If false or
     *     omitted, the identifier given is assumed to refer to a user.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     patch operation is successful.
     */
    service.patchUserGroups = function patchUserGroups(
      dataSource,
      identifier,
      addToUserGroups,
      removeFromUserGroups,
      group
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Update parent user groups
      return (
        requestService({
          method: "PATCH",
          url: getUserGroupsResourceURL(dataSource, identifier, group),
          params: httpParameters,
          data: getRelatedObjectPatch(addToUserGroups, removeFromUserGroups),
        })
          // Clear the cache
          .then(function parentUserGroupsChanged() {
            cacheService.users.removeAll();
          })
      );
    };

    /**
     * Makes a request to the REST API to retrieve the identifiers of all
     * users which are members of the given user group, returning a promise
     * that can be used for processing the results of the call.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user group
     *     whose member users should be retrieved. This identifier corresponds
     *     to an AuthenticationProvider within the Guacamole web application.
     *
     * @param {String} identifier
     *     The identifier of the user group to retrieve the member users of.
     *
     * @returns {Promise.<String[]>}
     *     A promise for the HTTP call which will resolve with an array
     *     containing the requested identifiers upon success.
     */
    service.getMemberUsers = function getMemberUsers(dataSource, identifier) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve member users
      return requestService({
        cache: cacheService.users,
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/userGroups/" +
          encodeURIComponent(identifier) +
          "/memberUsers",
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to modify the member users of a given
     * user group, returning a promise that can be used for processing the
     * results of the call.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user group
     *     whose member users should be modified. This identifier corresponds
     *     to an AuthenticationProvider within the Guacamole web application.
     *
     * @param {String} identifier
     *     The identifier of the user group to modify the member users of.
     *
     * @param {String[]} [usersToAdd]
     *     The identifier of all users to add as members of the given user
     *     group, if any.
     *
     * @param {String[]} [usersToRemove]
     *     The identifier of all users to remove from the given user group,
     *     if any.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     patch operation is successful.
     */
    service.patchMemberUsers = function patchMemberUsers(
      dataSource,
      identifier,
      usersToAdd,
      usersToRemove
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Update member users
      return (
        requestService({
          method: "PATCH",
          url:
            "api/session/data/" +
            encodeURIComponent(dataSource) +
            "/userGroups/" +
            encodeURIComponent(identifier) +
            "/memberUsers",
          params: httpParameters,
          data: getRelatedObjectPatch(usersToAdd, usersToRemove),
        })
          // Clear the cache
          .then(function memberUsersChanged() {
            cacheService.users.removeAll();
          })
      );
    };

    /**
     * Makes a request to the REST API to retrieve the identifiers of all
     * user groups which are members of the given user group, returning a
     * promise that can be used for processing the results of the call.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user group
     *     whose member user groups should be retrieved. This identifier
     *     corresponds to an AuthenticationProvider within the Guacamole web
     *     application.
     *
     * @param {String} identifier
     *     The identifier of the user group to retrieve the member user
     *     groups of.
     *
     * @returns {Promise.<String[]>}
     *     A promise for the HTTP call which will resolve with an array
     *     containing the requested identifiers upon success.
     */
    service.getMemberUserGroups = function getMemberUserGroups(
      dataSource,
      identifier
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve member user groups
      return requestService({
        cache: cacheService.users,
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/userGroups/" +
          encodeURIComponent(identifier) +
          "/memberUserGroups",
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to modify the member user groups of a
     * given user group, returning a promise that can be used for processing
     * the results of the call.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user group
     *     whose member user groups should be modified. This identifier
     *     corresponds to an AuthenticationProvider within the Guacamole web
     *     application.
     *
     * @param {String} identifier
     *     The identifier of the user group to modify the member user groups of.
     *
     * @param {String[]} [userGroupsToAdd]
     *     The identifier of all user groups to add as members of the given
     *     user group, if any.
     *
     * @param {String[]} [userGroupsToRemove]
     *     The identifier of all member user groups to remove from the given
     *     user group, if any.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     patch operation is successful.
     */
    service.patchMemberUserGroups = function patchMemberUserGroups(
      dataSource,
      identifier,
      userGroupsToAdd,
      userGroupsToRemove
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Update member user groups
      return (
        requestService({
          method: "PATCH",
          url:
            "api/session/data/" +
            encodeURIComponent(dataSource) +
            "/userGroups/" +
            encodeURIComponent(identifier) +
            "/memberUserGroups",
          params: httpParameters,
          data: getRelatedObjectPatch(userGroupsToAdd, userGroupsToRemove),
        })
          // Clear the cache
          .then(function memberUserGroupsChanged() {
            cacheService.users.removeAll();
          })
      );
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for operating on HTML patches via the REST API.
 */
angular.module("rest").factory("patchService", [
  "$injector",
  function patchService($injector) {
    // Required services
    var requestService = $injector.get("requestService");
    var authenticationService = $injector.get("authenticationService");
    var cacheService = $injector.get("cacheService");

    var service = {};

    /**
     * Makes a request to the REST API to get the list of patches, returning
     * a promise that provides the array of all applicable patches if
     * successful. Each patch is a string of raw HTML with meta information
     * describing the patch operation stored within meta tags.
     *
     * @returns {Promise.<String[]>}
     *     A promise which will resolve with an array of HTML patches upon
     *     success.
     */
    service.getPatches = function getPatches() {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };
      // PATCHED BY IAAS
      return Promise.resolve([]);
      // Retrieve all applicable HTML patches
      return requestService({
        cache: cacheService.patches,
        method: "GET",
        url: "api/patches",
        params: httpParameters,
      });
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for operating on user permissions via the REST API.
 */
angular.module("rest").factory("permissionService", [
  "$injector",
  function permissionService($injector) {
    // Required services
    var requestService = $injector.get("requestService");
    var authenticationService = $injector.get("authenticationService");
    var cacheService = $injector.get("cacheService");

    // Required types
    var PermissionPatch = $injector.get("PermissionPatch");

    var service = {};

    /**
     * Returns the URL for the REST resource most appropriate for accessing
     * the effective permissions of the user having the given username.
     * Effective permissions differ from the permissions returned via
     * getPermissions() in that permissions which are not directly granted to
     * the user are included.
     *
     * It is important to note that a particular data source can authenticate
     * and provide permissions for a user, even if that user does not exist
     * within that data source (and thus cannot be found beneath
     * "api/session/data/{dataSource}/users")
     *
     * NOTE: Unlike getPermissionsResourceURL(),
     * getEffectivePermissionsResourceURL() CANNOT be applied to user groups.
     * Only users have retrievable effective permissions as far as the REST API
     * is concerned.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user whose
     *     permissions should be retrieved. This identifier corresponds to an
     *     AuthenticationProvider within the Guacamole web application.
     *
     * @param {String} username
     *     The username of the user for which the URL of the proper REST
     *     resource should be derived.
     *
     * @returns {String}
     *     The URL for the REST resource representing the user having the given
     *     username.
     */
    var getEffectivePermissionsResourceURL =
      function getEffectivePermissionsResourceURL(dataSource, username) {
        // Create base URL for data source
        var base = "api/session/data/" + encodeURIComponent(dataSource);

        // If the username is that of the current user, do not rely on the
        // user actually existing (they may not). Access their permissions via
        // "self" rather than the collection of defined users.
        if (username === authenticationService.getCurrentUsername())
          return base + "/self/effectivePermissions";

        // Otherwise, the user must exist for their permissions to be
        // accessible. Use the collection of defined users.
        return (
          base +
          "/users/" +
          encodeURIComponent(username) +
          "/effectivePermissions"
        );
      };

    /**
     * Makes a request to the REST API to get the list of effective permissions
     * for a given user, returning a promise that provides an array of
     * @link{Permission} objects if successful. Effective permissions differ
     * from the permissions returned via getPermissions() in that permissions
     * which are not directly granted to the user are included.
     *
     * NOTE: Unlike getPermissions(), getEffectivePermissions() CANNOT be
     * applied to user groups. Only users have retrievable effective
     * permissions as far as the REST API is concerned.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user whose
     *     permissions should be retrieved. This identifier corresponds to an
     *     AuthenticationProvider within the Guacamole web application.
     *
     * @param {String} userID
     *     The ID of the user to retrieve the permissions for.
     *
     * @returns {Promise.<PermissionSet>}
     *     A promise which will resolve with a @link{PermissionSet} upon
     *     success.
     */
    service.getEffectivePermissions = function getEffectivePermissions(
      dataSource,
      userID
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve user permissions
      return requestService({
        cache: cacheService.users,
        method: "GET",
        url: getEffectivePermissionsResourceURL(dataSource, userID),
        params: httpParameters,
      });
    };

    /**
     * Returns the URL for the REST resource most appropriate for accessing
     * the permissions of the user or group having the given identifier. The
     * permissions retrieved differ from effective permissions (those returned
     * by getEffectivePermissions()) in that only permissions which are directly
     * granted to the user or group are included.
     *
     * It is important to note that a particular data source can authenticate
     * and provide permissions for a user, even if that user does not exist
     * within that data source (and thus cannot be found beneath
     * "api/session/data/{dataSource}/users")
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user whose
     *     permissions should be retrieved. This identifier corresponds to an
     *     AuthenticationProvider within the Guacamole web application.
     *
     * @param {String} identifier
     *     The identifier of the user or group for which the URL of the proper
     *     REST resource should be derived.
     *
     * @param {Boolean} [group]
     *     Whether the provided identifier refers to a user group. If false or
     *     omitted, the identifier given is assumed to refer to a user.
     *
     * @returns {String}
     *     The URL for the REST resource representing the user or group having
     *     the given identifier.
     */
    var getPermissionsResourceURL = function getPermissionsResourceURL(
      dataSource,
      identifier,
      group
    ) {
      // Create base URL for data source
      var base = "api/session/data/" + encodeURIComponent(dataSource);

      // Access group permissions directly (there is no "self" for user groups
      // as there is for users)
      if (group)
        return (
          base +
          "/userGroups/" +
          encodeURIComponent(identifier) +
          "/permissions"
        );

      // If the username is that of the current user, do not rely on the
      // user actually existing (they may not). Access their permissions via
      // "self" rather than the collection of defined users.
      if (identifier === authenticationService.getCurrentUsername())
        return base + "/self/permissions";

      // Otherwise, the user must exist for their permissions to be
      // accessible. Use the collection of defined users.
      return base + "/users/" + encodeURIComponent(identifier) + "/permissions";
    };

    /**
     * Makes a request to the REST API to get the list of permissions for a
     * given user or user group, returning a promise that provides an array of
     * @link{Permission} objects if successful. The permissions retrieved
     * differ from effective permissions (those returned by
     * getEffectivePermissions()) in that both users and groups may be queried,
     * and only permissions which are directly granted to the user or group are
     * included.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user or group
     *     whose permissions should be retrieved. This identifier corresponds to
     *     an AuthenticationProvider within the Guacamole web application.
     *
     * @param {String} identifier
     *     The identifier of the user or group to retrieve the permissions for.
     *
     * @param {Boolean} [group]
     *     Whether the provided identifier refers to a user group. If false or
     *     omitted, the identifier given is assumed to refer to a user.
     *
     * @returns {Promise.<PermissionSet>}
     *     A promise which will resolve with a @link{PermissionSet} upon
     *     success.
     */
    service.getPermissions = function getPermissions(
      dataSource,
      identifier,
      group
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };
      return Promise.resolve({
        connectionPermissions: { ROOT: ["READ"] },
        connectionGroupPermissions: { DEFAULT: ["READ"] },
        sharingProfilePermissions: {},
        activeConnectionPermissions: {},
        userPermissions: {},
        userGroupPermissions: {},
        systemPermissions: [],
      });
      // Retrieve user/group permissions
      return requestService({
        cache: cacheService.users,
        method: "GET",
        url: getPermissionsResourceURL(dataSource, identifier, group),
        params: httpParameters,
      });
    };

    /**
     * Adds patches for modifying the permissions associated with specific
     * objects to the given array of patches.
     *
     * @param {PermissionPatch[]} patch
     *     The array of patches to add new patches to.
     *
     * @param {String} operation
     *     The operation to specify within each of the patches. Valid values
     *     for this are defined within PermissionPatch.Operation.
     *
     * @param {String} path
     *     The path of the permissions being patched. The path is a JSON path
     *     describing the position of the permissions within a PermissionSet.
     *
     * @param {Object.<String, String[]>} permissions
     *     A map of object identifiers to arrays of permission type strings,
     *     where each type string is a value from
     *     PermissionSet.ObjectPermissionType.
     */
    var addObjectPatchOperations = function addObjectPatchOperations(
      patch,
      operation,
      path,
      permissions
    ) {
      // Add object permission operations to patch
      for (var identifier in permissions) {
        permissions[identifier].forEach(function addObjectPatch(type) {
          patch.push({
            op: operation,
            path: path + "/" + identifier,
            value: type,
          });
        });
      }
    };

    /**
     * Adds patches for modifying any permission that can be stored within a
     * @link{PermissionSet}.
     *
     * @param {PermissionPatch[]} patch
     *     The array of patches to add new patches to.
     *
     * @param {String} operation
     *     The operation to specify within each of the patches. Valid values
     *     for this are defined within PermissionPatch.Operation.
     *
     * @param {PermissionSet} permissions
     *     The set of permissions for which patches should be added.
     */
    var addPatchOperations = function addPatchOperations(
      patch,
      operation,
      permissions
    ) {
      // Add connection permission operations to patch
      addObjectPatchOperations(
        patch,
        operation,
        "/connectionPermissions",
        permissions.connectionPermissions
      );

      // Add connection group permission operations to patch
      addObjectPatchOperations(
        patch,
        operation,
        "/connectionGroupPermissions",
        permissions.connectionGroupPermissions
      );

      // Add sharing profile permission operations to patch
      addObjectPatchOperations(
        patch,
        operation,
        "/sharingProfilePermissions",
        permissions.sharingProfilePermissions
      );

      // Add active connection permission operations to patch
      addObjectPatchOperations(
        patch,
        operation,
        "/activeConnectionPermissions",
        permissions.activeConnectionPermissions
      );

      // Add user permission operations to patch
      addObjectPatchOperations(
        patch,
        operation,
        "/userPermissions",
        permissions.userPermissions
      );

      // Add user group permission operations to patch
      addObjectPatchOperations(
        patch,
        operation,
        "/userGroupPermissions",
        permissions.userGroupPermissions
      );

      // Add system operations to patch
      permissions.systemPermissions.forEach(function addSystemPatch(type) {
        patch.push({
          op: operation,
          path: "/systemPermissions",
          value: type,
        });
      });
    };

    /**
     * Makes a request to the REST API to modify the permissions for a given
     * user or group, returning a promise that can be used for processing the
     * results of the call. This request affects only the permissions directly
     * granted to the user or group, and may not affect permissions inherited
     * through other means (effective permissions).
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user or group
     *     whose permissions should be modified. This identifier corresponds to
     *     an AuthenticationProvider within the Guacamole web application.
     *
     * @param {String} identifier
     *     The identifier of the user or group to modify the permissions of.
     *
     * @param {PermissionSet} [permissionsToAdd]
     *     The set of permissions to add, if any.
     *
     * @param {PermissionSet} [permissionsToRemove]
     *     The set of permissions to remove, if any.
     *
     * @param {Boolean} [group]
     *     Whether the provided identifier refers to a user group. If false or
     *     omitted, the identifier given is assumed to refer to a user.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     patch operation is successful.
     */
    service.patchPermissions = function patchPermissions(
      dataSource,
      identifier,
      permissionsToAdd,
      permissionsToRemove,
      group
    ) {
      var permissionPatch = [];

      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Add all the add operations to the patch
      addPatchOperations(
        permissionPatch,
        PermissionPatch.Operation.ADD,
        permissionsToAdd
      );

      // Add all the remove operations to the patch
      addPatchOperations(
        permissionPatch,
        PermissionPatch.Operation.REMOVE,
        permissionsToRemove
      );

      // Patch user/group permissions
      return (
        requestService({
          method: "PATCH",
          url: getPermissionsResourceURL(dataSource, identifier, group),
          params: httpParameters,
          data: permissionPatch,
        })
          // Clear the cache
          .then(function permissionsPatched() {
            cacheService.users.removeAll();
          })
      );
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for converting $http promises that pass the entire response into
 * promises that pass only the data from that response.
 */
angular.module("rest").factory("requestService", [
  "$injector",
  function requestService($injector) {
    // Required services
    var $http = $injector.get("$http");
    var $log = $injector.get("$log");
    var $rootScope = $injector.get("$rootScope");

    // Required types
    var Error = $injector.get("Error");

    /**
     * Given a configuration object formatted for the $http service, returns
     * a promise that will resolve or reject with the data from the HTTP
     * response. If the promise is rejected due to the HTTP response indicating
     * failure, the promise will be rejected strictly with an instance of an
     * @link{Error} object.
     *
     * @param {Object} object
     *   Configuration object for $http service call.
     *
     * @returns {Promise.<Object>}
     *   A promise that will resolve with the data from the HTTP response for
     *   the underlying $http call if successful, or reject with an @link{Error}
     *   describing the failure.
     */
    var service = function wrapHttpServiceCall(object) {
      return $http(object).then(
        function success(response) {
          return response.data;
        },
        function failure(response) {
          // Wrap true error responses from $http within REST Error objects
          if (response.data) throw new Error(response.data);

          // The value provided is not actually a response object from
          // the $http service
          throw response;
        }
      );
    };

    /**
     * Creates a promise error callback which invokes the given callback only
     * if the promise was rejected with a REST @link{Error} object. If the
     * promise is rejected without an @link{Error} object, such as when a
     * JavaScript error occurs within a callback earlier in the promise chain,
     * the rejection is logged without invoking the given callback.
     *
     * @param {Function} callback
     *     The callback to invoke if the promise is rejected with an
     *     @link{Error} object.
     *
     * @returns {Function}
     *     A function which can be provided as the error callback for a
     *     promise.
     */
    service.createErrorCallback = function createErrorCallback(callback) {
      return function generatedErrorCallback(error) {
        // Invoke given callback ONLY if due to a legitimate REST error
        if (error instanceof Error) return callback(error);

        // Log all other errors
        $log.error(error);
      };
    };

    /**
     * Creates a promise error callback which resolves the promise with the
     * given default value only if the @link{Error} in the original rejection
     * is a NOT_FOUND error. All other errors are passed through and must be
     * handled as yet more rejections.
     *
     * @param {*} value
     *     The default value to use to resolve the promise if the promise is
     *     rejected with a NOT_FOUND error.
     *
     * @returns {Function}
     *     A function which can be provided as the error callback for a
     *     promise.
     */
    service.defaultValue = function defaultValue(value) {
      return service.createErrorCallback(function resolveIfNotFound(error) {
        // Return default value only if not found
        if (error.type === Error.Type.NOT_FOUND) return value;

        // Reject promise with original error otherwise
        throw error;
      });
    };

    /**
     * Promise error callback which ignores all rejections due to REST errors,
     * but logs all other rejections, such as those due to JavaScript errors.
     * This callback should be used in favor of angular.noop in cases where
     * a REST response is being handled but REST errors should be ignored.
     *
     * @constant
     * @type Function
     */
    service.IGNORE = service.createErrorCallback(angular.noop);

    /**
     * Promise error callback which logs all rejections due to REST errors as
     * warnings to the browser console, and logs all other rejections as
     * errors. This callback should be used in favor of angular.noop or
     * @link{IGNORE} if REST errors are simply not expected.
     *
     * @constant
     * @type Function
     */
    service.WARN = service.createErrorCallback(function warnRequestFailed(
      error
    ) {
      $log.warn(error.type, error.message || error.translatableMessage);
    });

    /**
     * Promise error callback which replaces the content of the page with a
     * generic error message warning that the page could not be displayed. All
     * rejections are logged to the browser console as errors. This callback
     * should be used in favor of @link{WARN} if REST errors will result in the
     * page being unusable.
     *
     * @constant
     * @type Function
     */
    service.DIE = service.createErrorCallback(function fatalPageError(error) {
      $rootScope.$broadcast("guacFatalPageError", error);
      $log.error(error.type, error.message || error.translatableMessage);
    });

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for operating on metadata via the REST API.
 */
angular.module("rest").factory("schemaService", [
  "$injector",
  function schemaService($injector) {
    // Required services
    var requestService = $injector.get("requestService");
    var authenticationService = $injector.get("authenticationService");
    var cacheService = $injector.get("cacheService");

    var service = {};

    /**
     * Makes a request to the REST API to get the list of available attributes
     * for user objects, returning a promise that provides an array of
     * @link{Form} objects if successful. Each element of the array describes
     * a logical grouping of possible attributes.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the users whose
     *     available attributes are to be retrieved. This identifier
     *     corresponds to an AuthenticationProvider within the Guacamole web
     *     application.
     *
     * @returns {Promise.<Form[]>}
     *     A promise which will resolve with an array of @link{Form}
     *     objects, where each @link{Form} describes a logical grouping of
     *     possible attributes.
     */
    service.getUserAttributes = function getUserAttributes(dataSource) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve available user attributes
      return requestService({
        cache: cacheService.schema,
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/schema/userAttributes",
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to get the list of available attributes
     * for user group objects, returning a promise that provides an array of
     * @link{Form} objects if successful. Each element of the array describes
     * a logical grouping of possible attributes.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user groups
     *     whose available attributes are to be retrieved. This identifier
     *     corresponds to an AuthenticationProvider within the Guacamole web
     *     application.
     *
     * @returns {Promise.<Form[]>}
     *     A promise which will resolve with an array of @link{Form}
     *     objects, where each @link{Form} describes a logical grouping of
     *     possible attributes.
     */
    service.getUserGroupAttributes = function getUserGroupAttributes(
      dataSource
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve available user group attributes
      return requestService({
        cache: cacheService.schema,
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/schema/userGroupAttributes",
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to get the list of available attributes
     * for connection objects, returning a promise that provides an array of
     * @link{Form} objects if successful. Each element of the array describes
     * a logical grouping of possible attributes.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the connections
     *     whose available attributes are to be retrieved. This identifier
     *     corresponds to an AuthenticationProvider within the Guacamole web
     *     application.
     *
     * @returns {Promise.<Form[]>}
     *     A promise which will resolve with an array of @link{Form}
     *     objects, where each @link{Form} describes a logical grouping of
     *     possible attributes.
     */
    service.getConnectionAttributes = function getConnectionAttributes(
      dataSource
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve available connection attributes
      return requestService({
        cache: cacheService.schema,
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/schema/connectionAttributes",
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to get the list of available attributes
     * for sharing profile objects, returning a promise that provides an array
     * of @link{Form} objects if successful. Each element of the array describes
     * a logical grouping of possible attributes.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the sharing
     *     profiles whose available attributes are to be retrieved. This
     *     identifier corresponds to an AuthenticationProvider within the
     *     Guacamole web application.
     *
     * @returns {Promise.<Form[]>}
     *     A promise which will resolve with an array of @link{Form}
     *     objects, where each @link{Form} describes a logical grouping of
     *     possible attributes.
     */
    service.getSharingProfileAttributes = function getSharingProfileAttributes(
      dataSource
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve available sharing profile attributes
      return requestService({
        cache: cacheService.schema,
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/schema/sharingProfileAttributes",
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to get the list of available attributes
     * for connection group objects, returning a promise that provides an array
     * of @link{Form} objects if successful. Each element of the array
     * a logical grouping of possible attributes.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the connection
     *     groups whose available attributes are to be retrieved. This
     *     identifier corresponds to an AuthenticationProvider within the
     *     Guacamole web application.
     *
     * @returns {Promise.<Form[]>}
     *     A promise which will resolve with an array of @link{Form}
     *     objects, where each @link{Form} describes a logical grouping of
     *     possible attributes.
     */
    service.getConnectionGroupAttributes =
      function getConnectionGroupAttributes(dataSource) {
        // Build HTTP parameters set
        var httpParameters = {
          token: authenticationService.getCurrentToken(),
        };

        // Retrieve available connection group attributes
        return requestService({
          cache: cacheService.schema,
          method: "GET",
          url:
            "api/session/data/" +
            encodeURIComponent(dataSource) +
            "/schema/connectionGroupAttributes",
          params: httpParameters,
        });
      };

    /**
     * Makes a request to the REST API to get the list of protocols, returning
     * a promise that provides a map of @link{Protocol} objects by protocol
     * name if successful.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source defining available
     *     protocols. This identifier corresponds to an AuthenticationProvider
     *     within the Guacamole web application.
     *
     * @returns {Promise.<Object.<String, Protocol>>}
     *     A promise which will resolve with a map of @link{Protocol}
     *     objects by protocol name upon success.
     */
    service.getProtocols = function getProtocols(dataSource) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve available protocols
      return requestService({
        cache: cacheService.schema,
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/schema/protocols",
        params: httpParameters,
      });
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for operating on sharing profiles via the REST API.
 */
angular.module("rest").factory("sharingProfileService", [
  "$injector",
  function sharingProfileService($injector) {
    // Required services
    var requestService = $injector.get("requestService");
    var authenticationService = $injector.get("authenticationService");
    var cacheService = $injector.get("cacheService");

    var service = {};

    /**
     * Makes a request to the REST API to get a single sharing profile,
     * returning a promise that provides the corresponding @link{SharingProfile}
     * if successful.
     *
     * @param {String} id The ID of the sharing profile.
     *
     * @returns {Promise.<SharingProfile>}
     *     A promise which will resolve with a @link{SharingProfile} upon
     *     success.
     *
     * @example
     *
     * sharingProfileService.getSharingProfile('mySharingProfile').then(function(sharingProfile) {
     *     // Do something with the sharing profile
     * });
     */
    service.getSharingProfile = function getSharingProfile(dataSource, id) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve sharing profile
      return requestService({
        cache: cacheService.connections,
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/sharingProfiles/" +
          encodeURIComponent(id),
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to get the parameters of a single
     * sharing profile, returning a promise that provides the corresponding
     * map of parameter name/value pairs if successful.
     *
     * @param {String} id
     *     The identifier of the sharing profile.
     *
     * @returns {Promise.<Object.<String, String>>}
     *     A promise which will resolve with an map of parameter name/value
     *     pairs upon success.
     */
    service.getSharingProfileParameters = function getSharingProfileParameters(
      dataSource,
      id
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve sharing profile parameters
      return requestService({
        cache: cacheService.connections,
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/sharingProfiles/" +
          encodeURIComponent(id) +
          "/parameters",
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to save a sharing profile, returning a
     * promise that can be used for processing the results of the call. If the
     * sharing profile is new, and thus does not yet have an associate
     * identifier, the identifier will be automatically set in the provided
     * sharing profile upon success.
     *
     * @param {SharingProfile} sharingProfile
     *     The sharing profile to update.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     save operation is successful.
     */
    service.saveSharingProfile = function saveSharingProfile(
      dataSource,
      sharingProfile
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // If sharing profile is new, add it and set the identifier automatically
      if (!sharingProfile.identifier) {
        return (
          requestService({
            method: "POST",
            url:
              "api/session/data/" +
              encodeURIComponent(dataSource) +
              "/sharingProfiles",
            params: httpParameters,
            data: sharingProfile,
          })
            // Set the identifier on the new sharing profile and clear the cache
            .then(function sharingProfileCreated(newSharingProfile) {
              sharingProfile.identifier = newSharingProfile.identifier;
              cacheService.connections.removeAll();

              // Clear users cache to force reload of permissions for this
              // newly created sharing profile
              cacheService.users.removeAll();
            })
        );
      }

      // Otherwise, update the existing sharing profile
      else {
        return (
          requestService({
            method: "PUT",
            url:
              "api/session/data/" +
              encodeURIComponent(dataSource) +
              "/sharingProfiles/" +
              encodeURIComponent(sharingProfile.identifier),
            params: httpParameters,
            data: sharingProfile,
          })
            // Clear the cache
            .then(function sharingProfileUpdated() {
              cacheService.connections.removeAll();

              // Clear users cache to force reload of permissions for this
              // newly updated sharing profile
              cacheService.users.removeAll();
            })
        );
      }
    };

    /**
     * Makes a request to the REST API to delete a sharing profile,
     * returning a promise that can be used for processing the results of the call.
     *
     * @param {SharingProfile} sharingProfile
     *     The sharing profile to delete.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     delete operation is successful.
     */
    service.deleteSharingProfile = function deleteSharingProfile(
      dataSource,
      sharingProfile
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Delete sharing profile
      return (
        requestService({
          method: "DELETE",
          url:
            "api/session/data/" +
            encodeURIComponent(dataSource) +
            "/sharingProfiles/" +
            encodeURIComponent(sharingProfile.identifier),
          params: httpParameters,
        })
          // Clear the cache
          .then(function sharingProfileDeleted() {
            cacheService.connections.removeAll();
          })
      );
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for operating on the tunnels of in-progress connections (and their
 * underlying objects) via the REST API.
 */
angular.module("rest").factory("tunnelService", [
  "$injector",
  function tunnelService($injector) {
    // Required types
    var Error = $injector.get("Error");

    // Required services
    var $q = $injector.get("$q");
    var $window = $injector.get("$window");
    var authenticationService = $injector.get("authenticationService");
    var requestService = $injector.get("requestService");

    var service = {};

    /**
     * Reference to the window.document object.
     *
     * @private
     * @type HTMLDocument
     */
    var document = $window.document;

    /**
     * The number of milliseconds to wait after a stream download has completed
     * before cleaning up related DOM resources, if the browser does not
     * otherwise notify us that cleanup is safe.
     *
     * @private
     * @constant
     * @type Number
     */
    var DOWNLOAD_CLEANUP_WAIT = 5000;

    /**
     * Makes a request to the REST API to get the list of all tunnels
     * associated with in-progress connections, returning a promise that
     * provides an array of their UUIDs (strings) if successful.
     *
     * @returns {Promise.<String[]>>}
     *     A promise which will resolve with an array of UUID strings, uniquely
     *     identifying each active tunnel.
     */
    service.getTunnels = function getTunnels() {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve tunnels
      return requestService({
        method: "GET",
        url: "api/session/tunnels",
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to retrieve the underlying protocol of
     * the connection associated with a particular tunnel, returning a promise
     * that provides a @link{Protocol} object if successful.
     *
     * @param {String} tunnel
     *     The UUID of the tunnel associated with the Guacamole connection
     *     whose underlying protocol is being retrieved.
     *
     * @returns {Promise.<Protocol>}
     *     A promise which will resolve with a @link{Protocol} object upon
     *     success.
     */
    service.getProtocol = function getProtocol(tunnel) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve the protocol details of the specified tunnel
      return requestService({
        method: "GET",
        url: "api/session/tunnels/" + encodeURIComponent(tunnel) + "/protocol",
        params: httpParameters,
      });
    };

    /**
     * Retrieves the set of sharing profiles that the current user can use to
     * share the active connection of the given tunnel.
     *
     * @param {String} tunnel
     *     The UUID of the tunnel associated with the Guacamole connection
     *     whose sharing profiles are being retrieved.
     *
     * @returns {Promise.<Object.<String, SharingProfile>>}
     *     A promise which will resolve with a map of @link{SharingProfile}
     *     objects where each key is the identifier of the corresponding
     *     sharing profile.
     */
    service.getSharingProfiles = function getSharingProfiles(tunnel) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve all associated sharing profiles
      return requestService({
        method: "GET",
        url:
          "api/session/tunnels/" +
          encodeURIComponent(tunnel) +
          "/activeConnection/connection/sharingProfiles",
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to generate credentials which have
     * access strictly to the active connection associated with the given
     * tunnel, using the restrictions defined by the given sharing profile,
     * returning a promise that provides the resulting @link{UserCredentials}
     * object if successful.
     *
     * @param {String} tunnel
     *     The UUID of the tunnel associated with the Guacamole connection
     *     being shared.
     *
     * @param {String} sharingProfile
     *     The identifier of the connection object dictating the
     *     semantics/restrictions which apply to the shared session.
     *
     * @returns {Promise.<UserCredentials>}
     *     A promise which will resolve with a @link{UserCredentials} object
     *     upon success.
     */
    service.getSharingCredentials = function getSharingCredentials(
      tunnel,
      sharingProfile
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Generate sharing credentials
      return requestService({
        method: "GET",
        url:
          "api/session/tunnels/" +
          encodeURIComponent(tunnel) +
          "/activeConnection/sharingCredentials/" +
          encodeURIComponent(sharingProfile),
        params: httpParameters,
      });
    };

    /**
     * Sanitize a filename, replacing all URL path seperators with safe
     * characters.
     *
     * @param {String} filename
     *     An unsanitized filename that may need cleanup.
     *
     * @returns {String}
     *     The sanitized filename.
     */
    var sanitizeFilename = function sanitizeFilename(filename) {
      return filename.replace(/[\\\/]+/g, "_");
    };

    /**
     * Makes a request to the REST API to retrieve the contents of a stream
     * which has been created within the active Guacamole connection associated
     * with the given tunnel. The contents of the stream will automatically be
     * downloaded by the browser.
     *
     * WARNING: Like Guacamole's various reader implementations, this function
     * relies on assigning an "onend" handler to the stream object for the sake
     * of cleaning up resources after the stream closes. If the "onend" handler
     * is overwritten after this function returns, resources may not be
     * properly cleaned up.
     *
     * @param {String} tunnel
     *     The UUID of the tunnel associated with the Guacamole connection
     *     whose stream should be downloaded as a file.
     *
     * @param {Guacamole.InputStream} stream
     *     The stream whose contents should be downloaded.
     *
     * @param {String} mimetype
     *     The mimetype of the stream being downloaded. This is currently
     *     ignored, with the download forced by using
     *     "application/octet-stream".
     *
     * @param {String} filename
     *     The filename that should be given to the downloaded file.
     */
    service.downloadStream = function downloadStream(
      tunnel,
      stream,
      mimetype,
      filename
    ) {
      // Work-around for IE missing window.location.origin
      if (!$window.location.origin)
        var streamOrigin =
          $window.location.protocol +
          "//" +
          $window.location.hostname +
          ($window.location.port ? ":" + $window.location.port : "");
      else var streamOrigin = $window.location.origin;

      // Build download URL
      var url =
        streamOrigin +
        $window.location.pathname +
        "api/session/tunnels/" +
        encodeURIComponent(tunnel) +
        "/streams/" +
        encodeURIComponent(stream.index) +
        "/" +
        encodeURIComponent(sanitizeFilename(filename)) +
        "?token=" +
        encodeURIComponent(authenticationService.getCurrentToken());

      // Create temporary hidden iframe to facilitate download
      var iframe = document.createElement("iframe");
      iframe.style.position = "fixed";
      iframe.style.border = "none";
      iframe.style.width = "1px";
      iframe.style.height = "1px";
      iframe.style.left = "-1px";
      iframe.style.top = "-1px";

      // The iframe MUST be part of the DOM for the download to occur
      document.body.appendChild(iframe);

      // Automatically remove iframe from DOM when download completes, if
      // browser supports tracking of iframe downloads via the "load" event
      iframe.onload = function downloadComplete() {
        document.body.removeChild(iframe);
      };

      // Acknowledge (and ignore) any received blobs
      stream.onblob = function acknowledgeData() {
        stream.sendAck("OK", Guacamole.Status.Code.SUCCESS);
      };

      // Automatically remove iframe from DOM a few seconds after the stream
      // ends, in the browser does NOT fire the "load" event for downloads
      stream.onend = function downloadComplete() {
        $window.setTimeout(function cleanupIframe() {
          if (iframe.parentElement) {
            document.body.removeChild(iframe);
          }
        }, DOWNLOAD_CLEANUP_WAIT);
      };

      // Begin download
      iframe.src = url;
    };

    /**
     * Makes a request to the REST API to send the contents of the given file
     * along a stream which has been created within the active Guacamole
     * connection associated with the given tunnel. The contents of the file
     * will automatically be split into individual "blob" instructions, as if
     * sent by the connected Guacamole client.
     *
     * @param {String} tunnel
     *     The UUID of the tunnel associated with the Guacamole connection
     *     whose stream should receive the given file.
     *
     * @param {Guacamole.OutputStream} stream
     *     The stream that should receive the given file.
     *
     * @param {File} file
     *     The file that should be sent along the given stream.
     *
     * @param {Function} [progressCallback]
     *     An optional callback which, if provided, will be invoked as the
     *     file upload progresses. The current position within the file, in
     *     bytes, will be provided to the callback as the sole argument.
     *
     * @return {Promise}
     *     A promise which resolves when the upload has completed, and is
     *     rejected with an Error if the upload fails. The Guacamole protocol
     *     status code describing the failure will be included in the Error if
     *     available. If the status code is available, the type of the Error
     *     will be STREAM_ERROR.
     */
    service.uploadToStream = function uploadToStream(
      tunnel,
      stream,
      file,
      progressCallback
    ) {
      var deferred = $q.defer();

      // Work-around for IE missing window.location.origin
      if (!$window.location.origin)
        var streamOrigin =
          $window.location.protocol +
          "//" +
          $window.location.hostname +
          ($window.location.port ? ":" + $window.location.port : "");
      else var streamOrigin = $window.location.origin;

      // Build upload URL
      var url =
        streamOrigin +
        $window.location.pathname +
        "api/session/tunnels/" +
        encodeURIComponent(tunnel) +
        "/streams/" +
        encodeURIComponent(stream.index) +
        "/" +
        encodeURIComponent(sanitizeFilename(file.name)) +
        "?token=" +
        encodeURIComponent(authenticationService.getCurrentToken());

      var xhr = new XMLHttpRequest();

      // Invoke provided callback if upload tracking is supported
      if (progressCallback && xhr.upload) {
        xhr.upload.addEventListener("progress", function updateProgress(e) {
          progressCallback(e.loaded);
        });
      }

      // Resolve/reject promise once upload has stopped
      xhr.onreadystatechange = function uploadStatusChanged() {
        // Ignore state changes prior to completion
        if (xhr.readyState !== 4) return;

        // Resolve if HTTP status code indicates success
        if (xhr.status >= 200 && xhr.status < 300) deferred.resolve();
        // Parse and reject with resulting JSON error
        else if (xhr.getResponseHeader("Content-Type") === "application/json")
          deferred.reject(angular.fromJson(xhr.responseText));
        // Warn of lack of permission of a proxy rejects the upload
        else if (xhr.status >= 400 && xhr.status < 500)
          deferred.reject(
            new Error({
              type: Error.Type.STREAM_ERROR,
              statusCode: Guacamole.Status.Code.CLIENT_FORBIDDEN,
              message: "HTTP " + xhr.status,
            })
          );
        // Assume internal error for all other cases
        else
          deferred.reject(
            new Error({
              type: Error.Type.STREAM_ERROR,
              statusCode: Guacamole.Status.Code.INTERNAL_ERROR,
              message: "HTTP " + xhr.status,
            })
          );
      };

      // Perform upload
      xhr.open("POST", url, true);
      xhr.send(file);

      return deferred.promise;
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for operating on user groups via the REST API.
 */
angular.module("rest").factory("userGroupService", [
  "$injector",
  function userGroupService($injector) {
    // Required services
    var requestService = $injector.get("requestService");
    var authenticationService = $injector.get("authenticationService");
    var cacheService = $injector.get("cacheService");

    var service = {};

    /**
     * Makes a request to the REST API to get the list of user groups,
     * returning a promise that provides an array of @link{UserGroup} objects if
     * successful.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user groups
     *     to be retrieved. This identifier corresponds to an
     *     AuthenticationProvider within the Guacamole web application.
     *
     * @param {String[]} [permissionTypes]
     *     The set of permissions to filter with. A user group must have one or
     *     more of these permissions for a user group to appear in the result.
     *     If null, no filtering will be performed. Valid values are listed
     *     within PermissionSet.ObjectType.
     *
     * @returns {Promise.<Object.<String, UserGroup>>}
     *     A promise which will resolve with a map of @link{UserGroup} objects
     *     where each key is the identifier of the corresponding user group.
     */
    service.getUserGroups = function getUserGroups(
      dataSource,
      permissionTypes
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Add permission filter if specified
      if (permissionTypes) httpParameters.permission = permissionTypes;

      // Retrieve user groups
      return requestService({
        cache: cacheService.users,
        method: "GET",
        url:
          "api/session/data/" + encodeURIComponent(dataSource) + "/userGroups",
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to get the user group having the given
     * identifier, returning a promise that provides the corresponding
     * @link{UserGroup} if successful.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user group to
     *     be retrieved. This identifier corresponds to an
     *     AuthenticationProvider within the Guacamole web application.
     *
     * @param {String} identifier
     *     The identifier of the user group to retrieve.
     *
     * @returns {Promise.<UserGroup>}
     *     A promise which will resolve with a @link{UserGroup} upon success.
     */
    service.getUserGroup = function getUserGroup(dataSource, identifier) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve user group
      return requestService({
        cache: cacheService.users,
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/userGroups/" +
          encodeURIComponent(identifier),
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to delete a user group, returning a
     * promise that can be used for processing the results of the call.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user group to
     *     be deleted. This identifier corresponds to an AuthenticationProvider
     *     within the Guacamole web application.
     *
     * @param {UserGroup} userGroup
     *     The user group to delete.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     delete operation is successful.
     */
    service.deleteUserGroup = function deleteUserGroup(dataSource, userGroup) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Delete user group
      return (
        requestService({
          method: "DELETE",
          url:
            "api/session/data/" +
            encodeURIComponent(dataSource) +
            "/userGroups/" +
            encodeURIComponent(userGroup.identifier),
          params: httpParameters,
        })
          // Clear the cache
          .then(function userGroupDeleted() {
            cacheService.users.removeAll();
          })
      );
    };

    /**
     * Makes a request to the REST API to create a user group, returning a promise
     * that can be used for processing the results of the call.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source in which the user group
     *     should be created. This identifier corresponds to an
     *     AuthenticationProvider within the Guacamole web application.
     *
     * @param {UserGroup} userGroup
     *     The user group to create.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     create operation is successful.
     */
    service.createUserGroup = function createUserGroup(dataSource, userGroup) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Create user group
      return (
        requestService({
          method: "POST",
          url:
            "api/session/data/" +
            encodeURIComponent(dataSource) +
            "/userGroups",
          params: httpParameters,
          data: userGroup,
        })
          // Clear the cache
          .then(function userGroupCreated() {
            cacheService.users.removeAll();
          })
      );
    };

    /**
     * Makes a request to the REST API to save a user group, returning a
     * promise that can be used for processing the results of the call.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user group to
     *     be updated. This identifier corresponds to an AuthenticationProvider
     *     within the Guacamole web application.
     *
     * @param {UserGroup} userGroup
     *     The user group to update.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     save operation is successful.
     */
    service.saveUserGroup = function saveUserGroup(dataSource, userGroup) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Update user group
      return (
        requestService({
          method: "PUT",
          url:
            "api/session/data/" +
            encodeURIComponent(dataSource) +
            "/userGroups/" +
            encodeURIComponent(userGroup.identifier),
          params: httpParameters,
          data: userGroup,
        })
          // Clear the cache
          .then(function userGroupUpdated() {
            cacheService.users.removeAll();
          })
      );
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for operating on users via the REST API.
 */
angular.module("rest").factory("userService", [
  "$injector",
  function userService($injector) {
    // Required services
    var requestService = $injector.get("requestService");
    var authenticationService = $injector.get("authenticationService");
    var cacheService = $injector.get("cacheService");

    // Get required types
    var UserPasswordUpdate = $injector.get("UserPasswordUpdate");

    var service = {};

    /**
     * Makes a request to the REST API to get the list of users,
     * returning a promise that provides an array of @link{User} objects if
     * successful.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the users to be
     *     retrieved. This identifier corresponds to an AuthenticationProvider
     *     within the Guacamole web application.
     *
     * @param {String[]} [permissionTypes]
     *     The set of permissions to filter with. A user must have one or more
     *     of these permissions for a user to appear in the result.
     *     If null, no filtering will be performed. Valid values are listed
     *     within PermissionSet.ObjectType.
     *
     * @returns {Promise.<Object.<String, User>>}
     *     A promise which will resolve with a map of @link{User} objects
     *     where each key is the identifier (username) of the corresponding
     *     user.
     */
    service.getUsers = function getUsers(dataSource, permissionTypes) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Add permission filter if specified
      if (permissionTypes) httpParameters.permission = permissionTypes;
      // Retrieve users
      return requestService({
        cache: cacheService.users,
        method: "GET",
        url: "api/session/data/" + encodeURIComponent(dataSource) + "/users",
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to get the user having the given
     * username, returning a promise that provides the corresponding
     * @link{User} if successful.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user to be
     *     retrieved. This identifier corresponds to an AuthenticationProvider
     *     within the Guacamole web application.
     *
     * @param {String} username
     *     The username of the user to retrieve.
     *
     * @returns {Promise.<User>}
     *     A promise which will resolve with a @link{User} upon success.
     */
    service.getUser = function getUser(dataSource, username) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Retrieve user
      return requestService({
        cache: cacheService.users,
        method: "GET",
        url:
          "api/session/data/" +
          encodeURIComponent(dataSource) +
          "/users/" +
          encodeURIComponent(username),
        params: httpParameters,
      });
    };

    /**
     * Makes a request to the REST API to delete a user, returning a promise
     * that can be used for processing the results of the call.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user to be
     *     deleted. This identifier corresponds to an AuthenticationProvider
     *     within the Guacamole web application.
     *
     * @param {User} user
     *     The user to delete.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     delete operation is successful.
     */
    service.deleteUser = function deleteUser(dataSource, user) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Delete user
      return (
        requestService({
          method: "DELETE",
          url:
            "api/session/data/" +
            encodeURIComponent(dataSource) +
            "/users/" +
            encodeURIComponent(user.username),
          params: httpParameters,
        })
          // Clear the cache
          .then(function userDeleted() {
            cacheService.users.removeAll();
          })
      );
    };

    /**
     * Makes a request to the REST API to create a user, returning a promise
     * that can be used for processing the results of the call.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source in which the user should be
     *     created. This identifier corresponds to an AuthenticationProvider
     *     within the Guacamole web application.
     *
     * @param {User} user
     *     The user to create.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     create operation is successful.
     */
    service.createUser = function createUser(dataSource, user) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Create user
      return (
        requestService({
          method: "POST",
          url: "api/session/data/" + encodeURIComponent(dataSource) + "/users",
          params: httpParameters,
          data: user,
        })
          // Clear the cache
          .then(function userCreated() {
            cacheService.users.removeAll();
          })
      );
    };

    /**
     * Makes a request to the REST API to save a user, returning a promise that
     * can be used for processing the results of the call.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user to be
     *     updated. This identifier corresponds to an AuthenticationProvider
     *     within the Guacamole web application.
     *
     * @param {User} user
     *     The user to update.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     save operation is successful.
     */
    service.saveUser = function saveUser(dataSource, user) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Update user
      return (
        requestService({
          method: "PUT",
          url:
            "api/session/data/" +
            encodeURIComponent(dataSource) +
            "/users/" +
            encodeURIComponent(user.username),
          params: httpParameters,
          data: user,
        })
          // Clear the cache
          .then(function userUpdated() {
            cacheService.users.removeAll();
          })
      );
    };

    /**
     * Makes a request to the REST API to update the password for a user,
     * returning a promise that can be used for processing the results of the call.
     *
     * @param {String} dataSource
     *     The unique identifier of the data source containing the user to be
     *     updated. This identifier corresponds to an AuthenticationProvider
     *     within the Guacamole web application.
     *
     * @param {String} username
     *     The username of the user to update.
     *
     * @param {String} oldPassword
     *     The exiting password of the user to update.
     *
     * @param {String} newPassword
     *     The new password of the user to update.
     *
     * @returns {Promise}
     *     A promise for the HTTP call which will succeed if and only if the
     *     password update operation is successful.
     */
    service.updateUserPassword = function updateUserPassword(
      dataSource,
      username,
      oldPassword,
      newPassword
    ) {
      // Build HTTP parameters set
      var httpParameters = {
        token: authenticationService.getCurrentToken(),
      };

      // Update user password
      return (
        requestService({
          method: "PUT",
          url:
            "api/session/data/" +
            encodeURIComponent(dataSource) +
            "/users/" +
            encodeURIComponent(username) +
            "/password",
          params: httpParameters,
          data: new UserPasswordUpdate({
            oldPassword: oldPassword,
            newPassword: newPassword,
          }),
        })
          // Clear the cache
          .then(function passwordChanged() {
            cacheService.users.removeAll();
          })
      );
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the ActiveConnection class.
 */
angular.module("rest").factory("ActiveConnection", [
  function defineActiveConnection() {
    /**
     * The object returned by REST API calls when representing the data
     * associated with an active connection. Each active connection is
     * effectively a pairing of a connection and the user currently using it,
     * along with other information.
     *
     * @constructor
     * @param {ActiveConnection|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ActiveConnection.
     */
    var ActiveConnection = function ActiveConnection(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The identifier which uniquely identifies this specific active
       * connection.
       *
       * @type String
       */
      this.identifier = template.identifier;

      /**
       * The identifier of the connection associated with this active
       * connection.
       *
       * @type String
       */
      this.connectionIdentifier = template.connectionIdentifier;

      /**
       * The time that the connection began, in seconds since
       * 1970-01-01 00:00:00 UTC, if known.
       *
       * @type Number
       */
      this.startDate = template.startDate;

      /**
       * The remote host that initiated the connection, if known.
       *
       * @type String
       */
      this.remoteHost = template.remoteHost;

      /**
       * The username of the user associated with the connection, if known.
       *
       * @type String
       */
      this.username = template.username;

      /**
       * Whether this active connection may be connected to, just as a
       * normal connection.
       *
       * @type Boolean
       */
      this.connectable = template.connectable;
    };

    return ActiveConnection;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the Connection class.
 */
angular.module("rest").factory("Connection", [
  function defineConnection() {
    /**
     * The object returned by REST API calls when representing the data
     * associated with a connection.
     *
     * @constructor
     * @param {Connection|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     Connection.
     */
    var Connection = function Connection(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The unique identifier associated with this connection.
       *
       * @type String
       */
      this.identifier = template.identifier;

      /**
       * The unique identifier of the connection group that contains this
       * connection.
       *
       * @type String
       */
      this.parentIdentifier = template.parentIdentifier;

      /**
       * The human-readable name of this connection, which is not necessarily
       * unique.
       *
       * @type String
       */
      this.name = template.name;

      /**
       * The name of the protocol associated with this connection, such as
       * "vnc" or "rdp".
       *
       * @type String
       */
      this.protocol = template.protocol;

      /**
       * Connection configuration parameters, as dictated by the protocol in
       * use, arranged as name/value pairs. This information may not be
       * available until directly queried. If this information is
       * unavailable, this property will be null or undefined.
       *
       * @type Object.<String, String>
       */
      this.parameters = template.parameters;

      /**
       * Arbitrary name/value pairs which further describe this connection.
       * The semantics and validity of these attributes are dictated by the
       * extension which defines them.
       *
       * @type Object.<String, String>
       */
      this.attributes = template.attributes || {};

      /**
       * The count of currently active connections using this connection.
       * This field will be returned from the REST API during a get
       * operation, but manually setting this field will have no effect.
       *
       * @type Number
       */
      this.activeConnections = template.activeConnections;

      /**
       * An array of all associated sharing profiles, if known. This property
       * may be null or undefined if sharing profiles have not been queried,
       * and thus the sharing profiles are unknown.
       *
       * @type SharingProfile[]
       */
      this.sharingProfiles = template.sharingProfiles;

      /**
       * The time that this connection was last used, in milliseconds since
       * 1970-01-01 00:00:00 UTC. If this information is unknown or
       * unavailable, this will be null.
       *
       * @type Number
       */
      this.lastActive = template.lastActive;
    };

    return Connection;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the ConnectionGroup class.
 */
angular.module("rest").factory("ConnectionGroup", [
  function defineConnectionGroup() {
    /**
     * The object returned by REST API calls when representing the data
     * associated with a connection group.
     *
     * @constructor
     * @param {ConnectionGroup|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ConnectionGroup.
     */
    var ConnectionGroup = function ConnectionGroup(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The unique identifier associated with this connection group.
       *
       * @type String
       */
      this.identifier = template.identifier;

      /**
       * The unique identifier of the connection group that contains this
       * connection group.
       *
       * @type String
       * @default ConnectionGroup.ROOT_IDENTIFIER
       */
      this.parentIdentifier =
        template.parentIdentifier || ConnectionGroup.ROOT_IDENTIFIER;

      /**
       * The human-readable name of this connection group, which is not
       * necessarily unique.
       *
       * @type String
       */
      this.name = template.name;

      /**
       * The type of this connection group, which may be either
       * ConnectionGroup.Type.ORGANIZATIONAL or
       * ConnectionGroup.Type.BALANCING.
       *
       * @type String
       * @default ConnectionGroup.Type.ORGANIZATIONAL
       */
      this.type = template.type || ConnectionGroup.Type.ORGANIZATIONAL;

      /**
       * An array of all child connections, if known. This property may be
       * null or undefined if children have not been queried, and thus the
       * child connections are unknown.
       *
       * @type Connection[]
       */
      this.childConnections = template.childConnections;

      /**
       * An array of all child connection groups, if known. This property may
       * be null or undefined if children have not been queried, and thus the
       * child connection groups are unknown.
       *
       * @type ConnectionGroup[]
       */
      this.childConnectionGroups = template.childConnectionGroups;

      /**
       * Arbitrary name/value pairs which further describe this connection
       * group. The semantics and validity of these attributes are dictated
       * by the extension which defines them.
       *
       * @type Object.<String, String>
       */
      this.attributes = template.attributes || {};

      /**
       * The count of currently active connections using this connection
       * group. This field will be returned from the REST API during a get
       * operation, but manually setting this field will have no effect.
       *
       * @type Number
       */
      this.activeConnections = template.activeConnections;
    };

    /**
     * The reserved identifier which always represents the root connection
     * group.
     *
     * @type String
     */
    ConnectionGroup.ROOT_IDENTIFIER = "ROOT";

    /**
     * All valid connection group types.
     */
    ConnectionGroup.Type = {
      /**
       * The type string associated with balancing connection groups.
       *
       * @type String
       */
      BALANCING: "BALANCING",

      /**
       * The type string associated with organizational connection groups.
       *
       * @type String
       */
      ORGANIZATIONAL: "ORGANIZATIONAL",
    };

    return ConnectionGroup;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the ConnectionHistoryEntry class.
 */
angular.module("rest").factory("ConnectionHistoryEntry", [
  function defineConnectionHistoryEntry() {
    /**
     * The object returned by REST API calls when representing the data
     * associated with an entry in a connection's usage history. Each history
     * entry represents the time at which a particular started using a
     * connection and, if applicable, the time that usage stopped.
     *
     * @constructor
     * @param {ConnectionHistoryEntry|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     ConnectionHistoryEntry.
     */
    var ConnectionHistoryEntry = function ConnectionHistoryEntry(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The identifier of the connection associated with this history entry.
       *
       * @type String
       */
      this.connectionIdentifier = template.connectionIdentifier;

      /**
       * The name of the connection associated with this history entry.
       *
       * @type String
       */
      this.connectionName = template.connectionName;

      /**
       * The remote host associated with this history entry.
       *
       * @type String
       */
      this.remoteHost = template.remoteHost;

      /**
       * The time that usage began, in seconds since 1970-01-01 00:00:00 UTC.
       *
       * @type Number
       */
      this.startDate = template.startDate;

      /**
       * The time that usage ended, in seconds since 1970-01-01 00:00:00 UTC.
       * The absence of an endDate does NOT necessarily indicate that the
       * connection is still in use, particularly if the server was shutdown
       * or restarted before the history entry could be updated. To determine
       * whether a connection is still active, check the active property of
       * this history entry.
       *
       * @type Number
       */
      this.endDate = template.endDate;

      /**
       * The remote host that initiated this connection, if known.
       *
       * @type String
       */
      this.remoteHost = template.remoteHost;

      /**
       * The username of the user associated with this particular usage of
       * the connection.
       *
       * @type String
       */
      this.username = template.username;

      /**
       * Whether this usage of the connection is still active. Note that this
       * is the only accurate way to check for connection activity; the
       * absence of endDate does not necessarily imply the connection is
       * active, as the history entry may simply be incomplete.
       *
       * @type Boolean
       */
      this.active = template.active;
    };

    /**
     * All possible predicates for sorting ConnectionHistoryEntry objects using
     * the REST API. By default, each predicate indicates ascending order. To
     * indicate descending order, add "-" to the beginning of the predicate.
     *
     * @type Object.<String, String>
     */
    ConnectionHistoryEntry.SortPredicate = {
      /**
       * The date and time that the connection associated with the history
       * entry began (connected).
       */
      START_DATE: "startDate",
    };

    /**
     * Value/unit pair representing the length of time that a connection was
     * used.
     *
     * @constructor
     * @param {Number} milliseconds
     *     The number of milliseconds that the associated connection was used.
     */
    ConnectionHistoryEntry.Duration = function Duration(milliseconds) {
      /**
       * The provided duration in seconds.
       *
       * @type Number
       */
      var seconds = milliseconds / 1000;

      /**
       * Rounds the given value to the nearest tenth.
       *
       * @param {Number} value The value to round.
       * @returns {Number} The given value, rounded to the nearest tenth.
       */
      var round = function round(value) {
        return Math.round(value * 10) / 10;
      };

      // Days
      if (seconds >= 86400) {
        this.value = round(seconds / 86400);
        this.unit = "day";
      }

      // Hours
      else if (seconds >= 3600) {
        this.value = round(seconds / 3600);
        this.unit = "hour";
      }

      // Minutes
      else if (seconds >= 60) {
        this.value = round(seconds / 60);
        this.unit = "minute";
      }

      // Seconds
      else {
        /**
         * The number of seconds (or minutes, or hours, etc.) that the
         * connection was used. The units associated with this value are
         * represented by the unit property.
         *
         * @type Number
         */
        this.value = round(seconds);

        /**
         * The units associated with the value of this duration. Valid
         * units are 'second', 'minute', 'hour', and 'day'.
         *
         * @type String
         */
        this.unit = "second";
      }
    };

    return ConnectionHistoryEntry;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the Error class.
 */
angular.module("rest").factory("Error", [
  function defineError() {
    /**
     * The object returned by REST API calls when an error occurs.
     *
     * @constructor
     * @param {Error|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     Error.
     */
    var Error = function Error(template) {
      // Use empty object by default
      template = template || {};

      /**
       * A human-readable message describing the error that occurred.
       *
       * @type String
       */
      this.message = template.message;

      /**
       * A message which can be translated using the translation service,
       * consisting of a translation key and optional set of substitution
       * variables.
       *
       * @type TranslatableMessage
       */
      this.translatableMessage = template.translatableMessage;

      /**
       * The Guacamole protocol status code associated with the error that
       * occurred. This is only valid for errors of type STREAM_ERROR.
       *
       * @type Number
       */
      this.statusCode = template.statusCode;

      /**
       * The type string defining which values this parameter may contain,
       * as well as what properties are applicable. Valid types are listed
       * within Error.Type.
       *
       * @type String
       * @default Error.Type.INTERNAL_ERROR
       */
      this.type = template.type || Error.Type.INTERNAL_ERROR;

      /**
       * Any parameters which were expected in the original request, or are
       * now expected as a result of the original request, if any. If no
       * such information is available, this will be null.
       *
       * @type Field[]
       */
      this.expected = template.expected;
    };

    /**
     * All valid field types.
     */
    Error.Type = {
      /**
       * The requested operation could not be performed because the request
       * itself was malformed.
       *
       * @type String
       */
      BAD_REQUEST: "BAD_REQUEST",

      /**
       * The credentials provided were invalid.
       *
       * @type String
       */
      INVALID_CREDENTIALS: "INVALID_CREDENTIALS",

      /**
       * The credentials provided were not necessarily invalid, but were not
       * sufficient to determine validity.
       *
       * @type String
       */
      INSUFFICIENT_CREDENTIALS: "INSUFFICIENT_CREDENTIALS",

      /**
       * An internal server error has occurred.
       *
       * @type String
       */
      INTERNAL_ERROR: "INTERNAL_ERROR",

      /**
       * An object related to the request does not exist.
       *
       * @type String
       */
      NOT_FOUND: "NOT_FOUND",

      /**
       * Permission was denied to perform the requested operation.
       *
       * @type String
       */
      PERMISSION_DENIED: "PERMISSION_DENIED",

      /**
       * An error occurred within an intercepted stream, terminating that
       * stream. The Guacamole protocol status code of that error will be
       * stored within statusCode.
       *
       * @type String
       */
      STREAM_ERROR: "STREAM_ERROR",
    };

    return Error;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the Field class.
 */
angular.module("rest").factory("Field", [
  function defineField() {
    /**
     * The object returned by REST API calls when representing the data
     * associated with a field or configuration parameter.
     *
     * @constructor
     * @param {Field|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     Field.
     */
    var Field = function Field(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The name which uniquely identifies this parameter.
       *
       * @type String
       */
      this.name = template.name;

      /**
       * The type string defining which values this parameter may contain,
       * as well as what properties are applicable. Valid types are listed
       * within Field.Type.
       *
       * @type String
       * @default Field.Type.TEXT
       */
      this.type = template.type || Field.Type.TEXT;

      /**
       * All possible legal values for this parameter.
       *
       * @type String[]
       */
      this.options = template.options;
    };

    /**
     * All valid field types.
     */
    Field.Type = {
      /**
       * The type string associated with parameters that may contain a single
       * line of arbitrary text.
       *
       * @type String
       */
      TEXT: "TEXT",

      /**
       * The type string associated with parameters that may contain an email
       * address.
       *
       * @type String
       */
      EMAIL: "EMAIL",

      /**
       * The type string associated with parameters that may contain an
       * arbitrary string, where that string represents the username of the
       * user authenticating with the remote desktop service.
       *
       * @type String
       */
      USERNAME: "USERNAME",

      /**
       * The type string associated with parameters that may contain an
       * arbitrary string, where that string represents the password of the
       * user authenticating with the remote desktop service.
       *
       * @type String
       */
      PASSWORD: "PASSWORD",

      /**
       * The type string associated with parameters that may contain only
       * numeric values.
       *
       * @type String
       */
      NUMERIC: "NUMERIC",

      /**
       * The type string associated with parameters that may contain only a
       * single possible value, where that value enables the parameter's
       * effect. It is assumed that each BOOLEAN field will provide exactly
       * one possible value (option), which will be the value if that field
       * is true.
       *
       * @type String
       */
      BOOLEAN: "BOOLEAN",

      /**
       * The type string associated with parameters that may contain a
       * strictly-defined set of possible values.
       *
       * @type String
       */
      ENUM: "ENUM",

      /**
       * The type string associated with parameters that may contain any
       * number of lines of arbitrary text.
       *
       * @type String
       */
      MULTILINE: "MULTILINE",

      /**
       * The type string associated with parameters that may contain timezone
       * IDs. Valid timezone IDs are dictated by Java:
       * http://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html#getAvailableIDs%28%29
       *
       * @type String
       */
      TIMEZONE: "TIMEZONE",

      /**
       * The type string associated with parameters that may contain dates.
       * The format of the date is standardized as YYYY-MM-DD, zero-padded.
       *
       * @type String
       */
      DATE: "DATE",

      /**
       * The type string associated with parameters that may contain times.
       * The format of the time is stnadardized as HH:MM:DD, zero-padded,
       * 24-hour.
       *
       * @type String
       */
      TIME: "TIME",

      /**
       * An HTTP query parameter which is expected to be embedded in the URL
       * given to a user.
       *
       * @type String
       */
      QUERY_PARAMETER: "QUERY_PARAMETER",

      /**
       * The type string associated with parameters that may contain color
       * schemes accepted by the Guacamole server terminal emulator and
       * protocols which leverage it.
       *
       * @type String
       */
      TERMINAL_COLOR_SCHEME: "TERMINAL_COLOR_SCHEME",
    };

    return Field;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the Form class.
 */
angular.module("rest").factory("Form", [
  function defineForm() {
    /**
     * The object returned by REST API calls when representing the data
     * associated with a form or set of configuration parameters.
     *
     * @constructor
     * @param {Form|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     Form.
     */
    var Form = function Form(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The name which uniquely identifies this form, or null if this form
       * has no name.
       *
       * @type String
       */
      this.name = template.name;

      /**
       * All fields contained within this form.
       *
       * @type Field[]
       */
      this.fields = template.fields || [];
    };

    return Form;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for defining the PermissionFlagSet class.
 */
angular.module("rest").factory("PermissionFlagSet", [
  "PermissionSet",
  function definePermissionFlagSet(PermissionSet) {
    /**
     * Alternative view of a @link{PermissionSet} which allows manipulation of
     * each permission through the setting (or retrieval) of boolean property
     * values.
     *
     * @constructor
     * @param {PermissionFlagSet|Object} template
     *     The object whose properties should be copied within the new
     *     PermissionFlagSet.
     */
    var PermissionFlagSet = function PermissionFlagSet(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The granted state of each system permission, as a map of system
       * permission type string to boolean value. A particular permission is
       * granted if its corresponding boolean value is set to true. Valid
       * permission type strings are defined within
       * PermissionSet.SystemPermissionType. Permissions which are not
       * granted may be set to false, but this is not required.
       *
       * @type Object.<String, Boolean>
       */
      this.systemPermissions = template.systemPermissions || {};

      /**
       * The granted state of each permission for each connection, as a map
       * of object permission type string to permission map. The permission
       * map is, in turn, a map of connection identifier to boolean value. A
       * particular permission is granted if its corresponding boolean value
       * is set to true. Valid permission type strings are defined within
       * PermissionSet.ObjectPermissionType. Permissions which are not
       * granted may be set to false, but this is not required.
       *
       * @type Object.<String, Object.<String, Boolean>>
       */
      this.connectionPermissions = template.connectionPermissions || {
        READ: {},
        UPDATE: {},
        DELETE: {},
        ADMINISTER: {},
      };

      /**
       * The granted state of each permission for each connection group, as a
       * map of object permission type string to permission map. The
       * permission map is, in turn, a map of connection group identifier to
       * boolean value. A particular permission is granted if its
       * corresponding boolean value is set to true. Valid permission type
       * strings are defined within PermissionSet.ObjectPermissionType.
       * Permissions which are not granted may be set to false, but this is
       * not required.
       *
       * @type Object.<String, Object.<String, Boolean>>
       */
      this.connectionGroupPermissions = template.connectionGroupPermissions || {
        READ: {},
        UPDATE: {},
        DELETE: {},
        ADMINISTER: {},
      };

      /**
       * The granted state of each permission for each sharing profile, as a
       * map of object permission type string to permission map. The
       * permission map is, in turn, a map of sharing profile identifier to
       * boolean value. A particular permission is granted if its
       * corresponding boolean value is set to true. Valid permission type
       * strings are defined within PermissionSet.ObjectPermissionType.
       * Permissions which are not granted may be set to false, but this is
       * not required.
       *
       * @type Object.<String, Object.<String, Boolean>>
       */
      this.sharingProfilePermissions = template.sharingProfilePermissions || {
        READ: {},
        UPDATE: {},
        DELETE: {},
        ADMINISTER: {},
      };

      /**
       * The granted state of each permission for each active connection, as
       * a map of object permission type string to permission map. The
       * permission map is, in turn, a map of active connection identifier to
       * boolean value. A particular permission is granted if its
       * corresponding boolean value is set to true. Valid permission type
       * strings are defined within PermissionSet.ObjectPermissionType.
       * Permissions which are not granted may be set to false, but this is
       * not required.
       *
       * @type Object.<String, Object.<String, Boolean>>
       */
      this.activeConnectionPermissions =
        template.activeConnectionPermissions || {
          READ: {},
          UPDATE: {},
          DELETE: {},
          ADMINISTER: {},
        };

      /**
       * The granted state of each permission for each user, as a map of
       * object permission type string to permission map. The permission map
       * is, in turn, a map of username to boolean value. A particular
       * permission is granted if its corresponding boolean value is set to
       * true. Valid permission type strings are defined within
       * PermissionSet.ObjectPermissionType. Permissions which are not
       * granted may be set to false, but this is not required.
       *
       * @type Object.<String, Object.<String, Boolean>>
       */
      this.userPermissions = template.userPermissions || {
        READ: {},
        UPDATE: {},
        DELETE: {},
        ADMINISTER: {},
      };

      /**
       * The granted state of each permission for each user group, as a map of
       * object permission type string to permission map. The permission map
       * is, in turn, a map of group identifier to boolean value. A particular
       * permission is granted if its corresponding boolean value is set to
       * true. Valid permission type strings are defined within
       * PermissionSet.ObjectPermissionType. Permissions which are not
       * granted may be set to false, but this is not required.
       *
       * @type Object.<String, Object.<String, Boolean>>
       */
      this.userGroupPermissions = template.userGroupPermissions || {
        READ: {},
        UPDATE: {},
        DELETE: {},
        ADMINISTER: {},
      };
    };

    /**
     * Iterates through all permissions in the given permission map, setting
     * the corresponding permission flags in the given permission flag map.
     *
     * @param {Object.<String, String[]>} permMap
     *     Map of object identifiers to the set of granted permissions. Each
     *     permission is represented by a string listed within
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {Object.<String, Object.<String, Boolean>>} flagMap
     *     Map of permission type strings to identifier/flag pairs representing
     *     whether the permission of that type is granted for the object having
     *     having the associated identifier.
     */
    var addObjectPermissions = function addObjectPermissions(permMap, flagMap) {
      // For each defined identifier in the permission map
      for (var identifier in permMap) {
        // Pull the permission array and loop through each permission
        var permissions = permMap[identifier];
        permissions.forEach(function addObjectPermission(type) {
          // Get identifier/flag mapping, creating first if necessary
          var objectFlags = (flagMap[type] = flagMap[type] || {});

          // Set flag for current permission
          objectFlags[identifier] = true;
        });
      }
    };

    /**
     * Creates a new PermissionFlagSet, populating it with all the permissions
     * indicated as granted within the given PermissionSet.
     *
     * @param {PermissionSet} permissionSet
     *     The PermissionSet containing the permissions to be copied into a new
     *     PermissionFlagSet.
     *
     * @returns {PermissionFlagSet}
     *     A new PermissionFlagSet containing flags representing all granted
     *     permissions from the given PermissionSet.
     */
    PermissionFlagSet.fromPermissionSet = function fromPermissionSet(
      permissionSet
    ) {
      var permissionFlagSet = new PermissionFlagSet();

      // Add all granted system permissions
      permissionSet.systemPermissions.forEach(function addSystemPermission(
        type
      ) {
        permissionFlagSet.systemPermissions[type] = true;
      });

      // Add all granted connection permissions
      addObjectPermissions(
        permissionSet.connectionPermissions,
        permissionFlagSet.connectionPermissions
      );

      // Add all granted connection group permissions
      addObjectPermissions(
        permissionSet.connectionGroupPermissions,
        permissionFlagSet.connectionGroupPermissions
      );

      // Add all granted sharing profile permissions
      addObjectPermissions(
        permissionSet.sharingProfilePermissions,
        permissionFlagSet.sharingProfilePermissions
      );

      // Add all granted active connection permissions
      addObjectPermissions(
        permissionSet.activeConnectionPermissions,
        permissionFlagSet.activeConnectionPermissions
      );

      // Add all granted user permissions
      addObjectPermissions(
        permissionSet.userPermissions,
        permissionFlagSet.userPermissions
      );

      // Add all granted user group permissions
      addObjectPermissions(
        permissionSet.userGroupPermissions,
        permissionFlagSet.userGroupPermissions
      );

      return permissionFlagSet;
    };

    return PermissionFlagSet;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the PermissionPatch class.
 */
angular.module("rest").factory("PermissionPatch", [
  function definePermissionPatch() {
    /**
     * The object returned by REST API calls when representing changes to the
     * permissions granted to a specific user.
     *
     * @constructor
     * @param {PermissionPatch|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     PermissionPatch.
     */
    var PermissionPatch = function PermissionPatch(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The operation to apply to the permissions indicated by the path.
       * Valid operation values are defined within PermissionPatch.Operation.
       *
       * @type String
       */
      this.op = template.op;

      /**
       * The path of the permissions to modify. Depending on the type of the
       * permission, this will be either "/connectionPermissions/ID",
       * "/connectionGroupPermissions/ID", "/userPermissions/ID", or
       * "/systemPermissions", where "ID" is the identifier of the object
       * to which the permissions apply, if any.
       *
       * @type String
       */
      this.path = template.path;

      /**
       * The permissions being added or removed. If the permission applies to
       * an object, such as a connection or connection group, this will be a
       * value from PermissionSet.ObjectPermissionType. If the permission
       * applies to the system as a whole (the path is "/systemPermissions"),
       * this will be a value from PermissionSet.SystemPermissionType.
       *
       * @type String
       */
      this.value = template.value;
    };

    /**
     * All valid patch operations for permissions. Currently, only add and
     * remove are supported.
     */
    PermissionPatch.Operation = {
      /**
       * Adds (grants) the specified permission.
       */
      ADD: "add",

      /**
       * Removes (revokes) the specified permission.
       */
      REMOVE: "remove",
    };

    return PermissionPatch;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the PermissionSet class.
 */
angular.module("rest").factory("PermissionSet", [
  function definePermissionSet() {
    /**
     * The object returned by REST API calls when representing the permissions
     * granted to a specific user.
     *
     * @constructor
     * @param {PermissionSet|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     PermissionSet.
     */
    var PermissionSet = function PermissionSet(template) {
      // Use empty object by default
      template = template || {};

      /**
       * Map of connection identifiers to the corresponding array of granted
       * permissions. Each permission is represented by a string listed
       * within PermissionSet.ObjectPermissionType.
       *
       * @type Object.<String, String[]>
       */
      this.connectionPermissions = template.connectionPermissions || {};

      /**
       * Map of connection group identifiers to the corresponding array of
       * granted permissions. Each permission is represented by a string
       * listed within PermissionSet.ObjectPermissionType.
       *
       * @type Object.<String, String[]>
       */
      this.connectionGroupPermissions =
        template.connectionGroupPermissions || {};

      /**
       * Map of sharing profile identifiers to the corresponding array of
       * granted permissions. Each permission is represented by a string
       * listed within PermissionSet.ObjectPermissionType.
       *
       * @type Object.<String, String[]>
       */
      this.sharingProfilePermissions = template.sharingProfilePermissions || {};

      /**
       * Map of active connection identifiers to the corresponding array of
       * granted permissions. Each permission is represented by a string
       * listed within PermissionSet.ObjectPermissionType.
       *
       * @type Object.<String, String[]>
       */
      this.activeConnectionPermissions =
        template.activeConnectionPermissions || {};

      /**
       * Map of user identifiers to the corresponding array of granted
       * permissions. Each permission is represented by a string listed
       * within PermissionSet.ObjectPermissionType.
       *
       * @type Object.<String, String[]>
       */
      this.userPermissions = template.userPermissions || {};

      /**
       * Map of user group identifiers to the corresponding array of granted
       * permissions. Each permission is represented by a string listed
       * within PermissionSet.ObjectPermissionType.
       *
       * @type Object.<String, String[]>
       */
      this.userGroupPermissions = template.userGroupPermissions || {};

      /**
       * Array of granted system permissions. Each permission is represented
       * by a string listed within PermissionSet.SystemPermissionType.
       *
       * @type String[]
       */
      this.systemPermissions = template.systemPermissions || [];
    };

    /**
     * Valid object permission type strings.
     */
    PermissionSet.ObjectPermissionType = {
      /**
       * Permission to read from the specified object.
       */
      READ: "READ",

      /**
       * Permission to update the specified object.
       */
      UPDATE: "UPDATE",

      /**
       * Permission to delete the specified object.
       */
      DELETE: "DELETE",

      /**
       * Permission to administer the specified object
       */
      ADMINISTER: "ADMINISTER",
    };

    /**
     * Valid system permission type strings.
     */
    PermissionSet.SystemPermissionType = {
      /**
       * Permission to administer the entire system.
       */
      ADMINISTER: "ADMINISTER",

      /**
       * Permission to create new users.
       */
      CREATE_USER: "CREATE_USER",

      /**
       * Permission to create new user groups.
       */
      CREATE_USER_GROUP: "CREATE_USER_GROUP",

      /**
       * Permission to create new connections.
       */
      CREATE_CONNECTION: "CREATE_CONNECTION",

      /**
       * Permission to create new connection groups.
       */
      CREATE_CONNECTION_GROUP: "CREATE_CONNECTION_GROUP",

      /**
       * Permission to create new sharing profiles.
       */
      CREATE_SHARING_PROFILE: "CREATE_SHARING_PROFILE",
    };

    /**
     * Returns whether the given permission is granted for at least one
     * arbitrary object, regardless of ID.
     *
     * @param {Object.<String, String[]>} permMap
     *     The permission map to check, where each entry maps an object
     *     identifer to the array of granted permissions.
     *
     * @param {String} type
     *     The permission to search for, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @returns {Boolean}
     *     true if the permission is present (granted), false otherwise.
     */
    var containsPermission = function containsPermission(permMap, type) {
      // Search all identifiers for given permission
      for (var identifier in permMap) {
        // If permission is granted, then no further searching is necessary
        if (permMap[identifier].indexOf(type) !== -1) return true;
      }

      // No such permission exists
      return false;
    };

    /**
     * Returns whether the given permission is granted for the arbitrary
     * object having the given ID. If no ID is given, this function determines
     * whether the permission is granted at all for any such arbitrary object.
     *
     * @param {Object.<String, String[]>} permMap
     *     The permission map to check, where each entry maps an object
     *     identifer to the array of granted permissions.
     *
     * @param {String} type
     *     The permission to search for, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} [identifier]
     *     The identifier of the object to which the permission applies.
     *
     * @returns {Boolean}
     *     true if the permission is present (granted), false otherwise.
     */
    var hasPermission = function hasPermission(permMap, type, identifier) {
      // No permission if no permission map at all
      if (!permMap) return false;

      // If no identifier given, search ignoring the identifier
      if (!identifier) return containsPermission(permMap, type);

      // If identifier not present at all, there are no such permissions
      if (!(identifier in permMap)) return false;

      return permMap[identifier].indexOf(type) !== -1;
    };

    /**
     * Returns whether the given permission is granted for the connection
     * having the given ID.
     *
     * @param {PermissionSet|Object} permSet
     *     The permission set to check.
     *
     * @param {String} type
     *     The permission to search for, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the connection to which the permission applies.
     *
     * @returns {Boolean}
     *     true if the permission is present (granted), false otherwise.
     */
    PermissionSet.hasConnectionPermission = function hasConnectionPermission(
      permSet,
      type,
      identifier
    ) {
      return hasPermission(permSet.connectionPermissions, type, identifier);
    };

    /**
     * Returns whether the given permission is granted for the connection group
     * having the given ID.
     *
     * @param {PermissionSet|Object} permSet
     *     The permission set to check.
     *
     * @param {String} type
     *     The permission to search for, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the connection group to which the permission
     *     applies.
     *
     * @returns {Boolean}
     *     true if the permission is present (granted), false otherwise.
     */
    PermissionSet.hasConnectionGroupPermission =
      function hasConnectionGroupPermission(permSet, type, identifier) {
        return hasPermission(
          permSet.connectionGroupPermissions,
          type,
          identifier
        );
      };

    /**
     * Returns whether the given permission is granted for the sharing profile
     * having the given ID.
     *
     * @param {PermissionSet|Object} permSet
     *     The permission set to check.
     *
     * @param {String} type
     *     The permission to search for, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the sharing profile to which the permission
     *     applies.
     *
     * @returns {Boolean}
     *     true if the permission is present (granted), false otherwise.
     */
    PermissionSet.hasSharingProfilePermission =
      function hasSharingProfilePermission(permSet, type, identifier) {
        return hasPermission(
          permSet.sharingProfilePermissions,
          type,
          identifier
        );
      };

    /**
     * Returns whether the given permission is granted for the active
     * connection having the given ID.
     *
     * @param {PermissionSet|Object} permSet
     *     The permission set to check.
     *
     * @param {String} type
     *     The permission to search for, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the active connection to which the permission
     *     applies.
     *
     * @returns {Boolean}
     *     true if the permission is present (granted), false otherwise.
     */
    PermissionSet.hasActiveConnectionPermission =
      function hasActiveConnectionPermission(permSet, type, identifier) {
        return hasPermission(
          permSet.activeConnectionPermissions,
          type,
          identifier
        );
      };

    /**
     * Returns whether the given permission is granted for the user having the
     * given ID.
     *
     * @param {PermissionSet|Object} permSet
     *     The permission set to check.
     *
     * @param {String} type
     *     The permission to search for, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the user to which the permission applies.
     *
     * @returns {Boolean}
     *     true if the permission is present (granted), false otherwise.
     */
    PermissionSet.hasUserPermission = function hasUserPermission(
      permSet,
      type,
      identifier
    ) {
      return hasPermission(permSet.userPermissions, type, identifier);
    };

    /**
     * Returns whether the given permission is granted for the user group having
     * the given identifier.
     *
     * @param {PermissionSet|Object} permSet
     *     The permission set to check.
     *
     * @param {String} type
     *     The permission to search for, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the user group to which the permission applies.
     *
     * @returns {Boolean}
     *     true if the permission is present (granted), false otherwise.
     */
    PermissionSet.hasUserGroupPermission = function hasUserGroupPermission(
      permSet,
      type,
      identifier
    ) {
      return hasPermission(permSet.userGroupPermissions, type, identifier);
    };

    /**
     * Returns whether the given permission is granted at the system level.
     *
     * @param {PermissionSet|Object} permSet
     *     The permission set to check.
     *
     * @param {String} type
     *     The permission to search for, as defined by
     *     PermissionSet.SystemPermissionType.
     *
     * @returns {Boolean}
     *     true if the permission is present (granted), false otherwise.
     */
    PermissionSet.hasSystemPermission = function hasSystemPermission(
      permSet,
      type
    ) {
      if (!permSet.systemPermissions) return false;
      return permSet.systemPermissions.indexOf(type) !== -1;
    };

    /**
     * Adds the given system permission to the given permission set, if not
     * already present. If the permission is already present, this function has
     * no effect.
     *
     * @param {PermissionSet} permSet
     *     The permission set to modify.
     *
     * @param {String} type
     *     The permission to add, as defined by
     *     PermissionSet.SystemPermissionType.
     *
     * @returns {Boolean}
     *     true if the permission was added, false if the permission was
     *     already present in the given permission set.
     */
    PermissionSet.addSystemPermission = function addSystemPermission(
      permSet,
      type
    ) {
      permSet.systemPermissions = permSet.systemPermissions || [];

      // Add permission, if it doesn't already exist
      if (permSet.systemPermissions.indexOf(type) === -1) {
        permSet.systemPermissions.push(type);
        return true;
      }

      // Permission already present
      return false;
    };

    /**
     * Removes the given system permission from the given permission set, if
     * present. If the permission is not present, this function has no effect.
     *
     * @param {PermissionSet} permSet
     *     The permission set to modify.
     *
     * @param {String} type
     *     The permission to remove, as defined by
     *     PermissionSet.SystemPermissionType.
     *
     * @returns {Boolean}
     *     true if the permission was removed, false if the permission was not
     *     present in the given permission set.
     */
    PermissionSet.removeSystemPermission = function removeSystemPermission(
      permSet,
      type
    ) {
      permSet.systemPermissions = permSet.systemPermissions || [];

      // Remove permission, if it exists
      var permLocation = permSet.systemPermissions.indexOf(type);
      if (permLocation !== -1) {
        permSet.systemPermissions.splice(permLocation, 1);
        return true;
      }

      // Permission not present
      return false;
    };

    /**
     * Adds the given permission applying to the arbitrary object with the
     * given ID to the given permission set, if not already present. If the
     * permission is already present, this function has no effect.
     *
     * @param {Object.<String, String[]>} permMap
     *     The permission map to modify, where each entry maps an object
     *     identifer to the array of granted permissions.
     *
     * @param {String} type
     *     The permission to add, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the arbitrary object to which the permission
     *     applies.
     *
     * @returns {Boolean}
     *     true if the permission was added, false if the permission was
     *     already present in the given permission set.
     */
    var addObjectPermission = function addObjectPermission(
      permMap,
      type,
      identifier
    ) {
      // Pull array of permissions, creating it if necessary
      var permArray = (permMap[identifier] = permMap[identifier] || []);

      // Add permission, if it doesn't already exist
      if (permArray.indexOf(type) === -1) {
        permArray.push(type);
        return true;
      }

      // Permission already present
      return false;
    };

    /**
     * Removes the given permission applying to the arbitrary object with the
     * given ID from the given permission set, if present. If the permission is
     * not present, this function has no effect.
     *
     * @param {Object.<String, String[]>} permMap
     *     The permission map to modify, where each entry maps an object
     *     identifer to the array of granted permissions.
     *
     * @param {String} type
     *     The permission to remove, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the arbitrary object to which the permission
     *     applies.
     *
     * @returns {Boolean}
     *     true if the permission was removed, false if the permission was not
     *     present in the given permission set.
     */
    var removeObjectPermission = function removeObjectPermission(
      permMap,
      type,
      identifier
    ) {
      // Pull array of permissions
      var permArray = permMap[identifier];

      // If no permissions present at all, nothing to remove
      if (!(identifier in permMap)) return false;

      // Remove permission, if it exists
      var permLocation = permArray.indexOf(type);
      if (permLocation !== -1) {
        permArray.splice(permLocation, 1);
        return true;
      }

      // Permission not present
      return false;
    };

    /**
     * Adds the given connection permission applying to the connection with
     * the given ID to the given permission set, if not already present. If the
     * permission is already present, this function has no effect.
     *
     * @param {PermissionSet} permSet
     *     The permission set to modify.
     *
     * @param {String} type
     *     The permission to add, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the connection to which the permission applies.
     *
     * @returns {Boolean}
     *     true if the permission was added, false if the permission was
     *     already present in the given permission set.
     */
    PermissionSet.addConnectionPermission = function addConnectionPermission(
      permSet,
      type,
      identifier
    ) {
      permSet.connectionPermissions = permSet.connectionPermissions || {};
      return addObjectPermission(
        permSet.connectionPermissions,
        type,
        identifier
      );
    };

    /**
     * Removes the given connection permission applying to the connection with
     * the given ID from the given permission set, if present. If the
     * permission is not present, this function has no effect.
     *
     * @param {PermissionSet} permSet
     *     The permission set to modify.
     *
     * @param {String} type
     *     The permission to remove, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the connection to which the permission applies.
     *
     * @returns {Boolean}
     *     true if the permission was removed, false if the permission was not
     *     present in the given permission set.
     */
    PermissionSet.removeConnectionPermission =
      function removeConnectionPermission(permSet, type, identifier) {
        permSet.connectionPermissions = permSet.connectionPermissions || {};
        return removeObjectPermission(
          permSet.connectionPermissions,
          type,
          identifier
        );
      };

    /**
     * Adds the given connection group permission applying to the connection
     * group with the given ID to the given permission set, if not already
     * present. If the permission is already present, this function has no
     * effect.
     *
     * @param {PermissionSet} permSet
     *     The permission set to modify.
     *
     * @param {String} type
     *     The permission to add, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the connection group to which the permission
     *     applies.
     *
     * @returns {Boolean}
     *     true if the permission was added, false if the permission was
     *     already present in the given permission set.
     */
    PermissionSet.addConnectionGroupPermission =
      function addConnectionGroupPermission(permSet, type, identifier) {
        permSet.connectionGroupPermissions =
          permSet.connectionGroupPermissions || {};
        return addObjectPermission(
          permSet.connectionGroupPermissions,
          type,
          identifier
        );
      };

    /**
     * Removes the given connection group permission applying to the connection
     * group with the given ID from the given permission set, if present. If
     * the permission is not present, this function has no effect.
     *
     * @param {PermissionSet} permSet
     *     The permission set to modify.
     *
     * @param {String} type
     *     The permission to remove, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the connection group to which the permission
     *     applies.
     *
     * @returns {Boolean}
     *     true if the permission was removed, false if the permission was not
     *     present in the given permission set.
     */
    PermissionSet.removeConnectionGroupPermission =
      function removeConnectionGroupPermission(permSet, type, identifier) {
        permSet.connectionGroupPermissions =
          permSet.connectionGroupPermissions || {};
        return removeObjectPermission(
          permSet.connectionGroupPermissions,
          type,
          identifier
        );
      };

    /**
     * Adds the given sharing profile permission applying to the sharing profile
     * with the given ID to the given permission set, if not already present. If
     * the permission is already present, this function has no effect.
     *
     * @param {PermissionSet} permSet
     *     The permission set to modify.
     *
     * @param {String} type
     *     The permission to add, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the sharing profile to which the permission
     *     applies.
     *
     * @returns {Boolean}
     *     true if the permission was added, false if the permission was
     *     already present in the given permission set.
     */
    PermissionSet.addSharingProfilePermission =
      function addSharingProfilePermission(permSet, type, identifier) {
        permSet.sharingProfilePermissions =
          permSet.sharingProfilePermissions || {};
        return addObjectPermission(
          permSet.sharingProfilePermissions,
          type,
          identifier
        );
      };

    /**
     * Removes the given sharing profile permission applying to the sharing
     * profile with the given ID from the given permission set, if present. If
     * the permission is not present, this function has no effect.
     *
     * @param {PermissionSet} permSet
     *     The permission set to modify.
     *
     * @param {String} type
     *     The permission to remove, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the sharing profile to which the permission
     *     applies.
     *
     * @returns {Boolean}
     *     true if the permission was removed, false if the permission was not
     *     present in the given permission set.
     */
    PermissionSet.removeSharingProfilePermission =
      function removeSharingProfilePermission(permSet, type, identifier) {
        permSet.sharingProfilePermissions =
          permSet.sharingProfilePermissions || {};
        return removeObjectPermission(
          permSet.sharingProfilePermissions,
          type,
          identifier
        );
      };

    /**
     * Adds the given active connection permission applying to the connection
     * group with the given ID to the given permission set, if not already
     * present. If the permission is already present, this function has no
     * effect.
     *
     * @param {PermissionSet} permSet
     *     The permission set to modify.
     *
     * @param {String} type
     *     The permission to add, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the active connection to which the permission
     *     applies.
     *
     * @returns {Boolean}
     *     true if the permission was added, false if the permission was
     *     already present in the given permission set.
     */
    PermissionSet.addActiveConnectionPermission =
      function addActiveConnectionPermission(permSet, type, identifier) {
        permSet.activeConnectionPermissions =
          permSet.activeConnectionPermissions || {};
        return addObjectPermission(
          permSet.activeConnectionPermissions,
          type,
          identifier
        );
      };

    /**
     * Removes the given active connection permission applying to the
     * connection group with the given ID from the given permission set, if
     * present. If the permission is not present, this function has no effect.
     *
     * @param {PermissionSet} permSet
     *     The permission set to modify.
     *
     * @param {String} type
     *     The permission to remove, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the active connection to which the permission
     *     applies.
     *
     * @returns {Boolean}
     *     true if the permission was removed, false if the permission was not
     *     present in the given permission set.
     */
    PermissionSet.removeActiveConnectionPermission =
      function removeActiveConnectionPermission(permSet, type, identifier) {
        permSet.activeConnectionPermissions =
          permSet.activeConnectionPermissions || {};
        return removeObjectPermission(
          permSet.activeConnectionPermissions,
          type,
          identifier
        );
      };

    /**
     * Adds the given user permission applying to the user with the given ID to
     * the given permission set, if not already present. If the permission is
     * already present, this function has no effect.
     *
     * @param {PermissionSet} permSet
     *     The permission set to modify.
     *
     * @param {String} type
     *     The permission to add, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the user to which the permission applies.
     *
     * @returns {Boolean}
     *     true if the permission was added, false if the permission was
     *     already present in the given permission set.
     */
    PermissionSet.addUserPermission = function addUserPermission(
      permSet,
      type,
      identifier
    ) {
      permSet.userPermissions = permSet.userPermissions || {};
      return addObjectPermission(permSet.userPermissions, type, identifier);
    };

    /**
     * Removes the given user permission applying to the user with the given ID
     * from the given permission set, if present. If the permission is not
     * present, this function has no effect.
     *
     * @param {PermissionSet} permSet
     *     The permission set to modify.
     *
     * @param {String} type
     *     The permission to remove, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the user to whom the permission applies.
     *
     * @returns {Boolean}
     *     true if the permission was removed, false if the permission was not
     *     present in the given permission set.
     */
    PermissionSet.removeUserPermission = function removeUserPermission(
      permSet,
      type,
      identifier
    ) {
      permSet.userPermissions = permSet.userPermissions || {};
      return removeObjectPermission(permSet.userPermissions, type, identifier);
    };

    /**
     * Adds the given user group permission applying to the user group with the
     * given identifier to the given permission set, if not already present. If
     * the permission is already present, this function has no effect.
     *
     * @param {PermissionSet} permSet
     *     The permission set to modify.
     *
     * @param {String} type
     *     The permission to add, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the user group to which the permission applies.
     *
     * @returns {Boolean}
     *     true if the permission was added, false if the permission was
     *     already present in the given permission set.
     */
    PermissionSet.addUserGroupPermission = function addUserGroupPermission(
      permSet,
      type,
      identifier
    ) {
      permSet.userGroupPermissions = permSet.userGroupPermissions || {};
      return addObjectPermission(
        permSet.userGroupPermissions,
        type,
        identifier
      );
    };

    /**
     * Removes the given user group permission applying to the user group with
     * the given identifier from the given permission set, if present. If the
     * permission is not present, this function has no effect.
     *
     * @param {PermissionSet} permSet
     *     The permission set to modify.
     *
     * @param {String} type
     *     The permission to remove, as defined by
     *     PermissionSet.ObjectPermissionType.
     *
     * @param {String} identifier
     *     The identifier of the user group to whom the permission applies.
     *
     * @returns {Boolean}
     *     true if the permission was removed, false if the permission was not
     *     present in the given permission set.
     */
    PermissionSet.removeUserGroupPermission =
      function removeUserGroupPermission(permSet, type, identifier) {
        permSet.userGroupPermissions = permSet.userGroupPermissions || {};
        return removeObjectPermission(
          permSet.userGroupPermissions,
          type,
          identifier
        );
      };

    return PermissionSet;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the Protocol class.
 */
angular.module("rest").factory("Protocol", [
  "$injector",
  function defineProtocol($injector) {
    // Required services
    var translationStringService = $injector.get("translationStringService");

    /**
     * The object returned by REST API calls when representing the data
     * associated with a supported remote desktop protocol.
     *
     * @constructor
     * @param {Protocol|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     Protocol.
     */
    var Protocol = function Protocol(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The name which uniquely identifies this protocol.
       *
       * @type String
       */
      this.name = template.name;

      /**
       * An array of forms describing all known parameters for a connection
       * using this protocol, including their types and other information.
       *
       * @type Form[]
       * @default []
       */
      this.connectionForms = template.connectionForms || [];

      /**
       * An array of forms describing all known parameters relevant to a
       * sharing profile whose primary connection uses this protocol,
       * including their types, and other information.
       *
       * @type Form[]
       * @default []
       */
      this.sharingProfileForms = template.sharingProfileForms || [];
    };

    /**
     * Returns the translation string namespace for the protocol having the
     * given name. The namespace will be of the form:
     *
     * <code>PROTOCOL_NAME</code>
     *
     * where <code>NAME</code> is the protocol name transformed via
     * translationStringService.canonicalize().
     *
     * @param {String} protocolName
     *     The name of the protocol.
     *
     * @returns {String}
     *     The translation namespace for the protocol specified, or null if no
     *     namespace could be generated.
     */
    Protocol.getNamespace = function getNamespace(protocolName) {
      // Do not generate a namespace if no protocol is selected
      if (!protocolName) return null;

      return "PROTOCOL_" + translationStringService.canonicalize(protocolName);
    };

    /**
     * Given the internal name of a protocol, produces the translation string
     * for the localized version of that protocol's name. The translation
     * string will be of the form:
     *
     * <code>NAMESPACE.NAME<code>
     *
     * where <code>NAMESPACE</code> is the namespace generated from
     * $scope.getNamespace().
     *
     * @param {String} protocolName
     *     The name of the protocol.
     *
     * @returns {String}
     *     The translation string which produces the localized name of the
     *     protocol specified.
     */
    Protocol.getName = function getProtocolName(protocolName) {
      return Protocol.getNamespace(protocolName) + ".NAME";
    };

    return Protocol;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the RelatedObjectPatch class.
 */
angular.module("rest").factory("RelatedObjectPatch", [
  function defineRelatedObjectPatch() {
    /**
     * The object returned by REST API calls when representing changes to an
     * arbitrary set of objects which share some common relation.
     *
     * @constructor
     * @param {RelatedObjectPatch|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     RelatedObjectPatch.
     */
    var RelatedObjectPatch = function RelatedObjectPatch(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The operation to apply to the objects indicated by the path. Valid
       * operation values are defined within RelatedObjectPatch.Operation.
       *
       * @type String
       */
      this.op = template.op;

      /**
       * The path of the objects to modify. This will always be "/".
       *
       * @type String
       * @default '/'
       */
      this.path = template.path || "/";

      /**
       * The identifier of the object being added or removed from the
       * relation.
       *
       * @type String
       */
      this.value = template.value;
    };

    /**
     * All valid patch operations for objects sharing some common relation.
     * Currently, only add and remove are supported.
     */
    RelatedObjectPatch.Operation = {
      /**
       * Adds the specified object to the relation.
       */
      ADD: "add",

      /**
       * Removes the specified object from the relation.
       */
      REMOVE: "remove",
    };

    return RelatedObjectPatch;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the SharingProfile class.
 */
angular.module("rest").factory("SharingProfile", [
  function defineSharingProfile() {
    /**
     * The object returned by REST API calls when representing the data
     * associated with a sharing profile.
     *
     * @constructor
     * @param {SharingProfile|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     SharingProfile.
     */
    var SharingProfile = function SharingProfile(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The unique identifier associated with this sharing profile.
       *
       * @type String
       */
      this.identifier = template.identifier;

      /**
       * The unique identifier of the connection that this sharing profile
       * can be used to share.
       *
       * @type String
       */
      this.primaryConnectionIdentifier = template.primaryConnectionIdentifier;

      /**
       * The human-readable name of this sharing profile, which is not
       * necessarily unique.
       *
       * @type String
       */
      this.name = template.name;

      /**
       * Connection configuration parameters, as dictated by the protocol in
       * use by the primary connection, arranged as name/value pairs. This
       * information may not be available until directly queried. If this
       * information is unavailable, this property will be null or undefined.
       *
       * @type Object.<String, String>
       */
      this.parameters = template.parameters;

      /**
       * Arbitrary name/value pairs which further describe this sharing
       * profile. The semantics and validity of these attributes are dictated
       * by the extension which defines them.
       *
       * @type Object.<String, String>
       */
      this.attributes = template.attributes || {};
    };

    return SharingProfile;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the TranslatableMessage class.
 */
angular.module("rest").factory("TranslatableMessage", [
  function defineTranslatableMessage() {
    /**
     * The object returned by REST API calls when representing a message which
     * can be translated using the translation service, providing a translation
     * key and optional set of values to be substituted into the translation
     * string associated with that key.
     *
     * @constructor
     * @param {TranslatableMessage|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     TranslatableMessage.
     */
    var TranslatableMessage = function TranslatableMessage(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The key associated with the translation string that used when
       * displaying this message.
       *
       * @type String
       */
      this.key = template.key;

      /**
       * The object which should be passed through to the translation service
       * for the sake of variable substitution. Each property of the provided
       * object will be substituted for the variable of the same name within
       * the translation string.
       *
       * @type Object
       */
      this.variables = template.variables;
    };

    return TranslatableMessage;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the User class.
 */
angular.module("rest").factory("User", [
  function defineUser() {
    /**
     * The object returned by REST API calls when representing the data
     * associated with a user.
     *
     * @constructor
     * @param {User|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     User.
     */
    var User = function User(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The name which uniquely identifies this user.
       *
       * @type String
       */
      this.username = template.username;

      /**
       * This user's password. Note that the REST API may not populate this
       * property for the sake of security. In most cases, it's not even
       * possible for the authentication layer to retrieve the user's true
       * password.
       *
       * @type String
       */
      this.password = template.password;

      /**
       * The time that this user was last logged in, in milliseconds since
       * 1970-01-01 00:00:00 UTC. If this information is unknown or
       * unavailable, this will be null.
       *
       * @type Number
       */
      this.lastActive = template.lastActive;

      /**
       * Arbitrary name/value pairs which further describe this user. The
       * semantics and validity of these attributes are dictated by the
       * extension which defines them.
       *
       * @type Object.<String, String>
       */
      this.attributes = template.attributes || {};
    };

    /**
     * All standard attribute names with semantics defined by the Guacamole web
     * application. Extensions may additionally define their own attributes
     * with completely arbitrary names and semantics, so long as those names do
     * not conflict with the names listed here. All standard attribute names
     * have a "guac-" prefix to avoid such conflicts.
     */
    User.Attributes = {
      /**
       * The user's full name.
       *
       * @type String
       */
      FULL_NAME: "guac-full-name",

      /**
       * The email address of the user.
       *
       * @type String
       */
      EMAIL_ADDRESS: "guac-email-address",

      /**
       * The organization, company, group, etc. that the user belongs to.
       *
       * @type String
       */
      ORGANIZATION: "guac-organization",

      /**
       * The role that the user has at the organization, company, group, etc.
       * they belong to.
       *
       * @type String
       */
      ORGANIZATIONAL_ROLE: "guac-organizational-role",
    };

    return User;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the UserCredentials class.
 */
angular.module("rest").factory("UserCredentials", [
  "$injector",
  function defineUserCredentials($injector) {
    // Required services
    var $window = $injector.get("$window");

    // Required types
    var Field = $injector.get("Field");

    /**
     * The object returned by REST API calls to define a full set of valid
     * credentials, including field definitions and corresponding expected
     * values.
     *
     * @constructor
     * @param {UserCredentials|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     UserCredentials.
     */
    var UserCredentials = function UserCredentials(template) {
      // Use empty object by default
      template = template || {};

      /**
       * Any parameters which should be provided when these credentials are
       * submitted. If no such information is available, this will be null.
       *
       * @type Field[]
       */
      this.expected = template.expected;

      /**
       * A map of all field values by field name. The fields having the names
       * used within this map should be defined within the @link{Field} array
       * stored under the @link{expected} property.
       *
       * @type Object.<String, String>
       */
      this.values = template.values;
    };

    /**
     * Generates a query string containing all QUERY_PARAMETER fields from the
     * given UserCredentials object, along with their corresponding values. The
     * parameter names and values will be appropriately URL-encoded and
     * separated by ampersands.
     *
     * @param {UserCredentials} userCredentials
     *     The UserCredentials to retrieve all query parameters from.
     *
     * @returns {String}
     *     A string containing all QUERY_PARAMETER fields as name/value pairs
     *     separated by ampersands, where each name is separated by the value
     *     by an equals sign.
     */
    UserCredentials.getQueryParameters = function getQueryParameters(
      userCredentials
    ) {
      // Build list of parameter name/value pairs
      var parameters = [];
      angular.forEach(
        userCredentials.expected,
        function addQueryParameter(field) {
          // Only add query parameters
          if (field.type !== Field.Type.QUERY_PARAMETER) return;

          // Pull parameter name and value
          var name = field.name;
          var value = userCredentials.values[name];

          // Properly encode name/value pair
          parameters.push(
            encodeURIComponent(name) + "=" + encodeURIComponent(value)
          );
        }
      );

      // Separate each name/value pair by an ampersand
      return parameters.join("&");
    };

    /**
     * Returns a fully-qualified, absolute URL to Guacamole prepopulated with
     * any query parameters dictated by the QUERY_PARAMETER fields defined in
     * the given UserCredentials.
     *
     * @param {UserCredentials} userCredentials
     *     The UserCredentials to retrieve all query parameters from.
     *
     * @returns {String}
     *     A fully-qualified, absolute URL to Guacamole prepopulated with the
     *     query parameters dictated by the given UserCredentials.
     */
    UserCredentials.getLink = function getLink(userCredentials) {
      // Work-around for IE missing window.location.origin
      if (!$window.location.origin)
        var linkOrigin =
          $window.location.protocol +
          "//" +
          $window.location.hostname +
          ($window.location.port ? ":" + $window.location.port : "");
      else var linkOrigin = $window.location.origin;

      // Build base link
      var link = linkOrigin + $window.location.pathname + "#/";

      // Add any required parameters
      var params = UserCredentials.getQueryParameters(userCredentials);
      if (params) link += "?" + params;

      return link;
    };

    return UserCredentials;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the UserGroup class.
 */
angular.module("rest").factory("UserGroup", [
  function defineUserGroup() {
    /**
     * The object returned by REST API calls when representing the data
     * associated with a user group.
     *
     * @constructor
     * @param {UserGroup|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     UserGroup.
     */
    var UserGroup = function UserGroup(template) {
      // Use empty object by default
      template = template || {};

      /**
       * The name which uniquely identifies this user group.
       *
       * @type String
       */
      this.identifier = template.identifier;

      /**
       * Arbitrary name/value pairs which further describe this user group.
       * The semantics and validity of these attributes are dictated by the
       * extension which defines them.
       *
       * @type Object.<String, String>
       */
      this.attributes = template.attributes || {};
    };

    return UserGroup;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service which defines the UserPasswordUpdate class.
 */
angular.module("rest").factory("UserPasswordUpdate", [
  function defineUserPasswordUpdate() {
    /**
     * The object sent to the REST API when representing the data
     * associated with a user password update.
     *
     * @constructor
     * @param {UserPasswordUpdate|Object} [template={}]
     *     The object whose properties should be copied within the new
     *     UserPasswordUpdate.
     */
    var UserPasswordUpdate = function UserPasswordUpdate(template) {
      // Use empty object by default
      template = template || {};

      /**
       * This user's current password. Required for authenticating the user
       * as part of to the password update operation.
       *
       * @type String
       */
      this.oldPassword = template.oldPassword;

      /**
       * The new password to set for the user.
       *
       * @type String
       */
      this.newPassword = template.newPassword;
    };

    return UserPasswordUpdate;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The controller for the general settings page.
 */
angular.module("manage").controller("settingsController", [
  "$scope",
  "$injector",
  function settingsController($scope, $injector) {
    // Required services
    var $routeParams = $injector.get("$routeParams");
    var userPageService = $injector.get("userPageService");

    /**
     * The array of settings pages available to the current user, or null if
     * not yet known.
     *
     * @type Page[]
     */
    $scope.settingsPages = null;

    /**
     * The currently-selected settings tab. This may be 'users', 'userGroups',
     * 'connections', 'history', 'preferences', or 'sessions'.
     *
     * @type String
     */
    $scope.activeTab = $routeParams.tab;

    // Retrieve settings pages
    userPageService
      .getSettingsPages()
      .then(function settingsPagesRetrieved(pages) {
        $scope.settingsPages = pages;
      });
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive for viewing connection history records.
 */
angular.module("settings").directive("guacSettingsConnectionHistory", [
  function guacSettingsConnectionHistory() {
    return {
      // Element only
      restrict: "E",
      replace: true,

      scope: {},

      templateUrl: "app/settings/templates/settingsConnectionHistory.html",
      controller: [
        "$scope",
        "$injector",
        function settingsConnectionHistoryController($scope, $injector) {
          // Get required types
          var ConnectionHistoryEntryWrapper = $injector.get(
            "ConnectionHistoryEntryWrapper"
          );
          var FilterToken = $injector.get("FilterToken");
          var SortOrder = $injector.get("SortOrder");

          // Get required services
          var $filter = $injector.get("$filter");
          var $routeParams = $injector.get("$routeParams");
          var $translate = $injector.get("$translate");
          var csvService = $injector.get("csvService");
          var historyService = $injector.get("historyService");
          var requestService = $injector.get("requestService");

          /**
           * The identifier of the currently-selected data source.
           *
           * @type String
           */
          $scope.dataSource = $routeParams.dataSource;

          /**
           * All wrapped matching connection history entries, or null if these
           * entries have not yet been retrieved.
           *
           * @type ConnectionHistoryEntryWrapper[]
           */
          $scope.historyEntryWrappers = null;

          /**
           * The search terms to use when filtering the history records.
           *
           * @type String
           */
          $scope.searchString = "";

          /**
           * The date format for use for start/end dates.
           *
           * @type String
           */
          $scope.dateFormat = null;

          /**
           * SortOrder instance which stores the sort order of the history
           * records.
           *
           * @type SortOrder
           */
          $scope.order = new SortOrder([
            "-startDate",
            "-duration",
            "username",
            "connectionName",
            "remoteHost",
          ]);

          // Get session date format
          $translate("SETTINGS_CONNECTION_HISTORY.FORMAT_DATE").then(
            function dateFormatReceived(retrievedDateFormat) {
              // Store received date format
              $scope.dateFormat = retrievedDateFormat;
            },
            angular.noop
          );

          /**
           * Returns true if the connection history records have been loaded,
           * indicating that information needed to render the page is fully
           * loaded.
           *
           * @returns {Boolean}
           *     true if the history records have been loaded, false
           *     otherwise.
           *
           */
          $scope.isLoaded = function isLoaded() {
            return (
              $scope.historyEntryWrappers !== null && $scope.dateFormat !== null
            );
          };

          /**
           * Returns whether the search has completed but contains no history
           * records. This function will return false if there are history
           * records in the results OR if the search has not yet completed.
           *
           * @returns {Boolean}
           *     true if the search results have been loaded but no history
           *     records are present, false otherwise.
           */
          $scope.isHistoryEmpty = function isHistoryEmpty() {
            return (
              $scope.isLoaded() && $scope.historyEntryWrappers.length === 0
            );
          };

          /**
           * Query the API for the connection record history, filtered by
           * searchString, and ordered by order.
           */
          $scope.search = function search() {
            // Clear current results
            $scope.historyEntryWrappers = null;

            // Tokenize search string
            var tokens = FilterToken.tokenize($scope.searchString);

            // Transform tokens into list of required string contents
            var requiredContents = [];
            angular.forEach(tokens, function addRequiredContents(token) {
              // Transform depending on token type
              switch (token.type) {
                // For string literals, use parsed token value
                case "LITERAL":
                  requiredContents.push(token.value);

                // Ignore whitespace
                case "WHITESPACE":
                  break;

                // For all other token types, use the relevant portion
                // of the original search string
                default:
                  requiredContents.push(token.consumed);
              }
            });

            // Fetch history records
            historyService
              .getConnectionHistory(
                $scope.dataSource,
                requiredContents,
                $scope.order.predicate.filter(function isSupportedPredicate(
                  predicate
                ) {
                  return (
                    predicate === "startDate" || predicate === "-startDate"
                  );
                })
              )
              .then(function historyRetrieved(historyEntries) {
                // Wrap all history entries for sake of display
                $scope.historyEntryWrappers = [];
                angular.forEach(
                  historyEntries,
                  function wrapHistoryEntry(historyEntry) {
                    $scope.historyEntryWrappers.push(
                      new ConnectionHistoryEntryWrapper(historyEntry)
                    );
                  }
                );
              }, requestService.DIE);
          };

          /**
           * Initiates a download of a CSV version of the displayed history
           * search results.
           */
          $scope.downloadCSV = function downloadCSV() {
            // Translate CSV header
            $translate([
              "SETTINGS_CONNECTION_HISTORY.TABLE_HEADER_SESSION_USERNAME",
              "SETTINGS_CONNECTION_HISTORY.TABLE_HEADER_SESSION_STARTDATE",
              "SETTINGS_CONNECTION_HISTORY.TABLE_HEADER_SESSION_DURATION",
              "SETTINGS_CONNECTION_HISTORY.TABLE_HEADER_SESSION_CONNECTION_NAME",
              "SETTINGS_CONNECTION_HISTORY.TABLE_HEADER_SESSION_REMOTEHOST",
              "SETTINGS_CONNECTION_HISTORY.FILENAME_HISTORY_CSV",
            ]).then(function headerTranslated(translations) {
              // Initialize records with translated header row
              var records = [
                [
                  translations[
                    "SETTINGS_CONNECTION_HISTORY.TABLE_HEADER_SESSION_USERNAME"
                  ],
                  translations[
                    "SETTINGS_CONNECTION_HISTORY.TABLE_HEADER_SESSION_STARTDATE"
                  ],
                  translations[
                    "SETTINGS_CONNECTION_HISTORY.TABLE_HEADER_SESSION_DURATION"
                  ],
                  translations[
                    "SETTINGS_CONNECTION_HISTORY.TABLE_HEADER_SESSION_CONNECTION_NAME"
                  ],
                  translations[
                    "SETTINGS_CONNECTION_HISTORY.TABLE_HEADER_SESSION_REMOTEHOST"
                  ],
                ],
              ];

              // Add rows for all history entries, using the same sort
              // order as the displayed table
              angular.forEach(
                $filter("orderBy")(
                  $scope.historyEntryWrappers,
                  $scope.order.predicate
                ),
                function pushRecord(historyEntryWrapper) {
                  records.push([
                    historyEntryWrapper.username,
                    $filter("date")(
                      historyEntryWrapper.startDate,
                      $scope.dateFormat
                    ),
                    historyEntryWrapper.duration / 1000,
                    historyEntryWrapper.connectionName,
                    historyEntryWrapper.remoteHost,
                  ]);
                }
              );

              // Save the result
              saveAs(
                csvService.toBlob(records),
                translations["SETTINGS_CONNECTION_HISTORY.FILENAME_HISTORY_CSV"]
              );
            }, angular.noop);
          };

          // Initialize search results
          $scope.search();
        },
      ],
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive for managing all connections and connection groups in the system.
 */
angular.module("settings").directive("guacSettingsConnections", [
  function guacSettingsConnections() {
    return {
      // Element only
      restrict: "E",
      replace: true,

      scope: {},

      templateUrl: "app/settings/templates/settingsConnections.html",
      controller: [
        "$scope",
        "$injector",
        function settingsConnectionsController($scope, $injector) {
          // Required types
          var ConnectionGroup = $injector.get("ConnectionGroup");
          var GroupListItem = $injector.get("GroupListItem");
          var PermissionSet = $injector.get("PermissionSet");

          // Required services
          var $location = $injector.get("$location");
          var $routeParams = $injector.get("$routeParams");
          var authenticationService = $injector.get("authenticationService");
          var connectionGroupService = $injector.get("connectionGroupService");
          var dataSourceService = $injector.get("dataSourceService");
          var guacNotification = $injector.get("guacNotification");
          var permissionService = $injector.get("permissionService");
          var requestService = $injector.get("requestService");

          /**
           * The identifier of the current user.
           *
           * @type String
           */
          var currentUsername = authenticationService.getCurrentUsername();

          /**
           * The identifier of the currently-selected data source.
           *
           * @type String
           */
          $scope.dataSource = $routeParams.dataSource;

          /**
           * The root connection group of the connection group hierarchy.
           *
           * @type Object.<String, ConnectionGroup>
           */
          $scope.rootGroups = null;

          /**
           * All permissions associated with the current user, or null if the
           * user's permissions have not yet been loaded.
           *
           * @type PermissionSet
           */
          $scope.permissions = null;

          /**
           * Array of all connection properties that are filterable.
           *
           * @type String[]
           */
          $scope.filteredConnectionProperties = ["name", "protocol"];

          /**
           * Array of all connection group properties that are filterable.
           *
           * @type String[]
           */
          $scope.filteredConnectionGroupProperties = ["name"];

          /**
           * Returns whether critical data has completed being loaded.
           *
           * @returns {Boolean}
           *     true if enough data has been loaded for the user interface
           *     to be useful, false otherwise.
           */
          $scope.isLoaded = function isLoaded() {
            return $scope.rootGroup !== null && $scope.permissions !== null;
          };

          /**
           * Returns whether the current user can create new connections
           * within the current data source.
           *
           * @return {Boolean}
           *     true if the current user can create new connections within
           *     the current data source, false otherwise.
           */
          $scope.canCreateConnections = function canCreateConnections() {
            // Abort if permissions have not yet loaded
            if (!$scope.permissions) return false;

            // Can create connections if adminstrator or have explicit permission
            if (
              PermissionSet.hasSystemPermission(
                $scope.permissions,
                PermissionSet.SystemPermissionType.ADMINISTER
              ) ||
              PermissionSet.hasSystemPermission(
                $scope.permissions,
                PermissionSet.SystemPermissionType.CREATE_CONNECTION
              )
            )
              return true;

            // No data sources allow connection creation
            return false;
          };

          /**
           * Returns whether the current user can create new connection
           * groups within the current data source.
           *
           * @return {Boolean}
           *     true if the current user can create new connection groups
           *     within the current data source, false otherwise.
           */
          $scope.canCreateConnectionGroups =
            function canCreateConnectionGroups() {
              // Abort if permissions have not yet loaded
              if (!$scope.permissions) return false;

              // Can create connections groups if adminstrator or have explicit permission
              if (
                PermissionSet.hasSystemPermission(
                  $scope.permissions,
                  PermissionSet.SystemPermissionType.ADMINISTER
                ) ||
                PermissionSet.hasSystemPermission(
                  $scope.permissions,
                  PermissionSet.SystemPermissionType.CREATE_CONNECTION_GROUP
                )
              )
                return true;

              // No data sources allow connection group creation
              return false;
            };

          /**
           * Returns whether the current user can create new sharing profiles
           * within the current data source.
           *
           * @return {Boolean}
           *     true if the current user can create new sharing profiles
           *     within the current data source, false otherwise.
           */
          $scope.canCreateSharingProfiles =
            function canCreateSharingProfiles() {
              // Abort if permissions have not yet loaded
              if (!$scope.permissions) return false;

              // Can create sharing profiles if adminstrator or have explicit permission
              if (
                PermissionSet.hasSystemPermission(
                  $scope.permissions,
                  PermissionSet.SystemPermissionType.ADMINISTER
                ) ||
                PermissionSet.hasSystemPermission(
                  $scope.permissions,
                  PermissionSet.SystemPermissionType.CREATE_SHARING_PROFILE
                )
              )
                return true;

              // Current data source does not allow sharing profile creation
              return false;
            };

          /**
           * Returns whether the current user can create new connections or
           * connection groups or make changes to existing connections or
           * connection groups within the current data source. The
           * connection management interface as a whole is useless if this
           * function returns false.
           *
           * @return {Boolean}
           *     true if the current user can create new connections/groups
           *     or make changes to existing connections/groups within the
           *     current data source, false otherwise.
           */
          $scope.canManageConnections = function canManageConnections() {
            // Abort if permissions have not yet loaded
            if (!$scope.permissions) return false;

            // Creating connections/groups counts as management
            if (
              $scope.canCreateConnections() ||
              $scope.canCreateConnectionGroups() ||
              $scope.canCreateSharingProfiles()
            )
              return true;

            // Can manage connections if granted explicit update or delete
            if (
              PermissionSet.hasConnectionPermission(
                $scope.permissions,
                PermissionSet.ObjectPermissionType.UPDATE
              ) ||
              PermissionSet.hasConnectionPermission(
                $scope.permissions,
                PermissionSet.ObjectPermissionType.DELETE
              )
            )
              return true;

            // Can manage connections groups if granted explicit update or delete
            if (
              PermissionSet.hasConnectionGroupPermission(
                $scope.permissions,
                PermissionSet.ObjectPermissionType.UPDATE
              ) ||
              PermissionSet.hasConnectionGroupPermission(
                $scope.permissions,
                PermissionSet.ObjectPermissionType.DELETE
              )
            )
              return true;

            // No data sources allow management of connections or groups
            return false;
          };

          /**
           * Returns whether the current user can update the connection having
           * the given identifier within the current data source.
           *
           * @param {String} identifier
           *     The identifier of the connection to check.
           *
           * @return {Boolean}
           *     true if the current user can update the connection having the
           *     given identifier within the current data source, false
           *     otherwise.
           */
          $scope.canUpdateConnection = function canUpdateConnection(
            identifier
          ) {
            // Abort if permissions have not yet loaded
            if (!$scope.permissions) return false;

            // Can update the connection if adminstrator or have explicit permission
            if (
              PermissionSet.hasSystemPermission(
                $scope.permissions,
                PermissionSet.SystemPermissionType.ADMINISTER
              ) ||
              PermissionSet.hasConnectionPermission(
                $scope.permissions,
                PermissionSet.ObjectPermissionType.UPDATE,
                identifier
              )
            )
              return true;

            // Current data sources does not allow the connection to be updated
            return false;
          };

          /**
           * Returns whether the current user can update the connection group
           * having the given identifier within the current data source.
           *
           * @param {String} identifier
           *     The identifier of the connection group to check.
           *
           * @return {Boolean}
           *     true if the current user can update the connection group
           *     having the given identifier within the current data source,
           *     false otherwise.
           */
          $scope.canUpdateConnectionGroup = function canUpdateConnectionGroup(
            identifier
          ) {
            // Abort if permissions have not yet loaded
            if (!$scope.permissions) return false;

            // Can update the connection if adminstrator or have explicit permission
            if (
              PermissionSet.hasSystemPermission(
                $scope.permissions,
                PermissionSet.SystemPermissionType.ADMINISTER
              ) ||
              PermissionSet.hasConnectionGroupPermission(
                $scope.permissions,
                PermissionSet.ObjectPermissionType.UPDATE,
                identifier
              )
            )
              return true;

            // Current data sources does not allow the connection group to be updated
            return false;
          };

          /**
           * Adds connection-group-specific contextual actions to the given
           * array of GroupListItems. Each contextual action will be
           * represented by a new GroupListItem.
           *
           * @param {GroupListItem[]} items
           *     The array of GroupListItems to which new GroupListItems
           *     representing connection-group-specific contextual actions
           *     should be added.
           *
           * @param {GroupListItem} [parent]
           *     The GroupListItem representing the connection group which
           *     contains the given array of GroupListItems, if known.
           */
          var addConnectionGroupActions = function addConnectionGroupActions(
            items,
            parent
          ) {
            // Do nothing if we lack permission to modify the parent at all
            if (parent && !$scope.canUpdateConnectionGroup(parent.identifier))
              return;

            // Add action for creating a child connection, if the user has
            // permission to do so
            if ($scope.canCreateConnections())
              items.push(
                new GroupListItem({
                  type: "new-connection",
                  dataSource: $scope.dataSource,
                  weight: 1,
                  wrappedItem: parent,
                })
              );

            // Add action for creating a child connection group, if the user
            // has permission to do so
            if ($scope.canCreateConnectionGroups())
              items.push(
                new GroupListItem({
                  type: "new-connection-group",
                  dataSource: $scope.dataSource,
                  weight: 1,
                  wrappedItem: parent,
                })
              );
          };

          /**
           * Adds connection-specific contextual actions to the given array of
           * GroupListItems. Each contextual action will be represented by a
           * new GroupListItem.
           *
           * @param {GroupListItem[]} items
           *     The array of GroupListItems to which new GroupListItems
           *     representing connection-specific contextual actions should
           *     be added.
           *
           * @param {GroupListItem} [parent]
           *     The GroupListItem representing the connection which contains
           *     the given array of GroupListItems, if known.
           */
          var addConnectionActions = function addConnectionActions(
            items,
            parent
          ) {
            // Do nothing if we lack permission to modify the parent at all
            if (parent && !$scope.canUpdateConnection(parent.identifier))
              return;

            // Add action for creating a child sharing profile, if the user
            // has permission to do so
            if ($scope.canCreateSharingProfiles())
              items.push(
                new GroupListItem({
                  type: "new-sharing-profile",
                  dataSource: $scope.dataSource,
                  weight: 1,
                  wrappedItem: parent,
                })
              );
          };

          /**
           * Decorates the given GroupListItem, including all descendants,
           * adding contextual actions.
           *
           * @param {GroupListItem} item
           *     The GroupListItem which should be decorated with additional
           *     GroupListItems representing contextual actions.
           */
          var decorateItem = function decorateItem(item) {
            // If the item is a connection group, add actions specific to
            // connection groups
            if (item.type === GroupListItem.Type.CONNECTION_GROUP)
              addConnectionGroupActions(item.children, item);
            // If the item is a connection, add actions specific to
            // connections
            else if (item.type === GroupListItem.Type.CONNECTION)
              addConnectionActions(item.children, item);

            // Decorate all children
            angular.forEach(item.children, decorateItem);
          };

          /**
           * Callback which decorates all items within the given array of
           * GroupListItems, including their descendants, adding contextual
           * actions.
           *
           * @param {GroupListItem[]} items
           *     The array of GroupListItems which should be decorated with
           *     additional GroupListItems representing contextual actions.
           */
          $scope.rootItemDecorator = function rootItemDecorator(items) {
            // Decorate each root-level item
            angular.forEach(items, decorateItem);
          };

          // Retrieve current permissions
          permissionService
            .getEffectivePermissions($scope.dataSource, currentUsername)
            .then(function permissionsRetrieved(permissions) {
              // Store retrieved permissions
              $scope.permissions = permissions;

              // Ignore permission to update root group
              PermissionSet.removeConnectionGroupPermission(
                $scope.permissions,
                PermissionSet.ObjectPermissionType.UPDATE,
                ConnectionGroup.ROOT_IDENTIFIER
              );

              // Return to home if there's nothing to do here
              if (!$scope.canManageConnections()) $location.path("/");

              // Retrieve all connections for which we have UPDATE or DELETE permission
              dataSourceService
                .apply(
                  connectionGroupService.getConnectionGroupTree,
                  [$scope.dataSource],
                  ConnectionGroup.ROOT_IDENTIFIER,
                  [
                    PermissionSet.ObjectPermissionType.UPDATE,
                    PermissionSet.ObjectPermissionType.DELETE,
                  ]
                )
                .then(function connectionGroupsReceived(rootGroups) {
                  $scope.rootGroups = rootGroups;
                }, requestService.DIE);
            }, requestService.DIE); // end retrieve permissions
        },
      ],
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive for managing preferences local to the current user.
 */
angular.module("settings").directive("guacSettingsPreferences", [
  function guacSettingsPreferences() {
    return {
      // Element only
      restrict: "E",
      replace: true,

      scope: {},

      templateUrl: "app/settings/templates/settingsPreferences.html",
      controller: [
        "$scope",
        "$injector",
        function settingsPreferencesController($scope, $injector) {
          // Get required types
          var PermissionSet = $injector.get("PermissionSet");

          // Required services
          var $translate = $injector.get("$translate");
          var authenticationService = $injector.get("authenticationService");
          var guacNotification = $injector.get("guacNotification");
          var permissionService = $injector.get("permissionService");
          var preferenceService = $injector.get("preferenceService");
          var requestService = $injector.get("requestService");
          var userService = $injector.get("userService");

          /**
           * An action to be provided along with the object sent to
           * showStatus which closes the currently-shown status dialog.
           */
          var ACKNOWLEDGE_ACTION = {
            name: "SETTINGS_PREFERENCES.ACTION_ACKNOWLEDGE",
            // Handle action
            callback: function acknowledgeCallback() {
              guacNotification.showStatus(false);
            },
          };

          /**
           * The username of the current user.
           *
           * @type String
           */
          var username = authenticationService.getCurrentUsername();

          /**
           * The identifier of the data source which authenticated the
           * current user.
           *
           * @type String
           */
          var dataSource = authenticationService.getDataSource();

          /**
           * All currently-set preferences, or their defaults if not yet set.
           *
           * @type Object.<String, Object>
           */
          $scope.preferences = preferenceService.preferences;

          /**
           * The fields which should be displayed for choosing locale
           * preferences. Each field name must be a property on
           * $scope.preferences.
           *
           * @type Field[]
           */
          $scope.localeFields = [
            { type: "LANGUAGE", name: "language" },
            { type: "TIMEZONE", name: "timezone" },
          ];

          // Automatically update applied translation when language preference is changed
          $scope.$watch(
            "preferences.language",
            function changeLanguage(language) {
              $translate.use(language);
            }
          );

          /**
           * The new password for the user.
           *
           * @type String
           */
          $scope.newPassword = null;

          /**
           * The password match for the user. The update password action will
           * fail if $scope.newPassword !== $scope.passwordMatch.
           *
           * @type String
           */
          $scope.newPasswordMatch = null;

          /**
           * Whether the current user can change their own password, or null
           * if this is not yet known.
           *
           * @type Boolean
           */
          $scope.canChangePassword = null;

          /**
           * Update the current user's password to the password currently set within
           * the password change dialog.
           */
          $scope.updatePassword = function updatePassword() {
            // Verify passwords match
            if ($scope.newPasswordMatch !== $scope.newPassword) {
              guacNotification.showStatus({
                className: "error",
                title: "SETTINGS_PREFERENCES.DIALOG_HEADER_ERROR",
                text: {
                  key: "SETTINGS_PREFERENCES.ERROR_PASSWORD_MISMATCH",
                },
                actions: [ACKNOWLEDGE_ACTION],
              });
              return;
            }

            // Verify that the new password is not blank
            if (!$scope.newPassword) {
              guacNotification.showStatus({
                className: "error",
                title: "SETTINGS_PREFERENCES.DIALOG_HEADER_ERROR",
                text: {
                  key: "SETTINGS_PREFERENCES.ERROR_PASSWORD_BLANK",
                },
                actions: [ACKNOWLEDGE_ACTION],
              });
              return;
            }

            // Save the user with the new password
            userService
              .updateUserPassword(
                dataSource,
                username,
                $scope.oldPassword,
                $scope.newPassword
              )
              .then(function passwordUpdated() {
                // Clear the password fields
                $scope.oldPassword = null;
                $scope.newPassword = null;
                $scope.newPasswordMatch = null;

                // Indicate that the password has been changed
                guacNotification.showStatus({
                  text: {
                    key: "SETTINGS_PREFERENCES.INFO_PASSWORD_CHANGED",
                  },
                  actions: [ACKNOWLEDGE_ACTION],
                });
              }, guacNotification.SHOW_REQUEST_ERROR);
          };

          // Retrieve current permissions
          permissionService
            .getEffectivePermissions(dataSource, username)
            .then(function permissionsRetrieved(permissions) {
              // Add action for changing password if permission is granted
              $scope.canChangePassword = PermissionSet.hasUserPermission(
                permissions,
                PermissionSet.ObjectPermissionType.UPDATE,
                username
              );
            })
            ["catch"](
              requestService.createErrorCallback(function permissionsFailed(
                error
              ) {
                $scope.canChangePassword = false;
              })
            );

          /**
           * Returns whether critical data has completed being loaded.
           *
           * @returns {Boolean}
           *     true if enough data has been loaded for the user interface to be
           *     useful, false otherwise.
           */
          $scope.isLoaded = function isLoaded() {
            return (
              $scope.canChangePassword !== null && $scope.languages !== null
            );
          };
        },
      ],
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive for managing all active Guacamole sessions.
 */
angular.module("settings").directive("guacSettingsSessions", [
  function guacSettingsSessions() {
    return {
      // Element only
      restrict: "E",
      replace: true,

      scope: {},

      templateUrl: "app/settings/templates/settingsSessions.html",
      controller: [
        "$scope",
        "$injector",
        function settingsSessionsController($scope, $injector) {
          // Required types
          var ActiveConnectionWrapper = $injector.get(
            "ActiveConnectionWrapper"
          );
          var ClientIdentifier = $injector.get("ClientIdentifier");
          var ConnectionGroup = $injector.get("ConnectionGroup");
          var SortOrder = $injector.get("SortOrder");

          // Required services
          var $filter = $injector.get("$filter");
          var $translate = $injector.get("$translate");
          var $q = $injector.get("$q");
          var activeConnectionService = $injector.get(
            "activeConnectionService"
          );
          var authenticationService = $injector.get("authenticationService");
          var connectionGroupService = $injector.get("connectionGroupService");
          var dataSourceService = $injector.get("dataSourceService");
          var guacNotification = $injector.get("guacNotification");
          var requestService = $injector.get("requestService");

          /**
           * The identifiers of all data sources accessible by the current
           * user.
           *
           * @type String[]
           */
          var dataSources = authenticationService.getAvailableDataSources();

          /**
           * The ActiveConnectionWrappers of all active sessions accessible
           * by the current user, or null if the active sessions have not yet
           * been loaded.
           *
           * @type ActiveConnectionWrapper[]
           */
          $scope.wrappers = null;

          /**
           * SortOrder instance which maintains the sort order of the visible
           * connection wrappers.
           *
           * @type SortOrder
           */
          $scope.wrapperOrder = new SortOrder([
            "activeConnection.username",
            "startDate",
            "activeConnection.remoteHost",
            "name",
          ]);

          /**
           * Array of all wrapper properties that are filterable.
           *
           * @type String[]
           */
          $scope.filteredWrapperProperties = [
            "activeConnection.username",
            "startDate",
            "activeConnection.remoteHost",
            "name",
          ];

          /**
           * All active connections, if known, grouped by corresponding data
           * source identifier, or null if active connections have not yet
           * been loaded.
           *
           * @type Object.<String, Object.<String, ActiveConnection>>
           */
          var allActiveConnections = null;

          /**
           * Map of all visible connections by data source identifier and
           * object identifier, or null if visible connections have not yet
           * been loaded.
           *
           * @type Object.<String, Object.<String, Connection>>
           */
          var allConnections = null;

          /**
           * The date format for use for session-related dates.
           *
           * @type String
           */
          var sessionDateFormat = null;

          /**
           * Map of all currently-selected active connection wrappers by
           * data source and identifier.
           *
           * @type Object.<String, Object.<String, ActiveConnectionWrapper>>
           */
          var allSelectedWrappers = {};

          /**
           * Adds the given connection to the internal set of visible
           * connections.
           *
           * @param {String} dataSource
           *     The identifier of the data source associated with the given
           *     connection.
           *
           * @param {Connection} connection
           *     The connection to add to the internal set of visible
           *     connections.
           */
          var addConnection = function addConnection(dataSource, connection) {
            // Add given connection to set of visible connections
            allConnections[dataSource][connection.identifier] = connection;
          };

          /**
           * Adds all descendant connections of the given connection group to
           * the internal set of connections.
           *
           * @param {String} dataSource
           *     The identifier of the data source associated with the given
           *     connection group.
           *
           * @param {ConnectionGroup} connectionGroup
           *     The connection group whose descendant connections should be
           *     added to the internal set of connections.
           */
          var addDescendantConnections = function addDescendantConnections(
            dataSource,
            connectionGroup
          ) {
            // Add all child connections
            angular.forEach(
              connectionGroup.childConnections,
              function addConnectionForDataSource(connection) {
                addConnection(dataSource, connection);
              }
            );

            // Add all child connection groups
            angular.forEach(
              connectionGroup.childConnectionGroups,
              function addConnectionGroupForDataSource(connectionGroup) {
                addDescendantConnections(dataSource, connectionGroup);
              }
            );
          };

          /**
           * Wraps all loaded active connections, storing the resulting array
           * within the scope. If required data has not yet finished loading,
           * this function has no effect.
           */
          var wrapAllActiveConnections = function wrapAllActiveConnections() {
            // Abort if not all required data is available
            if (!allActiveConnections || !allConnections || !sessionDateFormat)
              return;

            // Wrap all active connections for sake of display
            $scope.wrappers = [];
            angular.forEach(
              allActiveConnections,
              function wrapActiveConnections(activeConnections, dataSource) {
                angular.forEach(
                  activeConnections,
                  function wrapActiveConnection(activeConnection, identifier) {
                    // Retrieve corresponding connection
                    var connection =
                      allConnections[dataSource][
                        activeConnection.connectionIdentifier
                      ];

                    // Add wrapper
                    if (activeConnection.username !== null) {
                      $scope.wrappers.push(
                        new ActiveConnectionWrapper({
                          dataSource: dataSource,
                          name: connection.name,
                          startDate: $filter("date")(
                            activeConnection.startDate,
                            sessionDateFormat
                          ),
                          activeConnection: activeConnection,
                        })
                      );
                    }
                  }
                );
              }
            );
          };

          // Retrieve all connections
          dataSourceService
            .apply(
              connectionGroupService.getConnectionGroupTree,
              dataSources,
              ConnectionGroup.ROOT_IDENTIFIER
            )
            .then(function connectionGroupsReceived(rootGroups) {
              allConnections = {};

              // Load connections from each received root group
              angular.forEach(
                rootGroups,
                function connectionGroupReceived(rootGroup, dataSource) {
                  allConnections[dataSource] = {};
                  addDescendantConnections(dataSource, rootGroup);
                }
              );

              // Attempt to produce wrapped list of active connections
              wrapAllActiveConnections();
            }, requestService.DIE);

          // Query active sessions
          dataSourceService
            .apply(activeConnectionService.getActiveConnections, dataSources)
            .then(function sessionsRetrieved(retrievedActiveConnections) {
              // Store received map of active connections
              allActiveConnections = retrievedActiveConnections;

              // Attempt to produce wrapped list of active connections
              wrapAllActiveConnections();
            }, requestService.DIE);

          // Get session date format
          $translate("SETTINGS_SESSIONS.FORMAT_STARTDATE").then(
            function sessionDateFormatReceived(retrievedSessionDateFormat) {
              // Store received date format
              sessionDateFormat = retrievedSessionDateFormat;

              // Attempt to produce wrapped list of active connections
              wrapAllActiveConnections();
            },
            angular.noop
          );

          /**
           * Returns whether critical data has completed being loaded.
           *
           * @returns {Boolean}
           *     true if enough data has been loaded for the user interface
           *     to be useful, false otherwise.
           */
          $scope.isLoaded = function isLoaded() {
            return $scope.wrappers !== null;
          };

          /**
           * An action to be provided along with the object sent to
           * showStatus which closes the currently-shown status dialog.
           */
          var CANCEL_ACTION = {
            name: "SETTINGS_SESSIONS.ACTION_CANCEL",
            // Handle action
            callback: function cancelCallback() {
              guacNotification.showStatus(false);
            },
          };

          /**
           * An action to be provided along with the object sent to
           * showStatus which immediately deletes the currently selected
           * sessions.
           */
          var DELETE_ACTION = {
            name: "SETTINGS_SESSIONS.ACTION_DELETE",
            className: "danger",
            // Handle action
            callback: function deleteCallback() {
              deleteAllSessionsImmediately();
              guacNotification.showStatus(false);
            },
          };

          /**
           * Immediately deletes the selected sessions, without prompting the
           * user for confirmation.
           */
          var deleteAllSessionsImmediately =
            function deleteAllSessionsImmediately() {
              var deletionRequests = [];

              // Perform deletion for each relevant data source
              angular.forEach(
                allSelectedWrappers,
                function deleteSessionsImmediately(
                  selectedWrappers,
                  dataSource
                ) {
                  // Delete sessions, if any are selected
                  var identifiers = Object.keys(selectedWrappers);
                  if (identifiers.length)
                    deletionRequests.push(
                      activeConnectionService.deleteActiveConnections(
                        dataSource,
                        identifiers
                      )
                    );
                }
              );

              // Update interface
              $q.all(deletionRequests).then(
                function activeConnectionsDeleted() {
                  // Remove deleted connections from wrapper array
                  $scope.wrappers = $scope.wrappers.filter(
                    function activeConnectionStillExists(wrapper) {
                      return !(
                        wrapper.activeConnection.identifier in
                        (allSelectedWrappers[wrapper.dataSource] || {})
                      );
                    }
                  );

                  // Clear selection
                  allSelectedWrappers = {};
                },
                guacNotification.SHOW_REQUEST_ERROR
              );
            };

          /**
           * Delete all selected sessions, prompting the user first to
           * confirm that deletion is desired.
           */
          $scope.deleteSessions = function deleteSessions() {
            // Confirm deletion request
            guacNotification.showStatus({
              title: "SETTINGS_SESSIONS.DIALOG_HEADER_CONFIRM_DELETE",
              text: {
                key: "SETTINGS_SESSIONS.TEXT_CONFIRM_DELETE",
              },
              actions: [DELETE_ACTION, CANCEL_ACTION],
            });
          };

          /**
           * Returns the relative URL of the client page which accesses the
           * given active connection. If the active connection is not
           * connectable, null is returned.
           *
           * @param {String} dataSource
           *     The unique identifier of the data source containing the
           *     active connection.
           *
           * @param {String} activeConnection
           *     The active connection to determine the relative URL of.
           *
           * @returns {String}
           *     The relative URL of the client page which accesses the given
           *     active connection, or null if the active connection is not
           *     connectable.
           */
          $scope.getClientURL = function getClientURL(
            dataSource,
            activeConnection
          ) {
            if (!activeConnection.connectable) return null;

            return (
              "#/client/" +
              encodeURIComponent(
                ClientIdentifier.toString({
                  dataSource: dataSource,
                  type: ClientIdentifier.Types.ACTIVE_CONNECTION,
                  id: activeConnection.identifier,
                })
              )
            );
          };

          /**
           * Returns whether the selected sessions can be deleted.
           *
           * @returns {Boolean}
           *     true if selected sessions can be deleted, false otherwise.
           */
          $scope.canDeleteSessions = function canDeleteSessions() {
            // We can delete sessions if at least one is selected
            for (var dataSource in allSelectedWrappers) {
              for (var identifier in allSelectedWrappers[dataSource])
                return true;
            }

            return false;
          };

          /**
           * Called whenever an active connection wrapper changes selected
           * status.
           *
           * @param {ActiveConnectionWrapper} wrapper
           *     The wrapper whose selected status has changed.
           */
          $scope.wrapperSelectionChange = function wrapperSelectionChange(
            wrapper
          ) {
            // Get selection map for associated data source, creating if necessary
            var selectedWrappers = allSelectedWrappers[wrapper.dataSource];
            if (!selectedWrappers)
              selectedWrappers = allSelectedWrappers[wrapper.dataSource] = {};

            // Add wrapper to map if selected
            if (wrapper.checked)
              selectedWrappers[wrapper.activeConnection.identifier] = wrapper;
            // Otherwise, remove wrapper from map
            else delete selectedWrappers[wrapper.activeConnection.identifier];
          };
        },
      ],
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive for managing all user groups in the system.
 */
angular.module("settings").directive("guacSettingsUserGroups", [
  "$injector",
  function guacSettingsUserGroups($injector) {
    // Required types
    var ManageableUserGroup = $injector.get("ManageableUserGroup");
    var PermissionSet = $injector.get("PermissionSet");
    var SortOrder = $injector.get("SortOrder");

    // Required services
    var $location = $injector.get("$location");
    var authenticationService = $injector.get("authenticationService");
    var dataSourceService = $injector.get("dataSourceService");
    var permissionService = $injector.get("permissionService");
    var requestService = $injector.get("requestService");
    var userGroupService = $injector.get("userGroupService");

    var directive = {
      restrict: "E",
      replace: true,
      templateUrl: "app/settings/templates/settingsUserGroups.html",
      scope: {},
    };

    directive.controller = [
      "$scope",
      function settingsUserGroupsController($scope) {
        // Identifier of the current user
        var currentUsername = authenticationService.getCurrentUsername();

        /**
         * The identifiers of all data sources accessible by the current
         * user.
         *
         * @type String[]
         */
        var dataSources = authenticationService.getAvailableDataSources();

        /**
         * Map of data source identifiers to all permissions associated
         * with the current user within that data source, or null if the
         * user's permissions have not yet been loaded.
         *
         * @type Object.<String, PermissionSet>
         */
        var permissions = null;

        /**
         * All visible user groups, along with their corresponding data
         * sources.
         *
         * @type ManageableUserGroup[]
         */
        $scope.manageableUserGroups = null;

        /**
         * Array of all user group properties that are filterable.
         *
         * @type String[]
         */
        $scope.filteredUserGroupProperties = ["userGroup.identifier"];

        /**
         * SortOrder instance which stores the sort order of the listed
         * user groups.
         *
         * @type SortOrder
         */
        $scope.order = new SortOrder(["userGroup.identifier"]);

        /**
         * Returns whether critical data has completed being loaded.
         *
         * @returns {Boolean}
         *     true if enough data has been loaded for the user group
         *     interface to be useful, false otherwise.
         */
        $scope.isLoaded = function isLoaded() {
          return $scope.manageableUserGroups !== null;
        };

        /**
         * Returns the identifier of the data source that should be used by
         * default when creating a new user group.
         *
         * @return {String}
         *     The identifier of the data source that should be used by
         *     default when creating a new user group, or null if user group
         *     creation is not allowed.
         */
        $scope.getDefaultDataSource = function getDefaultDataSource() {
          // Abort if permissions have not yet loaded
          if (!permissions) return null;

          // For each data source
          var dataSources = _.keys(permissions).sort();
          for (var i = 0; i < dataSources.length; i++) {
            // Retrieve corresponding permission set
            var dataSource = dataSources[i];
            var permissionSet = permissions[dataSource];

            // Can create user groups if adminstrator or have explicit permission
            if (
              PermissionSet.hasSystemPermission(
                permissionSet,
                PermissionSet.SystemPermissionType.ADMINISTER
              ) ||
              PermissionSet.hasSystemPermission(
                permissionSet,
                PermissionSet.SystemPermissionType.CREATE_USER_GROUP
              )
            )
              return dataSource;
          }

          // No data sources allow user group creation
          return null;
        };

        /**
         * Returns whether the current user can create new user groups
         * within at least one data source.
         *
         * @return {Boolean}
         *     true if the current user can create new user groups within at
         *     least one data source, false otherwise.
         */
        $scope.canCreateUserGroups = function canCreateUserGroups() {
          return $scope.getDefaultDataSource() !== null;
        };

        /**
         * Returns whether the current user can create new user groups or
         * make changes to existing user groups within at least one data
         * source. The user group management interface as a whole is useless
         * if this function returns false.
         *
         * @return {Boolean}
         *     true if the current user can create new user groups or make
         *     changes to existing user groups within at least one data
         *     source, false otherwise.
         */
        var canManageUserGroups = function canManageUserGroups() {
          // Abort if permissions have not yet loaded
          if (!permissions) return false;

          // Creating user groups counts as management
          if ($scope.canCreateUserGroups()) return true;

          // For each data source
          for (var dataSource in permissions) {
            // Retrieve corresponding permission set
            var permissionSet = permissions[dataSource];

            // Can manage user groups if granted explicit update or delete
            if (
              PermissionSet.hasUserGroupPermission(
                permissionSet,
                PermissionSet.ObjectPermissionType.UPDATE
              ) ||
              PermissionSet.hasUserGroupPermission(
                permissionSet,
                PermissionSet.ObjectPermissionType.DELETE
              )
            )
              return true;
          }

          // No data sources allow management of user groups
          return false;
        };

        /**
         * Sets the displayed list of user groups. If any user groups are
         * already shown within the interface, those user groups are replaced
         * with the given user groups.
         *
         * @param {Object.<String, PermissionSet>} permissions
         *     A map of data source identifiers to all permissions associated
         *     with the current user within that data source.
         *
         * @param {Object.<String, Object.<String, UserGroup>>} userGroups
         *     A map of all user groups which should be displayed, where each
         *     key is the data source identifier from which the user groups
         *     were retrieved and each value is a map of user group identifiers
         *     to their corresponding @link{UserGroup} objects.
         */
        var setDisplayedUserGroups = function setDisplayedUserGroups(
          permissions,
          userGroups
        ) {
          var addedUserGroups = {};
          $scope.manageableUserGroups = [];

          // For each user group in each data source
          angular.forEach(dataSources, function addUserGroupList(dataSource) {
            angular.forEach(
              userGroups[dataSource],
              function addUserGroup(userGroup) {
                // Do not add the same user group twice
                if (addedUserGroups[userGroup.identifier]) return;

                // Link to default creation data source if we cannot manage this user
                if (
                  !PermissionSet.hasSystemPermission(
                    permissions[dataSource],
                    PermissionSet.ObjectPermissionType.ADMINISTER
                  ) &&
                  !PermissionSet.hasUserGroupPermission(
                    permissions[dataSource],
                    PermissionSet.ObjectPermissionType.UPDATE,
                    userGroup.identifier
                  ) &&
                  !PermissionSet.hasUserGroupPermission(
                    permissions[dataSource],
                    PermissionSet.ObjectPermissionType.DELETE,
                    userGroup.identifier
                  )
                )
                  dataSource = $scope.getDefaultDataSource();

                // Add user group to overall list
                addedUserGroups[userGroup.identifier] = userGroup;
                $scope.manageableUserGroups.push(
                  new ManageableUserGroup({
                    dataSource: dataSource,
                    userGroup: userGroup,
                  })
                );
              }
            );
          });
        };

        // Retrieve current permissions
        dataSourceService
          .apply(
            permissionService.getEffectivePermissions,
            dataSources,
            currentUsername
          )
          .then(function permissionsRetrieved(retrievedPermissions) {
            // Store retrieved permissions
            permissions = retrievedPermissions;

            // Return to home if there's nothing to do here
            if (!canManageUserGroups()) $location.path("/");

            // If user groups can be created, list all readable user groups
            if ($scope.canCreateUserGroups())
              return dataSourceService.apply(
                userGroupService.getUserGroups,
                dataSources
              );

            // Otherwise, list only updateable/deletable users
            return dataSourceService.apply(
              userGroupService.getUserGroups,
              dataSources,
              [
                PermissionSet.ObjectPermissionType.UPDATE,
                PermissionSet.ObjectPermissionType.DELETE,
              ]
            );
          })
          .then(function userGroupsReceived(userGroups) {
            setDisplayedUserGroups(permissions, userGroups);
          }, requestService.WARN);
      },
    ];

    return directive;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive for managing all users in the system.
 */
angular.module("settings").directive("guacSettingsUsers", [
  function guacSettingsUsers() {
    return {
      // Element only
      restrict: "E",
      replace: true,

      scope: {},

      templateUrl: "app/settings/templates/settingsUsers.html",
      controller: [
        "$scope",
        "$injector",
        function settingsUsersController($scope, $injector) {
          // Required types
          var ManageableUser = $injector.get("ManageableUser");
          var PermissionSet = $injector.get("PermissionSet");
          var SortOrder = $injector.get("SortOrder");

          // Required services
          var $location = $injector.get("$location");
          var $translate = $injector.get("$translate");
          var authenticationService = $injector.get("authenticationService");
          var dataSourceService = $injector.get("dataSourceService");
          var permissionService = $injector.get("permissionService");
          var requestService = $injector.get("requestService");
          var userService = $injector.get("userService");

          // Identifier of the current user
          var currentUsername = authenticationService.getCurrentUsername();

          /**
           * The identifiers of all data sources accessible by the current
           * user.
           *
           * @type String[]
           */
          var dataSources = authenticationService.getAvailableDataSources();

          /**
           * All visible users, along with their corresponding data sources.
           *
           * @type ManageableUser[]
           */
          $scope.manageableUsers = null;

          /**
           * The name of the new user to create, if any, when user creation
           * is requested via newUser().
           *
           * @type String
           */
          $scope.newUsername = "";

          /**
           * Map of data source identifiers to all permissions associated
           * with the current user within that data source, or null if the
           * user's permissions have not yet been loaded.
           *
           * @type Object.<String, PermissionSet>
           */
          $scope.permissions = null;

          /**
           * Array of all user properties that are filterable.
           *
           * @type String[]
           */
          $scope.filteredUserProperties = [
            'user.attributes["guac-full-name"]',
            'user.attributes["guac-organization"]',
            "user.lastActive",
            "user.username",
          ];

          /**
           * The date format for use for the last active date.
           *
           * @type String
           */
          $scope.dateFormat = null;

          /**
           * SortOrder instance which stores the sort order of the listed
           * users.
           *
           * @type SortOrder
           */
          $scope.order = new SortOrder([
            "user.username",
            "-user.lastActive",
            'user.attributes["guac-organization"]',
            'user.attributes["guac-full-name"]',
          ]);

          // Get session date format
          $translate("SETTINGS_USERS.FORMAT_DATE").then(
            function dateFormatReceived(retrievedDateFormat) {
              // Store received date format
              $scope.dateFormat = retrievedDateFormat;
            },
            angular.noop
          );

          /**
           * Returns whether critical data has completed being loaded.
           *
           * @returns {Boolean}
           *     true if enough data has been loaded for the user interface
           *     to be useful, false otherwise.
           */
          $scope.isLoaded = function isLoaded() {
            return (
              $scope.dateFormat !== null &&
              $scope.manageableUsers !== null &&
              $scope.permissions !== null
            );
          };

          /**
           * Returns the identifier of the data source that should be used by
           * default when creating a new user.
           *
           * @return {String}
           *     The identifier of the data source that should be used by
           *     default when creating a new user, or null if user creation
           *     is not allowed.
           */
          $scope.getDefaultDataSource = function getDefaultDataSource() {
            // Abort if permissions have not yet loaded
            if (!$scope.permissions) return null;

            // For each data source
            var dataSources = _.keys($scope.permissions).sort();
            for (var i = 0; i < dataSources.length; i++) {
              // Retrieve corresponding permission set
              var dataSource = dataSources[i];
              var permissionSet = $scope.permissions[dataSource];

              // Can create users if adminstrator or have explicit permission
              if (
                PermissionSet.hasSystemPermission(
                  permissionSet,
                  PermissionSet.SystemPermissionType.ADMINISTER
                ) ||
                PermissionSet.hasSystemPermission(
                  permissionSet,
                  PermissionSet.SystemPermissionType.CREATE_USER
                )
              )
                return dataSource;
            }

            // No data sources allow user creation
            return null;
          };

          /**
           * Returns whether the current user can create new users within at
           * least one data source.
           *
           * @return {Boolean}
           *     true if the current user can create new users within at
           *     least one data source, false otherwise.
           */
          $scope.canCreateUsers = function canCreateUsers() {
            return $scope.getDefaultDataSource() !== null;
          };

          /**
           * Returns whether the current user can create new users or make
           * changes to existing users within at least one data source. The
           * user management interface as a whole is useless if this function
           * returns false.
           *
           * @return {Boolean}
           *     true if the current user can create new users or make
           *     changes to existing users within at least one data source,
           *     false otherwise.
           */
          var canManageUsers = function canManageUsers() {
            // Abort if permissions have not yet loaded
            if (!$scope.permissions) return false;

            // Creating users counts as management
            if ($scope.canCreateUsers()) return true;

            // For each data source
            for (var dataSource in $scope.permissions) {
              // Retrieve corresponding permission set
              var permissionSet = $scope.permissions[dataSource];

              // Can manage users if granted explicit update or delete
              if (
                PermissionSet.hasUserPermission(
                  permissionSet,
                  PermissionSet.ObjectPermissionType.UPDATE
                ) ||
                PermissionSet.hasUserPermission(
                  permissionSet,
                  PermissionSet.ObjectPermissionType.DELETE
                )
              )
                return true;
            }

            // No data sources allow management of users
            return false;
          };

          // Retrieve current permissions
          dataSourceService
            .apply(
              permissionService.getEffectivePermissions,
              dataSources,
              currentUsername
            )
            .then(function permissionsRetrieved(permissions) {
              // Store retrieved permissions
              $scope.permissions = permissions;

              // Return to home if there's nothing to do here
              if (!canManageUsers()) $location.path("/");

              var userPromise;

              // If users can be created, list all readable users
              if ($scope.canCreateUsers())
                userPromise = dataSourceService.apply(
                  userService.getUsers,
                  dataSources
                );
              // Otherwise, list only updateable/deletable users
              else
                userPromise = dataSourceService.apply(
                  userService.getUsers,
                  dataSources,
                  [
                    PermissionSet.ObjectPermissionType.UPDATE,
                    PermissionSet.ObjectPermissionType.DELETE,
                  ]
                );

              userPromise.then(function usersReceived(allUsers) {
                var addedUsers = {};
                $scope.manageableUsers = [];

                // For each user in each data source
                angular.forEach(dataSources, function addUserList(dataSource) {
                  angular.forEach(allUsers[dataSource], function addUser(user) {
                    // Do not add the same user twice
                    if (addedUsers[user.username]) return;

                    // Link to default creation data source if we cannot manage this user
                    if (
                      !PermissionSet.hasSystemPermission(
                        permissions[dataSource],
                        PermissionSet.ObjectPermissionType.ADMINISTER
                      ) &&
                      !PermissionSet.hasUserPermission(
                        permissions[dataSource],
                        PermissionSet.ObjectPermissionType.UPDATE,
                        user.username
                      ) &&
                      !PermissionSet.hasUserPermission(
                        permissions[dataSource],
                        PermissionSet.ObjectPermissionType.DELETE,
                        user.username
                      )
                    )
                      dataSource = $scope.getDefaultDataSource();

                    // Add user to overall list
                    addedUsers[user.username] = user;
                    $scope.manageableUsers.push(
                      new ManageableUser({
                        dataSource: dataSource,
                        user: user,
                      })
                    );
                  });
                });
              }, requestService.DIE);
            }, requestService.DIE);
        },
      ],
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for generating downloadable CSV links given arbitrary data.
 */
angular.module("settings").factory("csvService", [
  function csvService() {
    var service = {};

    /**
     * Encodes an arbitrary value for inclusion in a CSV file as an individual
     * field. With the exception of null and undefined (which are both
     * interpreted as equivalent to an empty string), all values are coerced to
     * a string and, if non-numeric, included within double quotes. If the
     * value itself includes double quotes, those quotes will be properly
     * escaped.
     *
     * @param {*} field
     *     The arbitrary value to encode.
     *
     * @return {String}
     *     The provided value, coerced to a string and properly escaped for
     *     CSV.
     */
    var encodeField = function encodeField(field) {
      // Coerce field to string
      if (field === null || field === undefined) field = "";
      else field = "" + field;

      // Do not quote numeric fields
      if (/^[0-9.]*$/.test(field)) return field;

      // Enclose all other fields in quotes, escaping any quotes therein
      return '"' + field.replace(/"/g, '""') + '"';
    };

    /**
     * Encodes each of the provided values for inclusion in a CSV file as
     * fields within the same record (in the manner specified by
     * encodeField()), separated by commas.
     *
     * @param {*[]} fields
     *     An array of arbitrary values which make up the record.
     *
     * @return {String}
     *     A CSV record containing the each value in the given array.
     */
    var encodeRecord = function encodeRecord(fields) {
      return fields.map(encodeField).join(",");
    };

    /**
     * Encodes an entire array of records as properly-formatted CSV, where each
     * entry in the provided array is an array of arbitrary fields.
     *
     * @param {Array.<*[]>} records
     *     An array of all records making up the desired CSV.
     *
     * @return {String}
     *     An entire CSV containing each provided record, separated by CR+LF
     *     line terminators.
     */
    var encodeCSV = function encodeCSV(records) {
      return records.map(encodeRecord).join("\r\n");
    };

    /**
     * Creates a new Blob containing properly-formatted CSV generated from the
     * given array of records, where each entry in the provided array is an
     * array of arbitrary fields.
     *
     * @param {Array.<*[]>} records
     *     An array of all records making up the desired CSV.
     *
     * @returns {Blob}
     *     A new Blob containing each provided record in CSV format.
     */
    service.toBlob = function toBlob(records) {
      return new Blob([encodeCSV(records)], { type: "text/csv" });
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for setting and retrieving browser-local preferences. Preferences
 * may be any JSON-serializable type.
 */
angular.module("settings").provider("preferenceService", [
  "$injector",
  function preferenceServiceProvider($injector) {
    // Required providers
    var localStorageServiceProvider = $injector.get(
      "localStorageServiceProvider"
    );

    /**
     * Reference to the provider itself.
     *
     * @type preferenceServiceProvider
     */
    var provider = this;

    /**
     * The storage key of Guacamole preferences within local storage.
     *
     * @type String
     */
    var GUAC_PREFERENCES_STORAGE_KEY = "GUAC_PREFERENCES";

    /**
     * All valid input method type names.
     *
     * @type Object.<String, String>
     */
    var inputMethods = {
      /**
       * No input method is used. Keyboard events are generated from a
       * physical keyboard.
       *
       * @constant
       * @type String
       */
      NONE: "none",

      /**
       * Keyboard events will be generated from the Guacamole on-screen
       * keyboard.
       *
       * @constant
       * @type String
       */
      OSK: "osk",

      /**
       * Keyboard events will be generated by inferring the keys necessary to
       * produce typed text from an IME (Input Method Editor) such as the
       * native on-screen keyboard of a mobile device.
       *
       * @constant
       * @type String
       */
      TEXT: "text",
    };

    /**
     * Returns the key of the language currently in use within the browser.
     * This is not necessarily the user's desired language, but is rather the
     * language user by the browser's interface.
     *
     * @returns {String}
     *     The key of the language currently in use within the browser.
     */
    var getDefaultLanguageKey = function getDefaultLanguageKey() {
      // Pull browser language, falling back to US English
      var language =
        (navigator.languages && navigator.languages[0]) ||
        navigator.language ||
        navigator.browserLanguage ||
        "en";

      // Convert to format used internally
      return language.replace(/-/g, "_");
    };

    /**
     * Return the timezone detected for the current browser session
     * by the JSTZ timezone library.
     *
     * @returns String
     *     The name of the currently-detected timezone in IANA zone key
     *     format (Olson time zone database).
     */
    var getDetectedTimezone = function getDetectedTimezone() {
      return jstz.determine().name();
    };

    /**
     * All currently-set preferences, as name/value pairs. Each property name
     * corresponds to the name of a preference.
     *
     * @type Object.<String, Object>
     */
    this.preferences = {
      /**
       * Whether translation of touch to mouse events should emulate an
       * absolute pointer device, or a relative pointer device.
       *
       * @type Boolean
       */
      emulateAbsoluteMouse: true,

      /**
       * The default input method. This may be any of the values defined
       * within preferenceService.inputMethods.
       *
       * @type String
       */
      inputMethod: inputMethods.NONE,

      /**
       * The key of the desired display language.
       *
       * @type String
       */
      language: getDefaultLanguageKey(),

      /**
       * The timezone set by the user, in IANA zone key format (Olson time
       * zone database).
       *
       * @type String
       */
      timezone: getDetectedTimezone(),
    };

    // Get stored preferences from localStorage
    var storedPreferences = localStorageServiceProvider.getItem(
      GUAC_PREFERENCES_STORAGE_KEY
    );
    if (storedPreferences)
      angular.extend(provider.preferences, storedPreferences);

    // Factory method required by provider
    this.$get = [
      "$injector",
      function preferenceServiceFactory($injector) {
        // Required services
        var $rootScope = $injector.get("$rootScope");
        var $window = $injector.get("$window");
        var localStorageService = $injector.get("localStorageService");

        var service = {};

        /**
         * All valid input method type names.
         *
         * @type Object.<String, String>
         */
        service.inputMethods = inputMethods;

        /**
         * All currently-set preferences, as name/value pairs. Each property name
         * corresponds to the name of a preference.
         *
         * @type Object.<String, Object>
         */
        service.preferences = provider.preferences;

        /**
         * Persists the current values of all preferences, if possible.
         */
        service.save = function save() {
          localStorageService.setItem(
            GUAC_PREFERENCES_STORAGE_KEY,
            service.preferences
          );
        };

        // Persist settings when window is unloaded
        $window.addEventListener("unload", service.save);

        // Persist settings upon navigation
        $rootScope.$on("$routeChangeSuccess", function handleNavigate() {
          service.save();
        });

        // Persist settings upon logout
        $rootScope.$on("guacLogout", function handleLogout() {
          service.save();
        });

        return service;
      },
    ];
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The module for manipulation of general settings. This is distinct from the
 * "manage" module, which deals only with administrator-level system management.
 */
angular.module("settings", [
  "groupList",
  "list",
  "navigation",
  "notification",
  "rest",
  "storage",
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for defining the ActiveConnectionWrapper class.
 */
angular.module("settings").factory("ActiveConnectionWrapper", [
  function defineActiveConnectionWrapper() {
    /**
     * Wrapper for ActiveConnection which adds display-specific
     * properties, such as a checked option.
     *
     * @constructor
     * @param {ActiveConnectionWrapper|Object} template
     *     The object whose properties should be copied within the new
     *     ActiveConnectionWrapper.
     */
    var ActiveConnectionWrapper = function ActiveConnectionWrapper(template) {
      /**
       * The identifier of the data source associated with the
       * ActiveConnection wrapped by this ActiveConnectionWrapper.
       *
       * @type String
       */
      this.dataSource = template.dataSource;

      /**
       * The display name of this connection.
       *
       * @type String
       */
      this.name = template.name;

      /**
       * The date and time this session began, pre-formatted for display.
       *
       * @type String
       */
      this.startDate = template.startDate;

      /**
       * The wrapped ActiveConnection.
       *
       * @type ActiveConnection
       */
      this.activeConnection = template.activeConnection;

      /**
       * A flag indicating that the active connection has been selected.
       *
       * @type Boolean
       */
      this.checked = template.checked || false;
    };

    return ActiveConnectionWrapper;
  },
]);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A service for defining the ConnectionHistoryEntryWrapper class.
 */
angular.module("settings").factory("ConnectionHistoryEntryWrapper", [
  "$injector",
  function defineConnectionHistoryEntryWrapper($injector) {
    // Required types
    var ConnectionHistoryEntry = $injector.get("ConnectionHistoryEntry");

    /**
     * Wrapper for ConnectionHistoryEntry which adds display-specific
     * properties, such as a duration.
     *
     * @constructor
     * @param {ConnectionHistoryEntry} historyEntry
     *     The ConnectionHistoryEntry that should be wrapped.
     */
    var ConnectionHistoryEntryWrapper = function ConnectionHistoryEntryWrapper(
      historyEntry
    ) {
      /**
       * The identifier of the connection associated with this history entry.
       *
       * @type String
       */
      this.connectionIdentifier = historyEntry.connectionIdentifier;

      /**
       * The name of the connection associated with this history entry.
       *
       * @type String
       */
      this.connectionName = historyEntry.connectionName;

      /**
       * The remote host associated with this history entry.
       *
       * @type String
       */
      this.remoteHost = historyEntry.remoteHost;

      /**
       * The username of the user associated with this particular usage of
       * the connection.
       *
       * @type String
       */
      this.username = historyEntry.username;

      /**
       * The time that usage began, in seconds since 1970-01-01 00:00:00 UTC.
       *
       * @type Number
       */
      this.startDate = historyEntry.startDate;

      /**
       * The time that usage ended, in seconds since 1970-01-01 00:00:00 UTC.
       * The absence of an endDate does NOT necessarily indicate that the
       * connection is still in use, particularly if the server was shutdown
       * or restarted before the history entry could be updated. To determine
       * whether a connection is still active, check the active property of
       * this history entry.
       *
       * @type Number
       */
      this.endDate = historyEntry.endDate;

      /**
       * The total amount of time the connection associated with the wrapped
       * history record was open, in seconds.
       *
       * @type Number
       */
      this.duration = this.endDate - this.startDate;

      /**
       * An object providing value and unit properties, denoting the duration
       * and its corresponding units.
       *
       * @type ConnectionHistoryEntry.Duration
       */
      this.readableDuration = null;

      // Set the duration if the necessary information is present
      if (this.endDate && this.startDate)
        this.readableDuration = new ConnectionHistoryEntry.Duration(
          this.duration
        );

      /**
       * The string to display as the duration of this history entry. If a
       * duration is available, its value and unit will be exposed to any
       * given translation string as the VALUE and UNIT substitution
       * variables respectively.
       *
       * @type String
       */
      this.readableDurationText =
        "SETTINGS_CONNECTION_HISTORY.TEXT_HISTORY_DURATION";

      // Inform user if end date is not known
      if (!this.endDate)
        this.readableDurationText =
          "SETTINGS_CONNECTION_HISTORY.INFO_CONNECTION_DURATION_UNKNOWN";
    };

    return ConnectionHistoryEntryWrapper;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Service for setting, removing, and retrieving localStorage keys. If access
 * to localStorage is disabled, or the browser does not support localStorage,
 * key values are temporarily stored in memory instead. If necessary, the same
 * functionality is also available at the localStorageServiceProvider level.
 */
angular.module("storage").provider("localStorageService", [
  function localStorageServiceProvider() {
    /**
     * Reference to this provider.
     *
     * @type localStorageServiceProvider
     */
    var provider = this;

    /**
     * Internal cache of key/value pairs stored within localStorage, updated
     * lazily as keys are retrieved, updated, or removed. If localStorage is
     * not actually available, then this cache will be the sole storage
     * location for these key/value pairs.
     *
     * @type Object.<String, String>
     */
    var storedItems = {};

    /**
     * Stores the given value within localStorage under the given key. If access
     * to localStorage is not provided/implemented by the browser, the key/value
     * pair will be stored internally (in memory) only, with the stored value
     * remaining retrievable via getItem() until the browser tab/window is
     * closed.
     *
     * @param {String} key
     *     The arbitrary, unique key under which the value should be stored.
     *
     * @param {Object} value
     *     The object to store under the given key. This may be any object that
     *     can be serialized as JSON, and will automatically be serialized as
     *     JSON prior to storage.
     */
    provider.setItem = function setItem(key, value) {
      // Store given value internally
      var data = JSON.stringify(value);
      storedItems[key] = data;

      // Additionally store value within localStorage if allowed
      try {
        if (window.localStorage) localStorage.setItem(key, data);
      } catch (ignore) {}
    };

    /**
     * Removes the item having the given key from localStorage. If access to
     * localStorage is not provided/implemented by the browser, the item is
     * removed solely from internal, in-memory storage. If no such item exists,
     * this function has no effect.
     *
     * @param {String} key
     *     The arbitrary, unique key of the item to remove from localStorage.
     */
    provider.removeItem = function removeItem(key) {
      // Evict key from internal storage
      delete storedItems[key];

      // Remove key from localStorage if allowed
      try {
        if (window.localStorage) localStorage.removeItem(key);
      } catch (ignore) {}
    };

    /**
     * Retrieves the value currently stored within localStorage for the item
     * having the given key. If access to localStorage is not
     * provided/implemented by the browser, the item is retrieved from
     * internal, in-memory storage. The retrieved value is automatically
     * deserialized from JSON prior to being returned.
     *
     * @param {String} key
     *     The arbitrary, unique key of the item to retrieve from localStorage.
     *
     * @returns {Object}
     *     The value stored within localStorage under the given key,
     *     automatically deserialized from JSON, or null if no such item is
     *     present.
     */
    provider.getItem = function getItem(key) {
      // Attempt to refresh internal storage from localStorage
      try {
        if (window.localStorage) storedItems[key] = localStorage.getItem(key);
      } catch (ignore) {}

      // Pull and parse value from internal storage, if present
      var data = storedItems[key];
      if (data) return JSON.parse(data);

      // No value defined for given key
      return null;
    };

    // Factory method required by provider
    this.$get = [
      "$injector",
      function localStorageServiceFactory($injector) {
        // Pass through all get/set/remove calls to the provider
        // implementations of the same
        return {
          setItem: provider.setItem,
          removeItem: provider.removeItem,
          getItem: provider.getItem,
        };
      },
    ];
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Factory for session-local storage. Creating session-local storage creates a
 * getter/setter with semantics tied to the user's session. If a user is logged
 * in, the storage is consistent. If the user logs out, the storage will not
 * persist new values, and attempts to retrieve the existing value will result
 * only in the default value.
 */
angular.module("storage").factory("sessionStorageFactory", [
  "$injector",
  function sessionStorageFactory($injector) {
    // Required services
    var $rootScope = $injector.get("$rootScope");
    var authenticationService = $injector.get("authenticationService");

    var service = {};

    /**
     * Creates session-local storage that uses the provided default value or
     * getter to obtain new values as necessary. Beware that if the default is
     * an object, the resulting getter provide deep copies for new values.
     *
     * @param {Function|*} [template]
     *     The default value for new users, or a getter which returns a newly-
     *     created default value.
     *
     * @param {Function} [destructor]
     *     Function which will be called just before the stored value is
     *     destroyed on logout, if a value is stored.
     *
     * @returns {Function}
     *     A getter/setter which returns or sets the current value of the new
     *     session-local storage. Newly-set values will only persist of the
     *     user is actually logged in.
     */
    service.create = function create(template, destructor) {
      /**
       * Whether new values may be stored and retrieved.
       *
       * @type Boolean
       */
      var enabled = !!authenticationService.getCurrentToken();

      /**
       * Getter which returns the default value for this storage.
       *
       * @type Function
       */
      var getter;

      // If getter provided, use that
      if (typeof template === "function") getter = template;
      // Otherwise, always create a deep copy
      else
        getter = function getCopy() {
          return angular.copy(template);
        };

      /**
       * The current value of this storage, or undefined if not yet set.
       */
      var value = undefined;

      // Reset value and allow storage when the user is logged in
      $rootScope.$on("guacLogin", function userLoggedIn() {
        enabled = true;
        value = undefined;
      });

      // Reset value and disallow storage when the user is logged out
      $rootScope.$on("guacLogout", function userLoggedOut() {
        // Call destructor before storage is teared down
        if (angular.isDefined(value) && destructor) destructor(value);

        // Destroy storage
        enabled = false;
        value = undefined;
      });

      // Return getter/setter for value
      return function sessionLocalGetterSetter(newValue) {
        // Only actually store/retrieve values if enabled
        if (enabled) {
          // Set value if provided
          if (angular.isDefined(newValue)) value = newValue;

          // Obtain new value if unset
          if (!angular.isDefined(value)) value = getter();

          // Return current value
          return value;
        }

        // Otherwise, just pretend to store/retrieve
        return angular.isDefined(newValue) ? newValue : getter();
      };
    };

    return service;
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Module which provides generic storage services.
 */
angular.module("storage", ["auth"]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which displays a button that controls the pressed state of a
 * single keyboard key.
 */
angular.module("textInput").directive("guacKey", [
  function guacKey() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        /**
         * The text to display within the key. This will be run through the
         * translation filter prior to display.
         *
         * @type String
         */
        text: "=",

        /**
         * The keysym to send within keyup and keydown events when this key
         * is pressed or released.
         *
         * @type Number
         */
        keysym: "=",

        /**
         * Whether this key is sticky. Sticky keys toggle their pressed
         * state with each click.
         *
         * @type Boolean
         * @default false
         */
        sticky: "=?",

        /**
         * Whether this key is currently pressed.
         *
         * @type Boolean
         * @default false
         */
        pressed: "=?",
      },

      templateUrl: "app/textInput/templates/guacKey.html",
      controller: [
        "$scope",
        "$rootScope",
        function guacKey($scope, $rootScope) {
          // Not sticky by default
          $scope.sticky = $scope.sticky || false;

          // Unpressed by default
          $scope.pressed = $scope.pressed || false;

          /**
           * Presses and releases this key, sending the corresponding keydown
           * and keyup events. In the case of sticky keys, the pressed state
           * is toggled, and only a single keydown/keyup event will be sent,
           * depending on the current state.
           *
           * @param {MouseEvent} event
           *     The mouse event which resulted in this function being
           *     invoked.
           */
          $scope.updateKey = function updateKey(event) {
            // If sticky, toggle pressed state
            if ($scope.sticky) $scope.pressed = !$scope.pressed;
            // For all non-sticky keys, press and release key immediately
            else {
              $rootScope.$broadcast("guacSyntheticKeydown", $scope.keysym);
              $rootScope.$broadcast("guacSyntheticKeyup", $scope.keysym);
            }

            // Prevent loss of focus due to interaction with buttons
            event.preventDefault();
          };

          // Send keyup/keydown when pressed state is altered
          $scope.$watch(
            "pressed",
            function updatePressedState(isPressed, wasPressed) {
              // If the key is pressed now, send keydown
              if (isPressed)
                $rootScope.$broadcast("guacSyntheticKeydown", $scope.keysym);
              // If the key was pressed, but is not pressed any longer, send keyup
              else if (wasPressed)
                $rootScope.$broadcast("guacSyntheticKeyup", $scope.keysym);
            }
          );
        },
      ],
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which displays the Guacamole text input method.
 */
angular.module("textInput").directive("guacTextInput", [
  function guacTextInput() {
    return {
      restrict: "E",
      replace: true,
      scope: {},

      templateUrl: "app/textInput/templates/guacTextInput.html",
      controller: [
        "$scope",
        "$rootScope",
        "$element",
        "$timeout",
        function guacTextInput($scope, $rootScope, $element, $timeout) {
          /**
           * The number of characters to include on either side of text input
           * content, to allow the user room to use backspace and delete.
           *
           * @type Number
           */
          var TEXT_INPUT_PADDING = 4;

          /**
           * The Unicode codepoint of the character to use for padding on
           * either side of text input content.
           *
           * @type Number
           */
          var TEXT_INPUT_PADDING_CODEPOINT = 0x200b;

          /**
           * Keys which should be allowed through to the client when in text
           * input mode, providing corresponding key events are received.
           * Keys in this set will be allowed through to the server.
           *
           * @type Object.<Number, Boolean>
           */
          var ALLOWED_KEYS = {
            0xfe03: true /* AltGr */,
            0xff08: true /* Backspace */,
            0xff09: true /* Tab */,
            0xff0d: true /* Enter */,
            0xff1b: true /* Escape */,
            0xff50: true /* Home */,
            0xff51: true /* Left */,
            0xff52: true /* Up */,
            0xff53: true /* Right */,
            0xff54: true /* Down */,
            0xff57: true /* End */,
            0xff64: true /* Insert */,
            0xffbe: true /* F1 */,
            0xffbf: true /* F2 */,
            0xffc0: true /* F3 */,
            0xffc1: true /* F4 */,
            0xffc2: true /* F5 */,
            0xffc3: true /* F6 */,
            0xffc4: true /* F7 */,
            0xffc5: true /* F8 */,
            0xffc6: true /* F9 */,
            0xffc7: true /* F10 */,
            0xffc8: true /* F11 */,
            0xffc9: true /* F12 */,
            0xffe1: true /* Left shift */,
            0xffe2: true /* Right shift */,
            0xffe3: true /* Left ctrl */,
            0xffe4: true /* Right ctrl */,
            0xffe9: true /* Left alt */,
            0xffea: true /* Right alt */,
            0xffff: true /* Delete */,
          };

          /**
           * Recently-sent text, ordered from oldest to most recent.
           *
           * @type String[]
           */
          $scope.sentText = [];

          /**
           * Whether the "Alt" key is currently pressed within the text input
           * interface.
           *
           * @type Boolean
           */
          $scope.altPressed = false;

          /**
           * Whether the "Ctrl" key is currently pressed within the text
           * input interface.
           *
           * @type Boolean
           */
          $scope.ctrlPressed = false;

          /**
           * The text area input target.
           *
           * @type Element
           */
          var target = $element.find(".target")[0];

          /**
           * Whether the text input target currently has focus. Setting this
           * attribute has no effect, but any bound property will be updated
           * as focus is gained or lost.
           *
           * @type Boolean
           */
          var hasFocus = false;

          target.onfocus = function targetFocusGained() {
            hasFocus = true;
            resetTextInputTarget(TEXT_INPUT_PADDING);
          };

          target.onblur = function targetFocusLost() {
            hasFocus = false;
          };

          /**
           * Whether composition is currently active within the text input
           * target element, such as when an IME is in use.
           *
           * @type Boolean
           */
          var composingText = false;

          target.addEventListener(
            "compositionstart",
            function targetComposeStart(e) {
              composingText = true;
            },
            false
          );

          target.addEventListener(
            "compositionend",
            function targetComposeEnd(e) {
              composingText = false;
            },
            false
          );

          /**
           * Translates a given Unicode codepoint into the corresponding X11
           * keysym.
           *
           * @param {Number} codepoint
           *     The Unicode codepoint to translate.
           *
           * @returns {Number}
           *     The X11 keysym that corresponds to the given Unicode
           *     codepoint, or null if no such keysym exists.
           */
          var keysymFromCodepoint = function keysymFromCodepoint(codepoint) {
            // Keysyms for control characters
            if (codepoint <= 0x1f || (codepoint >= 0x7f && codepoint <= 0x9f))
              return 0xff00 | codepoint;

            // Keysyms for ASCII chars
            if (codepoint >= 0x0000 && codepoint <= 0x00ff) return codepoint;

            // Keysyms for Unicode
            if (codepoint >= 0x0100 && codepoint <= 0x10ffff)
              return 0x01000000 | codepoint;

            return null;
          };

          /**
           * Presses and releases the key corresponding to the given keysym,
           * as if typed by the user.
           *
           * @param {Number} keysym The keysym of the key to send.
           */
          var sendKeysym = function sendKeysym(keysym) {
            $rootScope.$broadcast("guacSyntheticKeydown", keysym);
            $rootScope.$broadcast("guacSyntheticKeyup", keysym);
          };

          /**
           * Presses and releases the key having the keysym corresponding to
           * the Unicode codepoint given, as if typed by the user.
           *
           * @param {Number} codepoint
           *     The Unicode codepoint of the key to send.
           */
          var sendCodepoint = function sendCodepoint(codepoint) {
            if (codepoint === 10) {
              sendKeysym(0xff0d);
              releaseStickyKeys();
              return;
            }

            var keysym = keysymFromCodepoint(codepoint);
            if (keysym) {
              sendKeysym(keysym);
              releaseStickyKeys();
            }
          };

          /**
           * Translates each character within the given string to keysyms and
           * sends each, in order, as if typed by the user.
           *
           * @param {String} content
           *     The string to send.
           */
          var sendString = function sendString(content) {
            var sentText = "";

            // Send each codepoint within the string
            for (var i = 0; i < content.length; i++) {
              var codepoint = content.charCodeAt(i);
              if (codepoint !== TEXT_INPUT_PADDING_CODEPOINT) {
                sentText += String.fromCharCode(codepoint);
                sendCodepoint(codepoint);
              }
            }

            // Display the text that was sent
            $scope.$apply(function addSentText() {
              $scope.sentText.push(sentText);
            });

            // Remove text after one second
            $timeout(function removeSentText() {
              $scope.sentText.shift();
            }, 1000);
          };

          /**
           * Releases all currently-held sticky keys within the text input UI.
           */
          var releaseStickyKeys = function releaseStickyKeys() {
            // Reset all sticky keys
            $scope.$apply(function clearAllStickyKeys() {
              $scope.altPressed = false;
              $scope.ctrlPressed = false;
            });
          };

          /**
           * Removes all content from the text input target, replacing it
           * with the given number of padding characters. Padding of the
           * requested size is added on both sides of the cursor, thus the
           * overall number of characters added will be twice the number
           * specified.
           *
           * @param {Number} padding
           *     The number of characters to pad the text area with.
           */
          var resetTextInputTarget = function resetTextInputTarget(padding) {
            var paddingChar = String.fromCharCode(TEXT_INPUT_PADDING_CODEPOINT);

            // Pad text area with an arbitrary, non-typable character (so there is something
            // to delete with backspace or del), and position cursor in middle.
            target.value = new Array(padding * 2 + 1).join(paddingChar);
            target.setSelectionRange(padding, padding);
          };

          target.addEventListener(
            "input",
            function (e) {
              // Ignore input events during text composition
              if (composingText) return;

              var i;
              var content = target.value;
              var expectedLength = TEXT_INPUT_PADDING * 2;

              // If content removed, update
              if (content.length < expectedLength) {
                // Calculate number of backspaces and send
                var backspaceCount = TEXT_INPUT_PADDING - target.selectionStart;
                for (i = 0; i < backspaceCount; i++) sendKeysym(0xff08);

                // Calculate number of deletes and send
                var deleteCount =
                  expectedLength - content.length - backspaceCount;
                for (i = 0; i < deleteCount; i++) sendKeysym(0xffff);
              } else sendString(content);

              // Reset content
              resetTextInputTarget(TEXT_INPUT_PADDING);
              e.preventDefault();
            },
            false
          );

          // Do not allow event target contents to be selected during input
          target.addEventListener(
            "selectstart",
            function (e) {
              e.preventDefault();
            },
            false
          );

          // If the text input UI has focus, prevent keydown events
          $scope.$on(
            "guacBeforeKeydown",
            function filterKeydown(event, keysym) {
              if (hasFocus && !ALLOWED_KEYS[keysym]) event.preventDefault();
            }
          );

          // If the text input UI has focus, prevent keyup events
          $scope.$on("guacBeforeKeyup", function filterKeyup(event, keysym) {
            if (hasFocus && !ALLOWED_KEYS[keysym]) event.preventDefault();
          });

          // Attempt to focus initially
          target.focus();
        },
      ],
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Module for displaying the Guacamole text input method.
 */
angular.module("textInput", []);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which allows handling of drag gestures on a particular element.
 */
angular.module("touch").directive("guacTouchDrag", [
  function guacTouchDrag() {
    return {
      restrict: "A",

      link: function linkGuacTouchDrag($scope, $element, $attrs) {
        /**
         * Called during a drag gesture as the user's finger is placed upon
         * the element, moves, and is lifted from the element.
         *
         * @event
         * @param {Boolean} inProgress
         *     Whether the gesture is currently in progress. This will
         *     always be true except when the gesture has ended, at which
         *     point one final call will occur with this parameter set to
         *     false.
         *
         * @param {Number} startX
         *     The X location at which the drag gesture began.
         *
         * @param {Number} startY
         *     The Y location at which the drag gesture began.
         *
         * @param {Number} currentX
         *     The current X location of the user's finger.
         *
         * @param {Number} currentY
         *     The current Y location of the user's finger.
         *
         * @param {Number} deltaX
         *     The difference in X location relative to the start of the
         *     gesture.
         *
         * @param {Number} deltaY
         *     The difference in Y location relative to the start of the
         *     gesture.
         *
         * @return {Boolean}
         *     false if the default action of the touch event should be
         *     prevented, any other value otherwise.
         */
        var guacTouchDrag = $scope.$eval($attrs.guacTouchDrag);

        /**
         * The element which will register the drag gesture.
         *
         * @type Element
         */
        var element = $element[0];

        /**
         * Whether a drag gesture is in progress.
         *
         * @type Boolean
         */
        var inProgress = false;

        /**
         * The starting X location of the drag gesture.
         *
         * @type Number
         */
        var startX = null;

        /**
         * The starting Y location of the drag gesture.
         *
         * @type Number
         */
        var startY = null;

        /**
         * The current X location of the drag gesture.
         *
         * @type Number
         */
        var currentX = null;

        /**
         * The current Y location of the drag gesture.
         *
         * @type Number
         */
        var currentY = null;

        /**
         * The change in X relative to drag start.
         *
         * @type Number
         */
        var deltaX = 0;

        /**
         * The change in X relative to drag start.
         *
         * @type Number
         */
        var deltaY = 0;

        // When there is exactly one touch, monitor the change in location
        element.addEventListener(
          "touchmove",
          function dragTouchMove(e) {
            if (e.touches.length === 1) {
              e.stopPropagation();

              // Get touch location
              var x = e.touches[0].clientX;
              var y = e.touches[0].clientY;

              // Init start location and deltas if gesture is starting
              if (!startX || !startY) {
                startX = currentX = x;
                startY = currentY = y;
                deltaX = 0;
                deltaY = 0;
                inProgress = true;
              }

              // Update deltas if gesture is in progress
              else if (inProgress) {
                deltaX = x - currentX;
                deltaY = y - currentY;
                currentX = x;
                currentY = y;
              }

              // Signal start/change in drag gesture
              if (inProgress && guacTouchDrag) {
                $scope.$apply(function dragChanged() {
                  if (
                    guacTouchDrag(
                      true,
                      startX,
                      startY,
                      currentX,
                      currentY,
                      deltaX,
                      deltaY
                    ) === false
                  )
                    e.preventDefault();
                });
              }
            }
          },
          false
        );

        // Reset monitoring and fire end event when done
        element.addEventListener(
          "touchend",
          function dragTouchEnd(e) {
            if (startX && startY && e.touches.length === 0) {
              e.stopPropagation();

              // Signal end of drag gesture
              if (inProgress && guacTouchDrag) {
                $scope.$apply(function dragComplete() {
                  if (
                    guacTouchDrag(
                      true,
                      startX,
                      startY,
                      currentX,
                      currentY,
                      deltaX,
                      deltaY
                    ) === false
                  )
                    e.preventDefault();
                });
              }

              startX = currentX = null;
              startY = currentY = null;
              deltaX = 0;
              deltaY = 0;
              inProgress = false;
            }
          },
          false
        );
      },
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * A directive which allows handling of pinch gestures (pinch-to-zoom, for
 * example) on a particular element.
 */
angular.module("touch").directive("guacTouchPinch", [
  function guacTouchPinch() {
    return {
      restrict: "A",

      link: function linkGuacTouchPinch($scope, $element, $attrs) {
        /**
         * Called when a pinch gesture begins, changes, or ends.
         *
         * @event
         * @param {Boolean} inProgress
         *     Whether the gesture is currently in progress. This will
         *     always be true except when the gesture has ended, at which
         *     point one final call will occur with this parameter set to
         *     false.
         *
         * @param {Number} startLength
         *     The initial distance between the two touches of the
         *     pinch gesture, in pixels.
         *
         * @param {Number} currentLength
         *     The current distance between the two touches of the
         *     pinch gesture, in pixels.
         *
         * @param {Number} centerX
         *     The current X coordinate of the center of the pinch gesture.
         *
         * @param {Number} centerY
         *     The current Y coordinate of the center of the pinch gesture.
         *
         * @return {Boolean}
         *     false if the default action of the touch event should be
         *     prevented, any other value otherwise.
         */
        var guacTouchPinch = $scope.$eval($attrs.guacTouchPinch);

        /**
         * The element which will register the pinch gesture.
         *
         * @type Element
         */
        var element = $element[0];

        /**
         * The starting pinch distance, or null if the gesture has not yet
         * started.
         *
         * @type Number
         */
        var startLength = null;

        /**
         * The current pinch distance, or null if the gesture has not yet
         * started.
         *
         * @type Number
         */
        var currentLength = null;

        /**
         * The X coordinate of the current center of the pinch gesture.
         *
         * @type Number
         */
        var centerX = 0;

        /**
         * The Y coordinate of the current center of the pinch gesture.
         * @type Number
         */
        var centerY = 0;

        /**
         * Given a touch event, calculates the distance between the first
         * two touches in pixels.
         *
         * @param {TouchEvent} e
         *     The touch event to use when performing distance calculation.
         *
         * @return {Number}
         *     The distance in pixels between the first two touches.
         */
        var pinchDistance = function pinchDistance(e) {
          var touchA = e.touches[0];
          var touchB = e.touches[1];

          var deltaX = touchA.clientX - touchB.clientX;
          var deltaY = touchA.clientY - touchB.clientY;

          return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        };

        /**
         * Given a touch event, calculates the center between the first two
         * touches in pixels, returning the X coordinate of this center.
         *
         * @param {TouchEvent} e
         *     The touch event to use when performing center calculation.
         *
         * @return {Number}
         *     The X coordinate of the center of the first two touches.
         */
        var pinchCenterX = function pinchCenterX(e) {
          var touchA = e.touches[0];
          var touchB = e.touches[1];

          return (touchA.clientX + touchB.clientX) / 2;
        };

        /**
         * Given a touch event, calculates the center between the first two
         * touches in pixels, returning the Y coordinate of this center.
         *
         * @param {TouchEvent} e
         *     The touch event to use when performing center calculation.
         *
         * @return {Number}
         *     The Y coordinate of the center of the first two touches.
         */
        var pinchCenterY = function pinchCenterY(e) {
          var touchA = e.touches[0];
          var touchB = e.touches[1];

          return (touchA.clientY + touchB.clientY) / 2;
        };

        // When there are exactly two touches, monitor the distance between
        // them, firing zoom events as appropriate
        element.addEventListener(
          "touchmove",
          function pinchTouchMove(e) {
            if (e.touches.length === 2) {
              e.stopPropagation();

              // Calculate current zoom level
              currentLength = pinchDistance(e);

              // Calculate center
              centerX = pinchCenterX(e);
              centerY = pinchCenterY(e);

              // Init start length if pinch is not in progress
              if (!startLength) startLength = currentLength;

              // Notify of pinch status
              if (guacTouchPinch) {
                $scope.$apply(function pinchChanged() {
                  if (
                    guacTouchPinch(
                      true,
                      startLength,
                      currentLength,
                      centerX,
                      centerY
                    ) === false
                  )
                    e.preventDefault();
                });
              }
            }
          },
          false
        );

        // Reset monitoring and fire end event when done
        element.addEventListener(
          "touchend",
          function pinchTouchEnd(e) {
            if (startLength && e.touches.length < 2) {
              e.stopPropagation();

              // Notify of pinch end
              if (guacTouchPinch) {
                $scope.$apply(function pinchComplete() {
                  if (
                    guacTouchPinch(
                      false,
                      startLength,
                      currentLength,
                      centerX,
                      centerY
                    ) === false
                  )
                    e.preventDefault();
                });
              }

              startLength = null;
            }
          },
          false
        );
      },
    };
  },
]);

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Module for handling common touch gestures, like panning or pinch-to-zoom.
 */
angular.module("touch", []);
